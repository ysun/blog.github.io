{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js_bak","path":"lib/three/three-waves.min.js_bak","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"213c8b0866f9d99a3b78fdd376ec9eadcd763b42","modified":1543211864120},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543198210432},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543198210432},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543198210432},{"_id":"themes/hexo-theme-next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1543198210432},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1543198210432},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543198210432},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1543198210432},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1543198210432},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1543198210432},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1543198210432},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1543198210432},{"_id":"themes/hexo-theme-next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1543198210436},{"_id":"themes/hexo-theme-next/_config.yml","hash":"d2f92faed8810e495b08d1f914115db77e969767","modified":1543336066265},{"_id":"themes/hexo-theme-next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1543198210436},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1543198210436},{"_id":"themes/hexo-theme-next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1543198210440},{"_id":"source/_posts/.hello-world.md.swp","hash":"71c82ffee31a10f123a88d386142628e4c3ff209","modified":1544449425101},{"_id":"source/_posts/hello-world.md","hash":"e88db5dbf1609a8411c7f8307859eb967d8fdf49","modified":1543237996228},{"_id":"source/_posts/hexo-next主题.md","hash":"d0b14dbfcc520c5f945a948f52480ae0c6d1d3a7","modified":1543200799808},{"_id":"source/_posts/kvm-boot.md","hash":"92d9242cb8bdd5c41e9358df50fea1d332e0b6af","modified":1544454923349},{"_id":"source/_posts/kvm-overview.md","hash":"ccfade8fb710d73cd2064c71f965fe53151a4a8c","modified":1544457482649},{"_id":"source/_posts/qmp-introduction.md","hash":"e6f95bfcdf6a88e42171de5cb0520d9d3d29aa3e","modified":1544451344125},{"_id":"source/about/index.md","hash":"e5e02ed5a161f10cf2ab5a4d50ade6c2e73f13ce","modified":1543372889397},{"_id":"source/categories/index.md","hash":"dfe874275a566036eb6b54f5358d382ec37538bf","modified":1543311556150},{"_id":"source/tags/index.md","hash":"73e754758d6f78e0d6920a20aa1a0d605ba7c537","modified":1543311582526},{"_id":"themes/hexo-theme-next/.git/COMMIT_EDITMSG","hash":"82729f05b01f87a211af7d69e046176cdcc7ab3c","modified":1543333401074},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1543198210400},{"_id":"themes/hexo-theme-next/.git/config","hash":"91b6a53b2a7f929b698734717a38d4ac169f0c1f","modified":1543198210400},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/index","hash":"3598db9cc34308d07646d915fdefbb4bf7ed5086","modified":1543333373278},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1543198210400},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1543198210432},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1543198210432},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1543198210432},{"_id":"themes/hexo-theme-next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543198210432},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543198210440},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543198210476},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543198210476},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543198210476},{"_id":"source/_posts/.kvm-boot.md.swp","hash":"7ecd8be4883efdfbed86742a0a74ceffb704992b","modified":1544454676145},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"source/_posts/kvm-overview/01_brief.png","hash":"687e4d3b8975842568b8692cb9090910df33445f","modified":1470648291000},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"7899dfb6b1e8375d06734c944de28ca158867dca","modified":1543333401154},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1543250462395},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"2e898366e8b1581738008a97d28a3c1afaae4e3f","modified":1543207664956},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"9c3d2d7ede7ffd27c791a29db19ab8317665039a","modified":1543221165956},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"8150414f0a87608cae78ba34cb24c7fce4002533","modified":1543214420596},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"afcca4ae19c97826780dd5407ecad0cff7f29e90","modified":1543332776650},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/alipay.png","hash":"4a8675d1848a77f4ac793c186840bd79600e9111","modified":1543247222251},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"d373a666d28b34e5bef952342860120f96c64d91","modified":1543215417196},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"02ee033f52051d3895703689c2601acac03dc02c","modified":1543215417196},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","hash":"394c68c9698cccf0d0e290f4468e2cf72bc8df3d","modified":1543247241147},{"_id":"source/_posts/kvm-overview/02_kvm_framework.png","hash":"c8890d45a5d37bf3f5ced9fcc6ec5cbf020cb03e","modified":1470648411000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210436},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"0c5c7400b4e2d1a3105f7bd5a583d0c05421a20f","modified":1543234343420},{"_id":"themes/hexo-theme-next/.git/objects/16/9eb2ffc05e35418f585ed0487ba4c53c81c0fc","hash":"bf05272bfcdfdf7106ab0c29217fcddd3ac0c155","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/10/a3e6d45fb6887e8dcaa92d1d758574060025b9","hash":"e50c788f6609ea88fdcdb9c2cae2e29083445959","modified":1543298015130},{"_id":"themes/hexo-theme-next/.git/objects/18/bfd793e92771a5dc982567a8f02b2694123b37","hash":"2a905abb609376ba05d0b432c7fcfb37866bad54","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/2b/d3fc90fe5ded62417df9fd9ddd5b08c325c730","hash":"25b075de2c6836f147fc8d511e2ebb8a8f9cac1b","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/29/1894f5eba941248cada13c37dd1e7dd7e3a4cf","hash":"cc17c71a3a44cfe7e0332ab179caceec99aa7c2e","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/42/9b7aa202fdeec5b4ae60a250f8c294c2b37161","hash":"e6faba39cbfe676b4d1683864777d526f8f16834","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/4d/ff25b6103052fe7e6fb4bc05e96318c2702c60","hash":"9338ff871c8e62ca0b8a4f8147b7ff5147eaf361","modified":1543213422496},{"_id":"themes/hexo-theme-next/.git/objects/50/9a5a91aea147f43be646b147b7aa56b29952bf","hash":"3cd7d3c34ac06c079fdf4877d3efd65664e3a91f","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/37/90f333a12cefd3603ca79dcb78d20b7a810cac","hash":"792a0ee8f1f45ba3e4696f713a9f6e51d7356e01","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/3c/f3acf314c7973644712dcd78cc58756a2993c8","hash":"52dd0ae9c1e2440f3855ef53ba7e61e9ceb913d6","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/62/4905967631578ddd59926ac54bb0f1e563e5d5","hash":"ffa36487638400ed4af9bd805b91a0d90490521a","modified":1543214775404},{"_id":"themes/hexo-theme-next/.git/objects/63/34bf60cd1176d515d2d68f6d4bad95c7bccbf7","hash":"f8317764623f8de89c9dc4506772b6be275fc695","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/5f/0f701a148ccea42bb90bb1fe6aa8da0ee82ed5","hash":"95b29a7f4946bcb7c188e2e545758e6a55238dca","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/69/5688e4bc12d5ab3eeed7aaf6088351562b7525","hash":"90dc4d64f22a95d19d2c2c111b657f5b35c766ec","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/78/5c0785dba3931fbb1df61a0df6cde1efe62866","hash":"33b0e20870eeb7edc847609df9d5dc00a4acd203","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/6e/408fd5cef62b104460275644736facbd6415ca","hash":"b08f34b69701f68d8b7fc46499c81cfab7a936e5","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/60/402a030ead238a99d8ca318ab562e8b83d7b25","hash":"7b54a97b25bdab0da95190d3f84087ce5679f710","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/7a/7f5068f043e9be057658f65480031866332001","hash":"af24bffad1bc367a151cdb8d85a98ff9ca21554e","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/81/df3d0c80e7dd8ecb70f85087c5fb6e15dd2c24","hash":"97fdcd66bc4129e948036762b79a3aef9da749e2","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/78/e81028366ed7a8460923a4f562daabe8345516","hash":"07d6b10a788a79919e5459bc813687aa481cac04","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/86/df50c4e45e3182060968b16a28ae586614e5c7","hash":"316eea2421d3991ea1a65da4fdad2a7ffb8f27ba","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/89/29fad11e9bda2af8598efc8e217e925d6a4048","hash":"4c4f30df5eaa2468d1de8ea2c7513ba6ba56418d","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/90/c0e343f09e51639defc139565f93a61bbcc1bd","hash":"afbf069e6511faf8cb8fd23080c20d2b3f6c7fe5","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/99/92abe1e23367d3fb07f4c6f21574101d063228","hash":"47c4624c0074e8be159c7782348d3f469bdfd9d8","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/9d/41ca9b9b9a8da848a151336f022e2d473d88ac","hash":"febf97bc82d4e16bf9e058a82aa7cc6f1106c48b","modified":1543214785736},{"_id":"themes/hexo-theme-next/.git/objects/a0/b38932cd483608a2f63360949dd0972d7eb7b1","hash":"675e36ce4676a9b54d4878452538373555e1e3bf","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/82/4452372d95e7755f2384a575dd1ef91c5a7d0a","hash":"b5e09bb736530149d158736bacc065a21b82dcc4","modified":1543297989406},{"_id":"themes/hexo-theme-next/.git/objects/a7/9331076af22ec66070d83d30f25087acf3d237","hash":"2de7a9d6fbfe649da56439b9e0d9e9459890506f","modified":1543333401154},{"_id":"themes/hexo-theme-next/.git/objects/b1/ec1e651ae883d36e33f8eacf1696d4edef918d","hash":"0c2d52941828d7bd6f0845ed61cbd11d2416553e","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/b4/64f6dafab7a41c078014c5d9cc9ab81fac6777","hash":"4dcaadb6c50730a73759b48121de6fe06a8f5603","modified":1543213407988},{"_id":"themes/hexo-theme-next/.git/objects/b9/803934a40f25bfcecd104208511e0fee2e8f0d","hash":"15a8b7fdff7200002cf72e421cc26255a284a94d","modified":1543214785740},{"_id":"themes/hexo-theme-next/.git/objects/bb/eba543f8b15d21c13b248a735d5f5a30560e47","hash":"a2f7da0f8cac0360183a1ab5a86adf3049e793e6","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/cb/2074bc6441f6c1c5544423450119535dbf1f97","hash":"8f04a1088bcca56f8e9d205907a63f59d07fb269","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/ce/788c95c0a4dcad866336e2d5e75b9f0b523a9d","hash":"842c27c6fe8420adc5f4eb6b3fb3cd0893c15569","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/b2/d2b09f1701f19c58964e55c433ac6be68d91ab","hash":"a74229eaf1047a37b41748f4be37336333abc54e","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/db/dafe0f54bd0dbb1af9898297405916bbf057b8","hash":"60ab3468707e46f709f035338c5e86fde5e9c254","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/e0/eb5c634230d03e1b6585993cf66e92c20f88f3","hash":"e64f6fe1d001eb90367b9afd213d5b671658721a","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/e2/5db23791e767351856c760ab4ef7321e12be93","hash":"8b78f13a8c78413f266530a2361647a9199a8b24","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/ce/7c13317179a91572e7c811b8d957aac6e65213","hash":"f2be785a11d28573284bd19834718a56f4d92ac2","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/bd/3fe93bdceb73ab30480553cd465eedeb3f4c11","hash":"d1f6a486a29fc3c810af3ef1b581da3c77ed961a","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/e5/2211f4c3f4a0c5c1c951fe6f3be0a701621244","hash":"b29a12dce7b0df391d660db19bf3959024f408a0","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/e4/53c05ef037b992278f898d5c9b76128235f8cd","hash":"fe57ca5be56ac6ffc6907624f772e7a2d6738f34","modified":1543214785736},{"_id":"themes/hexo-theme-next/.git/objects/eb/f65a2b528d8fef462630bfba89eb9c0ee07cda","hash":"3926268976f8f4ca9470bfa8283bd06e394ea881","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/f1/8ffc0da06b9982954f6b762cacbb5230da2ec5","hash":"179e837adca396486d5df6c25502153a78de42bc","modified":1543214800652},{"_id":"themes/hexo-theme-next/.git/objects/f3/e18667444d17e2fdcd2787d7166f5e44b1e0aa","hash":"c3d64b98defa1154bba3db288049f08bca8b5113","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/f6/ed20eb3a091b588e97c1051b438bbc39c6b690","hash":"7b46f8ebe2b667dd273752bfdf68faf40946a7bb","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/f8/53efa1038e1371714ff00bcfa76e36487fa528","hash":"b7c7f365e05ef9200b34a2426bc46df4debc0983","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/ff/6ab5b0ef6de998a784b473bdd558ffd429ad3d","hash":"3a06eb7ef7ea76317bb116bdca0d0ae5bd57925f","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"a8222a434109f21997ad0e1143a230bbe747181b","modified":1543333401154},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"4aa55cd424389cf5626aa019c15ef6f3e4da09f2","modified":1543213032024},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1543301721166},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"c01ae2e4235083b6730f9e4a72752bd27376460f","modified":1543236451792},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1543327167994},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"48e5996d879f2e447cc2c644b15b3b93da938e37","modified":1543333318138},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js_bak","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1543331018646},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543198210476},{"_id":"themes/hexo-theme-next/.git/objects/22/66940d887bf6631b3ebd1264ac572c34772e46","hash":"207d1151a2b8f1752aeb159583e76122c414ffd0","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/67/eb67dacdd7f138338aa7d23f13acba6bcdc9a3","hash":"a3decff22ead4b5aeab5a0fb27186b0415b8846f","modified":1543250843843},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543198210472},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"7899dfb6b1e8375d06734c944de28ca158867dca","modified":1543333401154},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1543198210400},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543198210476},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"c062995329302467dfa0b23c8e61110eea673e08","modified":1543198210400},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"78946c9e8c497ddd0d8d842f5515c2e452461e82","modified":1543250624783},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"aa979335caa23e77d79833a9c3304395614412a8","modified":1543235620568},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1543198210464},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543198210464},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1543198210472},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-085ca2fa71864e32c411aee65ef48ec3c9cd3307.idx","hash":"dcb75fb4289ca234c6610fc60f971a0713507ead","modified":1543198210196},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1543198210468},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-085ca2fa71864e32c411aee65ef48ec3c9cd3307.pack","hash":"d490685f539b63cd1dd5879b056a8c129f389d66","modified":1543333368000},{"_id":"source/_posts/.kvm-cpu.md.swp","hash":"ac83534f73b29f7ed7d92d54fbfc3059f0d3635a","modified":1544455575089},{"_id":"source/_posts/kvm-cpu.md","hash":"be26f43db6a8d06a6cb81c87c903d457bc815ecf","modified":1544455575033},{"_id":"source/_posts/kvm-memory.md","hash":"c7bd49ad3f19187e359d8c989df08cb2d23e6f6e","modified":1544456576429},{"_id":"source/_posts/kvm-cpu/vmm_guest_switch.png","hash":"211beafc6cf39027f8d5d4603f14658a668e9c51","modified":1470814108000},{"_id":"source/_posts/kvm-memory/gpa_hpa.png","hash":"d427367cd272b4c65dbe629222bf70f476cf7137","modified":1471335474000},{"_id":"source/_posts/kvm-memory/gpa_hpa2.png","hash":"dced64d97cf2b9ffe18649a44abe3449f2af87da","modified":1471334754000},{"_id":"source/_posts/kvm-memory/gpa_hpa4.png","hash":"69d2ca2ad87b8a8ffc4224abcb9cfcb9f05209b4","modified":1471336218000},{"_id":"source/_posts/kvm-memory/gpa_hpa3_shadow.png","hash":"e94f9351b678e66ca82407b6af2640c0de5dec5a","modified":1471335724000},{"_id":"source/_posts/kvm-memory/logical_address.png","hash":"b6442991e95d16255a2033b1f74d5a44d8efff7a","modified":1471331488000},{"_id":"source/_posts/kvm-cpu/vcpu-follow.png","hash":"42405e69514a7b136ce6bcaa83c3b04da9c11ed1","modified":1470800509000},{"_id":"source/_posts/kvm-memory/gpa_hpa5_ept.png","hash":"0b4e906c590a8a680ebe710ec37440b120ca1ef4","modified":1471337979000},{"_id":"source/_posts/kvm-cpu/vcpu-ring.png","hash":"bebcc569ba07e6b2a362f45df5843a8b114893ad","modified":1470813442000},{"_id":"source/_posts/kvm-memory/page.png","hash":"f619079a24e1a1d13ef6c54e01eebe465568d57a","modified":1471332158000},{"_id":"public/baidusitemap.xml","hash":"877c535e3ce695a6fe6a8de239b30c1e8be00366","modified":1544458585564},{"_id":"public/CNAME","hash":"697d8d2c5a646183e54be47e4724d112f232658d","modified":1544458585564},{"_id":"public/search.xml","hash":"bde11f2087545e97058e187113cb5c35d9514c4c","modified":1544458585570},{"_id":"public/sitemap.xml","hash":"c37a38ef4a0346199abc878e6f28b0cf646d7192","modified":1544458585570},{"_id":"public/about/index.html","hash":"5d2b93e2297b6d0894fa6a3671626e540eb145e1","modified":1544458585750},{"_id":"public/categories/index.html","hash":"e52a031aeff38e732c908a19a0db15aa831e5eb2","modified":1544458585750},{"_id":"public/tags/index.html","hash":"d0c0a9843ace802e8386e30b414ed26d59da4af0","modified":1544458585752},{"_id":"public/2018/12/10/kvm-overview/index.html","hash":"d2cb934bac142c680a4f7230d4ca32bf398917f2","modified":1544458585753},{"_id":"public/2018/12/10/qmp-introduction/index.html","hash":"34127608198864e4fbf3267224fd76ff6dcfc802","modified":1544458585753},{"_id":"public/2018/11/26/hello-world/index.html","hash":"22a38ad8524cdb43b6a6b950b42f664fb8888517","modified":1544458585753},{"_id":"public/2018/11/26/hexo-next主题/index.html","hash":"000e21a6d582332cd94bd0ff28db780a01c1c663","modified":1544458585753},{"_id":"public/archives/index.html","hash":"5c867849a95949d29dff97c875fb03db44d330b8","modified":1544458585753},{"_id":"public/archives/2018/index.html","hash":"2ae38f89f4fa73b047c6a035f349796120af4967","modified":1544458585753},{"_id":"public/archives/2018/11/index.html","hash":"6de801faf772509faee7569936cfc14b5a6dd756","modified":1544458585753},{"_id":"public/archives/2018/12/index.html","hash":"2233d8b1e9744d3d9ecfc211e4f59e0be535a033","modified":1544458585753},{"_id":"public/categories/KVM/index.html","hash":"b5fea5ff9c33d46f24c3918ba9b7a6413798bac3","modified":1544458585753},{"_id":"public/categories/QEMU/index.html","hash":"e1c90bb598e88db88c66f2dc18e20544f9452412","modified":1544458585753},{"_id":"public/index.html","hash":"352f0071a169f718036737c243ca82826ea59a6f","modified":1544458585753},{"_id":"public/tags/KVM/index.html","hash":"9fad7f260f50b9e9fa5232fc82c7c1e7af6f55d2","modified":1544458585753},{"_id":"public/tags/QEMU/index.html","hash":"d69f1e53dfbf2863779bf4fc3763c4c43221f2b8","modified":1544458585753},{"_id":"public/tags/QMP/index.html","hash":"17d964ef5168aae4c196d7d5b45a740bd07683a4","modified":1544458585753},{"_id":"public/2018/12/10/kvm-memory/index.html","hash":"db4f5ec309a029a06a234c0b3c3a119258a96a53","modified":1544458585756},{"_id":"public/2018/12/10/kvm-cpu/index.html","hash":"9b8b15a063e00ce0c43595d6075a9fd76f9c0866","modified":1544458585756},{"_id":"public/2018/12/10/kvm-boot/index.html","hash":"3da60d356210e860052953613595fc215f31f4f5","modified":1544458585756},{"_id":"public/2018/12/10/kvm-cpu/vmm_guest_switch.png","hash":"211beafc6cf39027f8d5d4603f14658a668e9c51","modified":1544458585757},{"_id":"public/2018/12/10/kvm-memory/logical_address.png","hash":"b6442991e95d16255a2033b1f74d5a44d8efff7a","modified":1544458585757},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa.png","hash":"d427367cd272b4c65dbe629222bf70f476cf7137","modified":1544458585757},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa2.png","hash":"dced64d97cf2b9ffe18649a44abe3449f2af87da","modified":1544458585757},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa4.png","hash":"69d2ca2ad87b8a8ffc4224abcb9cfcb9f05209b4","modified":1544458585757},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa3_shadow.png","hash":"e94f9351b678e66ca82407b6af2640c0de5dec5a","modified":1544458585757},{"_id":"public/2018/12/10/kvm-cpu/vcpu-follow.png","hash":"42405e69514a7b136ce6bcaa83c3b04da9c11ed1","modified":1544458585759},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa5_ept.png","hash":"0b4e906c590a8a680ebe710ec37440b120ca1ef4","modified":1544458585759},{"_id":"public/2018/12/10/kvm-cpu/vcpu-ring.png","hash":"bebcc569ba07e6b2a362f45df5843a8b114893ad","modified":1544458585760},{"_id":"public/2018/12/10/kvm-memory/page.png","hash":"f619079a24e1a1d13ef6c54e01eebe465568d57a","modified":1544458585760}],"Category":[{"name":"KVM","_id":"cjpigecwf0007bpo4obwalb4g"},{"name":"QEMU","_id":"cjpigecwh0009bpo4lbsrv9ft"}],"Data":[],"Page":[{"title":"关于“Yi颗烂樱桃”","date":"2018-11-26T02:54:13.000Z","comments":0,"_content":"\n本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。\n计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。\n就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。\n目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。\n平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。\n希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。\n我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。\n之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。\n欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。\n很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！\n","source":"about/index.md","raw":"---\ntitle: 关于“Yi颗烂樱桃”\ndate: 2018-11-26 10:54:13\ncomments: false\n---\n\n本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。\n计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。\n就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。\n目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。\n平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。\n希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。\n我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。\n之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。\n欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。\n很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！\n","updated":"2018-11-28T02:41:29.397Z","path":"about/index.html","layout":"page","_id":"cjpigecwa0001bpo4kwy3s63i","content":"<p>本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。<br>计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。<br>就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。<br>目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。<br>平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。<br>希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。<br>我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。<br>之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。<br>欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。<br>很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。<br>计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。<br>就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。<br>目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。<br>平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。<br>希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。<br>我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。<br>之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。<br>欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。<br>很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！</p>\n"},{"title":"categories","date":"2018-11-26T03:21:05.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-26 11:21:05\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-27T09:39:16.150Z","path":"categories/index.html","layout":"page","_id":"cjpigecwc0003bpo4o7vkvr7x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-26T03:23:32.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-26 11:23:32\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-27T09:39:42.526Z","path":"tags/index.html","layout":"page","_id":"cjpigecwd0005bpo4ak5b87kw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","donate":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndonate: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-11-26T13:13:16.288Z","updated":"2018-11-26T13:13:16.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpigecw70000bpo425c8cvrz","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"hexo+next主题","date":"2018-11-26T02:49:59.000Z","_content":"\n这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。\n另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~\n\n从印象笔记到简书到Hexo\n我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。\n\n但使用了简书3个月之后，我就发现了一些问题：\n\n首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；\n\n其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；\n\n另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；\n\n在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。\n\nHexo部署\nhexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。\n\n安装前提\n安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：\n\nimage-20180809141924679\n安装Hexo\n安装好node.js和git后，可以通过npm来安装Hexo。\n\nnpm install -g hexo-cli\n建站\n之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：\n\nhexo init <folder>\ncd <folder>\nnpm install\n<folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。\n\n文件夹开始初始化了\n站内内容\n新建好的文件夹目录如下：\n\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n这里解释一下各个文件夹的作用：\n\nconfig.yml\n博客的配置文件，博客的名称、关键词、作者、语言、博客主题...设置都在里面。\n\npackage.json\n应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。\n\nscaffolds\nscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。\n\n这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容\n\nsource\nsource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。\n\nthemes\n放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。\n\n初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。\n\nHexo命令\ninit\n新建一个网站。\n\nhexo init <folder>\nnew\n新建文章或页面。\n\nhexo new <layout> \"title\"\n这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。\n\n默认是添加posts。\n\n然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。\n\ngenerate\n生成静态页面\n\nhexo generate\n也可以简写成\n\nhexo g\ndeploy\n将内容部署到网站\n\nhexo deploy\n也可以简写成\n\nhexo -d\npublish\n发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。\n\nhexo publish <layout> <filename>\nserver\n启动服务器，默认情况下，访问网站为http://localhost:4000/\n\nhexo server\n也可以简写成\n\nhexo s\n根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：\n\nhexo n <filename> 新建文章\nhexo s 启动服务器，在本地查看内容\nhexo g 生成静态页面\nhexo deploy 部署到网站\n以上四个步骤。\n\n其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。\n\n搭建好后我们在localhost:4000就可以看到这样的博客内容：\n\nimage-20180809152743968\n实际操作\n我在新建博客之后，做了以下改动：\n\n1. 创建“分类”页面\n新建分类页面\n\nhexo new page categories\n给分类页面添加类型\n\n我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。\n\n---\ntitle: 文章分类\ndate: 2017-05-27 13:47:40\ntype: \"categories\"   #这部分是新添加的\n---\n给模板添加分类属性\n\n现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。\n\ntitle: {{ title }}\ndate: {{ date }}\ncategories:\ntags:\n给文章添加分类\n\n现在我们可以找到一篇文章，然后尝试给它添加分类\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n2. 创建“标签”页面\n创建\"标签\"页的方式和创建“分类”一样。\n\n新建“标签”页面\n\nhexo new page tags\n给标签页面添加类型\n\n我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。\n\ntitle: tags\ndate: 2018-08-06 22:48:29\ntype: \"tags\" #新添加的内容\n给文章添加标签\n\n有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n第二种写法是用-短划线列出来\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: \n- node.js\n- express\n部署域名\n紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。\n\n部署Github\n首先你必须有一个github账号\n\n然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)\n\nimage-20180809153134467\n然后在setting里添加生成页面的选项\n\nimage-20180809153304980\nimage-20180809153343362\n这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径\n\nimage-20180809153610047\n这里注意两小点：\n\n属性和内容之间一定要有一个空格，配置文件有自己的格式规范\n如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程\n我们再用hexo g && hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了\n\nimage-20180809153933270\n部署自己的域名\n首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；\n\n购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；\n\n认证成功后需要解析域名\n\nimage-20180809154942783\nimage-20180809155013659\n记录类型选CNAME，记录值是自己github生成页面的地址。\n\n在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下\n\n这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可\n\nnpm i hexo-generator-cname --save\n最后hexo g && hexo deploy就可以了\n\nNexT主题\nhexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。\n\n首先，NexT也有中文文档，然后我们就可以开始了。\n\n安装\n我是用的git clone的方法，文档中还有其他方法\n\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n设置主题\n在hexo根目录下的配置文件config.yml里设置主题\n\ntheme: next\n配置主题\n接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。\n\n官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用\n\n菜单栏 menu\n原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n注意点：\n\n如果事先没有通过hexo new page <pageName>来创建页面的话，即使在配置文件中取消注释，页面也没法显示\n我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里\n||后面是fontAwesome里的文件对应的名称\nmenu_icons记得选enable: true（默认应该是true）\n我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  读书: /books || book\n  电影: /movies || film\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n主题风格 schemes\n主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。\n\nMuse\n\nimage-20180809164700600\nMist\n\nimage-20180809164749052\nPisces\n\nimage-20180809164925685\nGemini\n\nimage-20180809165023401\n选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。\n\n底部建站时间和图标修改\n修改主题的配置文件：\n\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  since: 2018\n\n  # Icon between year and copyright info.\n  icon: snowflake-o\n\n  # If not defined, will be used `author` from Hexo main config.\n  copyright:\n  # -------------------------------------------------------------\n  # Hexo link (Powered by Hexo).\n  powered: false\n\n  theme:\n    # Theme & scheme info link (Theme - NexT.scheme).\n    enable: false\n    # Version info of NexT after scheme info (vX.X.X).\n    # version: false\n我在这部分做了这样几件事：\n\n把用户的图标从小人user改成了雪花snowflake-o\ncopyright留空，显示成页面author即我的名字\npowered: false把hexo的授权图片取消了\ntheme: enable:false 把主题的内容也取消了\n这样底部信息比较简单。\n\nimage-20180809172835606\n个人社交信息 social\n在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。\n\nsocial:\n  GitHub: https://github.com/XuQuan-nikkkki || github\n  E-Mail: mailto:xuquan1225@hotmail.com || envelope\n  #Google: https://plus.google.com/yourname || google\n  #Twitter: https://twitter.com/yourname || twitter\n  #FB Page: https://www.facebook.com/yourname || facebook\n注意点：\n\n||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标\n建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球\n网站动画效果\n为了网站响应速度我们可以把网站的动画关掉\n\nmotion:\n  enable: false\n但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。\n\nmotion:\n  enable: true\n  async: true\n  \n# Canvas-nest\ncanvas_nest: true\n\n# three_waves\nthree_waves: false\n\n# canvas_lines\ncanvas_lines: false\n\n# canvas_sphere\ncanvas_sphere: false\n评论系统\nNexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。\n\n方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。\n\n# Disqus\ndisqus:\n  enable: true\n  shortname: xuquan\n  count: true\n统计文章字数和阅读时间\npost_wordcount:\n  item_text: true\n  wordcount: true  # 文章字数\n  min2read: true   # 阅读时间\n  totalcount: true  # 总共字数\n  separated_meta: true\n统计阅读次数\n这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：\n\nimage-20180809175133462\n第三方插件\nHexo-admin\nHexo-admin插件允许我们直接在本地页面上修改文章内容。\n\n下载\n\nnpm i hexo-admin --save\n登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\n\nHexo-douban\nhexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。\n\n下载\n\nnpm install hexo-douban --save\n配置\n\n在hexo根目录下的config.yml文件中添加如下内容\n\ndouban:\n  user: \n  builtin: false\n  book:\n    title: 'This is my book title'\n    quote: 'This is my book quote'\n  movie:\n    title: 'This is my movie title'\n    quote: 'This is my movie quote'\n  game:\n    title: 'This is my game title'\n    quote: 'This is my game quote'\n  timeout: 10000 \ntitle和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。\n\nuser就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。\n\n生成页面\n\nhexo douban   #生成读书、电影、游戏三个页面\nhexo douban -b  #生成读书页面\nhexo douban -m  #生成电影页面\nhexo douban -g  #生成游戏页面\n在博客中生成页面\n\n这里就需要用到我们前面提过的hexo new命令了。\n\nhexo new page books\nhexo new page movies\nhexo new page games\n在博客中添加页面\n\n在menu部分添加我们需要添加的页面名称和相对路径\n\nmenu:\n  Home: /\n  Archives: /archives\n  Books: /books     #This is your books page\n  Movies: /movies   #This is your movies page\n  Games: /games   #This is your games page\n部署到博客\n\nhexo g && hexo deploy\n我踩过的坑\niPic图片上传\nhexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。\n\n但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。\n\n我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。\n\n评论系统\n因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。\n","source":"_posts/hexo-next主题.md","raw":"---\ntitle: hexo+next主题\ndate: 2018-11-26 10:49:59\ntags:\n---\n\n这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。\n另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~\n\n从印象笔记到简书到Hexo\n我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。\n\n但使用了简书3个月之后，我就发现了一些问题：\n\n首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；\n\n其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；\n\n另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；\n\n在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。\n\nHexo部署\nhexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。\n\n安装前提\n安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：\n\nimage-20180809141924679\n安装Hexo\n安装好node.js和git后，可以通过npm来安装Hexo。\n\nnpm install -g hexo-cli\n建站\n之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：\n\nhexo init <folder>\ncd <folder>\nnpm install\n<folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。\n\n文件夹开始初始化了\n站内内容\n新建好的文件夹目录如下：\n\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n这里解释一下各个文件夹的作用：\n\nconfig.yml\n博客的配置文件，博客的名称、关键词、作者、语言、博客主题...设置都在里面。\n\npackage.json\n应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。\n\nscaffolds\nscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。\n\n这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容\n\nsource\nsource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。\n\nthemes\n放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。\n\n初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。\n\nHexo命令\ninit\n新建一个网站。\n\nhexo init <folder>\nnew\n新建文章或页面。\n\nhexo new <layout> \"title\"\n这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。\n\n默认是添加posts。\n\n然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。\n\ngenerate\n生成静态页面\n\nhexo generate\n也可以简写成\n\nhexo g\ndeploy\n将内容部署到网站\n\nhexo deploy\n也可以简写成\n\nhexo -d\npublish\n发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。\n\nhexo publish <layout> <filename>\nserver\n启动服务器，默认情况下，访问网站为http://localhost:4000/\n\nhexo server\n也可以简写成\n\nhexo s\n根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：\n\nhexo n <filename> 新建文章\nhexo s 启动服务器，在本地查看内容\nhexo g 生成静态页面\nhexo deploy 部署到网站\n以上四个步骤。\n\n其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。\n\n搭建好后我们在localhost:4000就可以看到这样的博客内容：\n\nimage-20180809152743968\n实际操作\n我在新建博客之后，做了以下改动：\n\n1. 创建“分类”页面\n新建分类页面\n\nhexo new page categories\n给分类页面添加类型\n\n我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。\n\n---\ntitle: 文章分类\ndate: 2017-05-27 13:47:40\ntype: \"categories\"   #这部分是新添加的\n---\n给模板添加分类属性\n\n现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。\n\ntitle: {{ title }}\ndate: {{ date }}\ncategories:\ntags:\n给文章添加分类\n\n现在我们可以找到一篇文章，然后尝试给它添加分类\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n2. 创建“标签”页面\n创建\"标签\"页的方式和创建“分类”一样。\n\n新建“标签”页面\n\nhexo new page tags\n给标签页面添加类型\n\n我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。\n\ntitle: tags\ndate: 2018-08-06 22:48:29\ntype: \"tags\" #新添加的内容\n给文章添加标签\n\n有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n第二种写法是用-短划线列出来\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: \n- node.js\n- express\n部署域名\n紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。\n\n部署Github\n首先你必须有一个github账号\n\n然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)\n\nimage-20180809153134467\n然后在setting里添加生成页面的选项\n\nimage-20180809153304980\nimage-20180809153343362\n这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径\n\nimage-20180809153610047\n这里注意两小点：\n\n属性和内容之间一定要有一个空格，配置文件有自己的格式规范\n如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程\n我们再用hexo g && hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了\n\nimage-20180809153933270\n部署自己的域名\n首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；\n\n购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；\n\n认证成功后需要解析域名\n\nimage-20180809154942783\nimage-20180809155013659\n记录类型选CNAME，记录值是自己github生成页面的地址。\n\n在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下\n\n这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可\n\nnpm i hexo-generator-cname --save\n最后hexo g && hexo deploy就可以了\n\nNexT主题\nhexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。\n\n首先，NexT也有中文文档，然后我们就可以开始了。\n\n安装\n我是用的git clone的方法，文档中还有其他方法\n\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n设置主题\n在hexo根目录下的配置文件config.yml里设置主题\n\ntheme: next\n配置主题\n接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。\n\n官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用\n\n菜单栏 menu\n原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n注意点：\n\n如果事先没有通过hexo new page <pageName>来创建页面的话，即使在配置文件中取消注释，页面也没法显示\n我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里\n||后面是fontAwesome里的文件对应的名称\nmenu_icons记得选enable: true（默认应该是true）\n我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  读书: /books || book\n  电影: /movies || film\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n主题风格 schemes\n主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。\n\nMuse\n\nimage-20180809164700600\nMist\n\nimage-20180809164749052\nPisces\n\nimage-20180809164925685\nGemini\n\nimage-20180809165023401\n选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。\n\n底部建站时间和图标修改\n修改主题的配置文件：\n\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  since: 2018\n\n  # Icon between year and copyright info.\n  icon: snowflake-o\n\n  # If not defined, will be used `author` from Hexo main config.\n  copyright:\n  # -------------------------------------------------------------\n  # Hexo link (Powered by Hexo).\n  powered: false\n\n  theme:\n    # Theme & scheme info link (Theme - NexT.scheme).\n    enable: false\n    # Version info of NexT after scheme info (vX.X.X).\n    # version: false\n我在这部分做了这样几件事：\n\n把用户的图标从小人user改成了雪花snowflake-o\ncopyright留空，显示成页面author即我的名字\npowered: false把hexo的授权图片取消了\ntheme: enable:false 把主题的内容也取消了\n这样底部信息比较简单。\n\nimage-20180809172835606\n个人社交信息 social\n在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。\n\nsocial:\n  GitHub: https://github.com/XuQuan-nikkkki || github\n  E-Mail: mailto:xuquan1225@hotmail.com || envelope\n  #Google: https://plus.google.com/yourname || google\n  #Twitter: https://twitter.com/yourname || twitter\n  #FB Page: https://www.facebook.com/yourname || facebook\n注意点：\n\n||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标\n建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球\n网站动画效果\n为了网站响应速度我们可以把网站的动画关掉\n\nmotion:\n  enable: false\n但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。\n\nmotion:\n  enable: true\n  async: true\n  \n# Canvas-nest\ncanvas_nest: true\n\n# three_waves\nthree_waves: false\n\n# canvas_lines\ncanvas_lines: false\n\n# canvas_sphere\ncanvas_sphere: false\n评论系统\nNexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。\n\n方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。\n\n# Disqus\ndisqus:\n  enable: true\n  shortname: xuquan\n  count: true\n统计文章字数和阅读时间\npost_wordcount:\n  item_text: true\n  wordcount: true  # 文章字数\n  min2read: true   # 阅读时间\n  totalcount: true  # 总共字数\n  separated_meta: true\n统计阅读次数\n这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：\n\nimage-20180809175133462\n第三方插件\nHexo-admin\nHexo-admin插件允许我们直接在本地页面上修改文章内容。\n\n下载\n\nnpm i hexo-admin --save\n登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\n\nHexo-douban\nhexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。\n\n下载\n\nnpm install hexo-douban --save\n配置\n\n在hexo根目录下的config.yml文件中添加如下内容\n\ndouban:\n  user: \n  builtin: false\n  book:\n    title: 'This is my book title'\n    quote: 'This is my book quote'\n  movie:\n    title: 'This is my movie title'\n    quote: 'This is my movie quote'\n  game:\n    title: 'This is my game title'\n    quote: 'This is my game quote'\n  timeout: 10000 \ntitle和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。\n\nuser就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。\n\n生成页面\n\nhexo douban   #生成读书、电影、游戏三个页面\nhexo douban -b  #生成读书页面\nhexo douban -m  #生成电影页面\nhexo douban -g  #生成游戏页面\n在博客中生成页面\n\n这里就需要用到我们前面提过的hexo new命令了。\n\nhexo new page books\nhexo new page movies\nhexo new page games\n在博客中添加页面\n\n在menu部分添加我们需要添加的页面名称和相对路径\n\nmenu:\n  Home: /\n  Archives: /archives\n  Books: /books     #This is your books page\n  Movies: /movies   #This is your movies page\n  Games: /games   #This is your games page\n部署到博客\n\nhexo g && hexo deploy\n我踩过的坑\niPic图片上传\nhexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。\n\n但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。\n\n我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。\n\n评论系统\n因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。\n","slug":"hexo-next主题","published":1,"updated":"2018-11-26T02:53:19.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpigecwb0002bpo4tm9w1vg2","content":"<p>这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。<br>另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~</p>\n<p>从印象笔记到简书到Hexo<br>我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。</p>\n<p>但使用了简书3个月之后，我就发现了一些问题：</p>\n<p>首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；</p>\n<p>其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；</p>\n<p>另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；</p>\n<p>在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。</p>\n<p>Hexo部署<br>hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。</p>\n<p>安装前提<br>安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：</p>\n<p>image-20180809141924679<br>安装Hexo<br>安装好node.js和git后，可以通过npm来安装Hexo。</p>\n<p>npm install -g hexo-cli<br>建站<br>之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：</p>\n<p>hexo init <folder><br>cd <folder><br>npm install</folder></folder></p>\n<p><folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。</folder></p>\n<p>文件夹开始初始化了<br>站内内容<br>新建好的文件夹目录如下：</p>\n<p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>这里解释一下各个文件夹的作用：</p>\n<p>config.yml<br>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p>\n<p>package.json<br>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p>\n<p>scaffolds<br>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p>\n<p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p>\n<p>source<br>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p>\n<p>themes<br>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p>\n<p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p>\n<p>Hexo命令<br>init<br>新建一个网站。</p>\n<p>hexo init <folder><br>new<br>新建文章或页面。</folder></p>\n<p>hexo new <layout> “title”<br>这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。</layout></layout></p>\n<p>默认是添加posts。</p>\n<p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p>\n<p>generate<br>生成静态页面</p>\n<p>hexo generate<br>也可以简写成</p>\n<p>hexo g<br>deploy<br>将内容部署到网站</p>\n<p>hexo deploy<br>也可以简写成</p>\n<p>hexo -d<br>publish<br>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p>\n<p>hexo publish <layout> <filename><br>server<br>启动服务器，默认情况下，访问网站为<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></filename></layout></p>\n<p>hexo server<br>也可以简写成</p>\n<p>hexo s<br>根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：</p>\n<p>hexo n <filename> 新建文章<br>hexo s 启动服务器，在本地查看内容<br>hexo g 生成静态页面<br>hexo deploy 部署到网站<br>以上四个步骤。</filename></p>\n<p>其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。</p>\n<p>搭建好后我们在localhost:4000就可以看到这样的博客内容：</p>\n<p>image-20180809152743968<br>实际操作<br>我在新建博客之后，做了以下改动：</p>\n<ol>\n<li>创建“分类”页面<br>新建分类页面</li>\n</ol>\n<p>hexo new page categories<br>给分类页面添加类型</p>\n<p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<hr>\n<p>title: 文章分类<br>date: 2017-05-27 13:47:40</p>\n<h2 id=\"type-“categories”-这部分是新添加的\"><a href=\"#type-“categories”-这部分是新添加的\" class=\"headerlink\" title=\"type: “categories”   #这部分是新添加的\"></a>type: “categories”   #这部分是新添加的</h2><p>给模板添加分类属性</p>\n<p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>\n<p>title: hexo+next主题<br>date: 1543200599000<br>categories:<br>tags:<br>给文章添加分类</p>\n<p>现在我们可以找到一篇文章，然后尝试给它添加分类</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]</p>\n<ol start=\"2\">\n<li>创建“标签”页面<br>创建”标签”页的方式和创建“分类”一样。</li>\n</ol>\n<p>新建“标签”页面</p>\n<p>hexo new page tags<br>给标签页面添加类型</p>\n<p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<p>title: tags<br>date: 2018-08-06 22:48:29<br>type: “tags” #新添加的内容<br>给文章添加标签</p>\n<p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]<br>第二种写法是用-短划线列出来</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: </p>\n<ul>\n<li>node.js</li>\n<li>express<br>部署域名<br>紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。</li>\n</ul>\n<p>部署Github<br>首先你必须有一个github账号</p>\n<p>然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)</p>\n<p>image-20180809153134467<br>然后在setting里添加生成页面的选项</p>\n<p>image-20180809153304980<br>image-20180809153343362<br>这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径</p>\n<p>image-20180809153610047<br>这里注意两小点：</p>\n<p>属性和内容之间一定要有一个空格，配置文件有自己的格式规范<br>如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程<br>我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了</p>\n<p>image-20180809153933270<br>部署自己的域名<br>首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；</p>\n<p>购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；</p>\n<p>认证成功后需要解析域名</p>\n<p>image-20180809154942783<br>image-20180809155013659<br>记录类型选CNAME，记录值是自己github生成页面的地址。</p>\n<p>在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下</p>\n<p>这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可</p>\n<p>npm i hexo-generator-cname –save<br>最后hexo g &amp;&amp; hexo deploy就可以了</p>\n<p>NexT主题<br>hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p>\n<p>首先，NexT也有中文文档，然后我们就可以开始了。</p>\n<p>安装<br>我是用的git clone的方法，文档中还有其他方法</p>\n<p>$ git clone <a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>设置主题<br>在hexo根目录下的配置文件config.yml里设置主题</p>\n<p>theme: next<br>配置主题<br>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。</p>\n<p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p>\n<p>菜单栏 menu<br>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user\"><a href=\"#about-about-user\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar\"><a href=\"#schedule-schedule-calendar\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap\"><a href=\"#sitemap-sitemap-xml-sitemap\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat\"><a href=\"#commonweal-404-heartbeat\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>注意点：</p>\n<p>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示<br>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里<br>||后面是fontAwesome里的文件对应的名称<br>menu_icons记得选enable: true（默认应该是true）<br>我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。</pagename></p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user-1\"><a href=\"#about-about-user-1\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  读书: /books || book<br>  电影: /movies || film<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar-1\"><a href=\"#schedule-schedule-calendar-1\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap-1\"><a href=\"#sitemap-sitemap-xml-sitemap-1\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat-1\"><a href=\"#commonweal-404-heartbeat-1\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>主题风格 schemes<br>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p>\n<p>Muse</p>\n<p>image-20180809164700600<br>Mist</p>\n<p>image-20180809164749052<br>Pisces</p>\n<p>image-20180809164925685<br>Gemini</p>\n<p>image-20180809165023401<br>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p>\n<p>底部建站时间和图标修改<br>修改主题的配置文件：</p>\n<p>footer:</p>\n<h1 id=\"Specify-the-date-when-the-site-was-setup\"><a href=\"#Specify-the-date-when-the-site-was-setup\" class=\"headerlink\" title=\"Specify the date when the site was setup.\"></a>Specify the date when the site was setup.</h1><h1 id=\"If-not-defined-current-year-will-be-used\"><a href=\"#If-not-defined-current-year-will-be-used\" class=\"headerlink\" title=\"If not defined, current year will be used.\"></a>If not defined, current year will be used.</h1><p>  since: 2018</p>\n<h1 id=\"Icon-between-year-and-copyright-info\"><a href=\"#Icon-between-year-and-copyright-info\" class=\"headerlink\" title=\"Icon between year and copyright info.\"></a>Icon between year and copyright info.</h1><p>  icon: snowflake-o</p>\n<h1 id=\"If-not-defined-will-be-used-author-from-Hexo-main-config\"><a href=\"#If-not-defined-will-be-used-author-from-Hexo-main-config\" class=\"headerlink\" title=\"If not defined, will be used author from Hexo main config.\"></a>If not defined, will be used <code>author</code> from Hexo main config.</h1><p>  copyright:</p>\n<h1 id=\"————————————————————\"><a href=\"#————————————————————\" class=\"headerlink\" title=\"————————————————————-\"></a>————————————————————-</h1><h1 id=\"Hexo-link-Powered-by-Hexo\"><a href=\"#Hexo-link-Powered-by-Hexo\" class=\"headerlink\" title=\"Hexo link (Powered by Hexo).\"></a>Hexo link (Powered by Hexo).</h1><p>  powered: false</p>\n<p>  theme:</p>\n<pre><code># Theme &amp; scheme info link (Theme - NexT.scheme).\nenable: false\n# Version info of NexT after scheme info (vX.X.X).\n# version: false\n</code></pre><p>我在这部分做了这样几件事：</p>\n<p>把用户的图标从小人user改成了雪花snowflake-o<br>copyright留空，显示成页面author即我的名字<br>powered: false把hexo的授权图片取消了<br>theme: enable:false 把主题的内容也取消了<br>这样底部信息比较简单。</p>\n<p>image-20180809172835606<br>个人社交信息 social<br>在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。</p>\n<p>social:<br>  GitHub: <a href=\"https://github.com/XuQuan-nikkkki\" target=\"_blank\" rel=\"noopener\">https://github.com/XuQuan-nikkkki</a> || github<br>  E-Mail: mailto:<a href=\"mailto:xuquan1225@hotmail.com\" target=\"_blank\" rel=\"noopener\">xuquan1225@hotmail.com</a> || envelope</p>\n<p>  #Google: <a href=\"https://plus.google.com/yourname\" target=\"_blank\" rel=\"noopener\">https://plus.google.com/yourname</a> || google</p>\n<p>  #Twitter: <a href=\"https://twitter.com/yourname\" target=\"_blank\" rel=\"noopener\">https://twitter.com/yourname</a> || twitter</p>\n<p>  #FB Page: <a href=\"https://www.facebook.com/yourname\" target=\"_blank\" rel=\"noopener\">https://www.facebook.com/yourname</a> || facebook<br>注意点：</p>\n<p>||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标<br>建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球<br>网站动画效果<br>为了网站响应速度我们可以把网站的动画关掉</p>\n<p>motion:<br>  enable: false<br>但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。</p>\n<p>motion:<br>  enable: true<br>  async: true</p>\n<h1 id=\"Canvas-nest\"><a href=\"#Canvas-nest\" class=\"headerlink\" title=\"Canvas-nest\"></a>Canvas-nest</h1><p>canvas_nest: true</p>\n<h1 id=\"three-waves\"><a href=\"#three-waves\" class=\"headerlink\" title=\"three_waves\"></a>three_waves</h1><p>three_waves: false</p>\n<h1 id=\"canvas-lines\"><a href=\"#canvas-lines\" class=\"headerlink\" title=\"canvas_lines\"></a>canvas_lines</h1><p>canvas_lines: false</p>\n<h1 id=\"canvas-sphere\"><a href=\"#canvas-sphere\" class=\"headerlink\" title=\"canvas_sphere\"></a>canvas_sphere</h1><p>canvas_sphere: false<br>评论系统<br>NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。</p>\n<p>方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。</p>\n<h1 id=\"Disqus\"><a href=\"#Disqus\" class=\"headerlink\" title=\"Disqus\"></a>Disqus</h1><p>disqus:<br>  enable: true<br>  shortname: xuquan<br>  count: true<br>统计文章字数和阅读时间<br>post_wordcount:<br>  item_text: true<br>  wordcount: true  # 文章字数<br>  min2read: true   # 阅读时间<br>  totalcount: true  # 总共字数<br>  separated_meta: true<br>统计阅读次数<br>这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：</p>\n<p>image-20180809175133462<br>第三方插件<br>Hexo-admin<br>Hexo-admin插件允许我们直接在本地页面上修改文章内容。</p>\n<p>下载</p>\n<p>npm i hexo-admin –save<br>登录<a href=\"http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容</a></p>\n<p>Hexo-douban<br>hexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。</p>\n<p>下载</p>\n<p>npm install hexo-douban –save<br>配置</p>\n<p>在hexo根目录下的config.yml文件中添加如下内容</p>\n<p>douban:<br>  user:<br>  builtin: false<br>  book:<br>    title: ‘This is my book title’<br>    quote: ‘This is my book quote’<br>  movie:<br>    title: ‘This is my movie title’<br>    quote: ‘This is my movie quote’<br>  game:<br>    title: ‘This is my game title’<br>    quote: ‘This is my game quote’<br>  timeout: 10000<br>title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。</p>\n<p>user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。</p>\n<p>生成页面</p>\n<p>hexo douban   #生成读书、电影、游戏三个页面<br>hexo douban -b  #生成读书页面<br>hexo douban -m  #生成电影页面<br>hexo douban -g  #生成游戏页面<br>在博客中生成页面</p>\n<p>这里就需要用到我们前面提过的hexo new命令了。</p>\n<p>hexo new page books<br>hexo new page movies<br>hexo new page games<br>在博客中添加页面</p>\n<p>在menu部分添加我们需要添加的页面名称和相对路径</p>\n<p>menu:<br>  Home: /<br>  Archives: /archives<br>  Books: /books     #This is your books page<br>  Movies: /movies   #This is your movies page<br>  Games: /games   #This is your games page<br>部署到博客</p>\n<p>hexo g &amp;&amp; hexo deploy<br>我踩过的坑<br>iPic图片上传<br>hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。</p>\n<p>但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。</p>\n<p>我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。</p>\n<p>评论系统<br>因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。<br>另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~</p>\n<p>从印象笔记到简书到Hexo<br>我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。</p>\n<p>但使用了简书3个月之后，我就发现了一些问题：</p>\n<p>首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；</p>\n<p>其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；</p>\n<p>另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；</p>\n<p>在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。</p>\n<p>Hexo部署<br>hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。</p>\n<p>安装前提<br>安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：</p>\n<p>image-20180809141924679<br>安装Hexo<br>安装好node.js和git后，可以通过npm来安装Hexo。</p>\n<p>npm install -g hexo-cli<br>建站<br>之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：</p>\n<p>hexo init <folder><br>cd <folder><br>npm install</folder></folder></p>\n<p><folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。</folder></p>\n<p>文件夹开始初始化了<br>站内内容<br>新建好的文件夹目录如下：</p>\n<p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>这里解释一下各个文件夹的作用：</p>\n<p>config.yml<br>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p>\n<p>package.json<br>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p>\n<p>scaffolds<br>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p>\n<p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p>\n<p>source<br>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p>\n<p>themes<br>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p>\n<p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p>\n<p>Hexo命令<br>init<br>新建一个网站。</p>\n<p>hexo init <folder><br>new<br>新建文章或页面。</folder></p>\n<p>hexo new <layout> “title”<br>这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。</layout></layout></p>\n<p>默认是添加posts。</p>\n<p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p>\n<p>generate<br>生成静态页面</p>\n<p>hexo generate<br>也可以简写成</p>\n<p>hexo g<br>deploy<br>将内容部署到网站</p>\n<p>hexo deploy<br>也可以简写成</p>\n<p>hexo -d<br>publish<br>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p>\n<p>hexo publish <layout> <filename><br>server<br>启动服务器，默认情况下，访问网站为<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></filename></layout></p>\n<p>hexo server<br>也可以简写成</p>\n<p>hexo s<br>根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：</p>\n<p>hexo n <filename> 新建文章<br>hexo s 启动服务器，在本地查看内容<br>hexo g 生成静态页面<br>hexo deploy 部署到网站<br>以上四个步骤。</filename></p>\n<p>其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。</p>\n<p>搭建好后我们在localhost:4000就可以看到这样的博客内容：</p>\n<p>image-20180809152743968<br>实际操作<br>我在新建博客之后，做了以下改动：</p>\n<ol>\n<li>创建“分类”页面<br>新建分类页面</li>\n</ol>\n<p>hexo new page categories<br>给分类页面添加类型</p>\n<p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<hr>\n<p>title: 文章分类<br>date: 2017-05-27 13:47:40</p>\n<h2 id=\"type-“categories”-这部分是新添加的\"><a href=\"#type-“categories”-这部分是新添加的\" class=\"headerlink\" title=\"type: “categories”   #这部分是新添加的\"></a>type: “categories”   #这部分是新添加的</h2><p>给模板添加分类属性</p>\n<p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>\n<p>title: hexo+next主题<br>date: 1543200599000<br>categories:<br>tags:<br>给文章添加分类</p>\n<p>现在我们可以找到一篇文章，然后尝试给它添加分类</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]</p>\n<ol start=\"2\">\n<li>创建“标签”页面<br>创建”标签”页的方式和创建“分类”一样。</li>\n</ol>\n<p>新建“标签”页面</p>\n<p>hexo new page tags<br>给标签页面添加类型</p>\n<p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<p>title: tags<br>date: 2018-08-06 22:48:29<br>type: “tags” #新添加的内容<br>给文章添加标签</p>\n<p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]<br>第二种写法是用-短划线列出来</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: </p>\n<ul>\n<li>node.js</li>\n<li>express<br>部署域名<br>紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。</li>\n</ul>\n<p>部署Github<br>首先你必须有一个github账号</p>\n<p>然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)</p>\n<p>image-20180809153134467<br>然后在setting里添加生成页面的选项</p>\n<p>image-20180809153304980<br>image-20180809153343362<br>这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径</p>\n<p>image-20180809153610047<br>这里注意两小点：</p>\n<p>属性和内容之间一定要有一个空格，配置文件有自己的格式规范<br>如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程<br>我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了</p>\n<p>image-20180809153933270<br>部署自己的域名<br>首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；</p>\n<p>购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；</p>\n<p>认证成功后需要解析域名</p>\n<p>image-20180809154942783<br>image-20180809155013659<br>记录类型选CNAME，记录值是自己github生成页面的地址。</p>\n<p>在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下</p>\n<p>这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可</p>\n<p>npm i hexo-generator-cname –save<br>最后hexo g &amp;&amp; hexo deploy就可以了</p>\n<p>NexT主题<br>hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p>\n<p>首先，NexT也有中文文档，然后我们就可以开始了。</p>\n<p>安装<br>我是用的git clone的方法，文档中还有其他方法</p>\n<p>$ git clone <a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>设置主题<br>在hexo根目录下的配置文件config.yml里设置主题</p>\n<p>theme: next<br>配置主题<br>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。</p>\n<p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p>\n<p>菜单栏 menu<br>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user\"><a href=\"#about-about-user\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar\"><a href=\"#schedule-schedule-calendar\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap\"><a href=\"#sitemap-sitemap-xml-sitemap\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat\"><a href=\"#commonweal-404-heartbeat\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>注意点：</p>\n<p>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示<br>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里<br>||后面是fontAwesome里的文件对应的名称<br>menu_icons记得选enable: true（默认应该是true）<br>我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。</pagename></p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user-1\"><a href=\"#about-about-user-1\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  读书: /books || book<br>  电影: /movies || film<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar-1\"><a href=\"#schedule-schedule-calendar-1\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap-1\"><a href=\"#sitemap-sitemap-xml-sitemap-1\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat-1\"><a href=\"#commonweal-404-heartbeat-1\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>主题风格 schemes<br>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p>\n<p>Muse</p>\n<p>image-20180809164700600<br>Mist</p>\n<p>image-20180809164749052<br>Pisces</p>\n<p>image-20180809164925685<br>Gemini</p>\n<p>image-20180809165023401<br>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p>\n<p>底部建站时间和图标修改<br>修改主题的配置文件：</p>\n<p>footer:</p>\n<h1 id=\"Specify-the-date-when-the-site-was-setup\"><a href=\"#Specify-the-date-when-the-site-was-setup\" class=\"headerlink\" title=\"Specify the date when the site was setup.\"></a>Specify the date when the site was setup.</h1><h1 id=\"If-not-defined-current-year-will-be-used\"><a href=\"#If-not-defined-current-year-will-be-used\" class=\"headerlink\" title=\"If not defined, current year will be used.\"></a>If not defined, current year will be used.</h1><p>  since: 2018</p>\n<h1 id=\"Icon-between-year-and-copyright-info\"><a href=\"#Icon-between-year-and-copyright-info\" class=\"headerlink\" title=\"Icon between year and copyright info.\"></a>Icon between year and copyright info.</h1><p>  icon: snowflake-o</p>\n<h1 id=\"If-not-defined-will-be-used-author-from-Hexo-main-config\"><a href=\"#If-not-defined-will-be-used-author-from-Hexo-main-config\" class=\"headerlink\" title=\"If not defined, will be used author from Hexo main config.\"></a>If not defined, will be used <code>author</code> from Hexo main config.</h1><p>  copyright:</p>\n<h1 id=\"————————————————————\"><a href=\"#————————————————————\" class=\"headerlink\" title=\"————————————————————-\"></a>————————————————————-</h1><h1 id=\"Hexo-link-Powered-by-Hexo\"><a href=\"#Hexo-link-Powered-by-Hexo\" class=\"headerlink\" title=\"Hexo link (Powered by Hexo).\"></a>Hexo link (Powered by Hexo).</h1><p>  powered: false</p>\n<p>  theme:</p>\n<pre><code># Theme &amp; scheme info link (Theme - NexT.scheme).\nenable: false\n# Version info of NexT after scheme info (vX.X.X).\n# version: false\n</code></pre><p>我在这部分做了这样几件事：</p>\n<p>把用户的图标从小人user改成了雪花snowflake-o<br>copyright留空，显示成页面author即我的名字<br>powered: false把hexo的授权图片取消了<br>theme: enable:false 把主题的内容也取消了<br>这样底部信息比较简单。</p>\n<p>image-20180809172835606<br>个人社交信息 social<br>在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。</p>\n<p>social:<br>  GitHub: <a href=\"https://github.com/XuQuan-nikkkki\" target=\"_blank\" rel=\"noopener\">https://github.com/XuQuan-nikkkki</a> || github<br>  E-Mail: mailto:<a href=\"mailto:xuquan1225@hotmail.com\" target=\"_blank\" rel=\"noopener\">xuquan1225@hotmail.com</a> || envelope</p>\n<p>  #Google: <a href=\"https://plus.google.com/yourname\" target=\"_blank\" rel=\"noopener\">https://plus.google.com/yourname</a> || google</p>\n<p>  #Twitter: <a href=\"https://twitter.com/yourname\" target=\"_blank\" rel=\"noopener\">https://twitter.com/yourname</a> || twitter</p>\n<p>  #FB Page: <a href=\"https://www.facebook.com/yourname\" target=\"_blank\" rel=\"noopener\">https://www.facebook.com/yourname</a> || facebook<br>注意点：</p>\n<p>||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标<br>建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球<br>网站动画效果<br>为了网站响应速度我们可以把网站的动画关掉</p>\n<p>motion:<br>  enable: false<br>但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。</p>\n<p>motion:<br>  enable: true<br>  async: true</p>\n<h1 id=\"Canvas-nest\"><a href=\"#Canvas-nest\" class=\"headerlink\" title=\"Canvas-nest\"></a>Canvas-nest</h1><p>canvas_nest: true</p>\n<h1 id=\"three-waves\"><a href=\"#three-waves\" class=\"headerlink\" title=\"three_waves\"></a>three_waves</h1><p>three_waves: false</p>\n<h1 id=\"canvas-lines\"><a href=\"#canvas-lines\" class=\"headerlink\" title=\"canvas_lines\"></a>canvas_lines</h1><p>canvas_lines: false</p>\n<h1 id=\"canvas-sphere\"><a href=\"#canvas-sphere\" class=\"headerlink\" title=\"canvas_sphere\"></a>canvas_sphere</h1><p>canvas_sphere: false<br>评论系统<br>NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。</p>\n<p>方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。</p>\n<h1 id=\"Disqus\"><a href=\"#Disqus\" class=\"headerlink\" title=\"Disqus\"></a>Disqus</h1><p>disqus:<br>  enable: true<br>  shortname: xuquan<br>  count: true<br>统计文章字数和阅读时间<br>post_wordcount:<br>  item_text: true<br>  wordcount: true  # 文章字数<br>  min2read: true   # 阅读时间<br>  totalcount: true  # 总共字数<br>  separated_meta: true<br>统计阅读次数<br>这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：</p>\n<p>image-20180809175133462<br>第三方插件<br>Hexo-admin<br>Hexo-admin插件允许我们直接在本地页面上修改文章内容。</p>\n<p>下载</p>\n<p>npm i hexo-admin –save<br>登录<a href=\"http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容</a></p>\n<p>Hexo-douban<br>hexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。</p>\n<p>下载</p>\n<p>npm install hexo-douban –save<br>配置</p>\n<p>在hexo根目录下的config.yml文件中添加如下内容</p>\n<p>douban:<br>  user:<br>  builtin: false<br>  book:<br>    title: ‘This is my book title’<br>    quote: ‘This is my book quote’<br>  movie:<br>    title: ‘This is my movie title’<br>    quote: ‘This is my movie quote’<br>  game:<br>    title: ‘This is my game title’<br>    quote: ‘This is my game quote’<br>  timeout: 10000<br>title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。</p>\n<p>user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。</p>\n<p>生成页面</p>\n<p>hexo douban   #生成读书、电影、游戏三个页面<br>hexo douban -b  #生成读书页面<br>hexo douban -m  #生成电影页面<br>hexo douban -g  #生成游戏页面<br>在博客中生成页面</p>\n<p>这里就需要用到我们前面提过的hexo new命令了。</p>\n<p>hexo new page books<br>hexo new page movies<br>hexo new page games<br>在博客中添加页面</p>\n<p>在menu部分添加我们需要添加的页面名称和相对路径</p>\n<p>menu:<br>  Home: /<br>  Archives: /archives<br>  Books: /books     #This is your books page<br>  Movies: /movies   #This is your movies page<br>  Games: /games   #This is your games page<br>部署到博客</p>\n<p>hexo g &amp;&amp; hexo deploy<br>我踩过的坑<br>iPic图片上传<br>hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。</p>\n<p>但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。</p>\n<p>我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。</p>\n<p>评论系统<br>因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。</p>\n"},{"title":"KVM 虚拟化原理1 -- 概述","date":"2018-12-10T14:32:20.000Z","donate":true,"_content":"## KVM虚拟化简介 ##\n\nKVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。\nKVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。\n\nQemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。\n\n正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。\n\n\n![](01_brief.png)\n\nKVM有如下特点：\n\n* guest作为一个普通进程运行于宿主机\n* guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度\n\n## KVM整体架构##\n\n![](02_kvm_framework.png)\n\n### 虚拟CPU\n\n虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。\n\nKVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。\n\n### 虚拟IO设备\n\nguest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。\n\n### 虚拟内存\n\nguest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。\n","source":"_posts/kvm-overview.md","raw":"---\ntitle: KVM 虚拟化原理1 -- 概述\ndate: 2018-12-10 22:32:20\ncategories: KVM\ntags: KVM\ndonate: true\n\n---\n## KVM虚拟化简介 ##\n\nKVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。\nKVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。\n\nQemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。\n\n正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。\n\n\n![](01_brief.png)\n\nKVM有如下特点：\n\n* guest作为一个普通进程运行于宿主机\n* guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度\n\n## KVM整体架构##\n\n![](02_kvm_framework.png)\n\n### 虚拟CPU\n\n虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。\n\nKVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。\n\n### 虚拟IO设备\n\nguest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。\n\n### 虚拟内存\n\nguest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。\n","slug":"kvm-overview","published":1,"updated":"2018-12-10T15:58:02.649Z","_id":"cjpigecwd0004bpo4wtccakqg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"KVM虚拟化简介\"><a href=\"#KVM虚拟化简介\" class=\"headerlink\" title=\"KVM虚拟化简介\"></a>KVM虚拟化简介</h2><p>KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。<br>KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。</p>\n<p>Qemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p>\n<p>正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。</p>\n<p><img src=\"/2018/12/10/kvm-overview/01_brief.png\" alt=\"\"></p>\n<p>KVM有如下特点：</p>\n<ul>\n<li>guest作为一个普通进程运行于宿主机</li>\n<li>guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度</li>\n</ul>\n<h2 id=\"KVM整体架构\"><a href=\"#KVM整体架构\" class=\"headerlink\" title=\"KVM整体架构\"></a>KVM整体架构</h2><p><img src=\"/2018/12/10/kvm-overview/02_kvm_framework.png\" alt=\"\"></p>\n<h3 id=\"虚拟CPU\"><a href=\"#虚拟CPU\" class=\"headerlink\" title=\"虚拟CPU\"></a>虚拟CPU</h3><p>虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。</p>\n<p>KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。</p>\n<h3 id=\"虚拟IO设备\"><a href=\"#虚拟IO设备\" class=\"headerlink\" title=\"虚拟IO设备\"></a>虚拟IO设备</h3><p>guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"KVM虚拟化简介\"><a href=\"#KVM虚拟化简介\" class=\"headerlink\" title=\"KVM虚拟化简介\"></a>KVM虚拟化简介</h2><p>KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。<br>KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。</p>\n<p>Qemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p>\n<p>正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。</p>\n<p><img src=\"/2018/12/10/kvm-overview/01_brief.png\" alt=\"\"></p>\n<p>KVM有如下特点：</p>\n<ul>\n<li>guest作为一个普通进程运行于宿主机</li>\n<li>guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度</li>\n</ul>\n<h2 id=\"KVM整体架构\"><a href=\"#KVM整体架构\" class=\"headerlink\" title=\"KVM整体架构\"></a>KVM整体架构</h2><p><img src=\"/2018/12/10/kvm-overview/02_kvm_framework.png\" alt=\"\"></p>\n<h3 id=\"虚拟CPU\"><a href=\"#虚拟CPU\" class=\"headerlink\" title=\"虚拟CPU\"></a>虚拟CPU</h3><p>虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。</p>\n<p>KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。</p>\n<h3 id=\"虚拟IO设备\"><a href=\"#虚拟IO设备\" class=\"headerlink\" title=\"虚拟IO设备\"></a>虚拟IO设备</h3><p>guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。</p>\n"},{"title":"QMP 简介","date":"2018-12-10T13:42:39.000Z","donate":true,"_content":"\n## 什么是QMP协议##\nQMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。\n\n## QMP协议有哪些特征##\n1）轻量、基于文本、指令格式易于解析，因为它是json格式的；\n2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；\n3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ \"execute\": \"query-status\" }，这样就可以查询虚拟机的状态。\n\n## QMP协议有哪些模式##\n 有两种模式：Capabilities Negotiation模式和Command模式。\n\n## 那么该如何建立qmp连接呢 ##\n这里简要介绍通过tcp和unix socket使用qmp。\n\n### 通过TCP使用QMP ###\n使用-qmp添加qmp相关参数：\n\n``` bash\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp tcp:localhost:1234,server,nowait\n```\n新开一个终端使用telnet 链接localhost：1234\n\n``` bash\ntelnet localhost 1234\n```\n之后就可以使用qmp的命令和虚拟机交互了\n\n```\n[root@localhost ~]# telnet localhost 1234\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\n### 通过unix socket使用QMP ###\n使用unix socket创建qmp：\n\n```\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait\n```\n\n使用nc连接该socket:\n\n```\nnc -U /tmp/qmp-test\n```\n\n之后就一样了。\n\n```\n[root@localhost qmp]# nc -U /tmp/qmp-test\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\nQMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。\n\n### 自动批量发送QMP命令\n\n可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。\n\n```\n# QEMU Monitor Protocol Python class\n#\n# Copyright (C) 2009 Red Hat Inc.\n#\n# This work is licensed under the terms of the GNU GPL, version 2.  See\n# the COPYING file in the top-level directory.\n\nimport socket, json, time, commands\nfrom optparse import OptionParser\n\nclass QMPError(Exception):\n    pass\n\nclass QMPConnectError(QMPError):\n    pass\n\nclass QEMUMonitorProtocol:\n    def connect(self):\n        print self.filename\n        self.sock.connect(self.filename)\n        data = self.__json_read()\n        if data == None:\n            raise QMPConnectError\n        if not data.has_key('QMP'):\n            raise QMPConnectError\n        return data['QMP']['capabilities']\n\n    def close(self):\n        self.sock.close()\n\n    def send_raw(self, line):\n        self.sock.send(str(line))\n        return self.__json_read()\n\n    def send(self, cmdline, timeout=30, convert=True):\n        end_time = time.time() + timeout\n        if convert:\n            cmd = self.__build_cmd(cmdline)\n        else:\n            cmd = cmdline\n\t    print(\"*cmdline = %s\" % cmd)\n        print cmd\n        self.__json_send(cmd)\n        while time.time() < end_time:\n            resp = self.__json_read()\n            if resp == None:\n                return (False, None)\n            elif resp.has_key('error'):\n                return (False, resp['error'])\n            elif resp.has_key('return'):\n                return (True, resp['return'])\n\n    def read(self, timeout=30):\n        o = \"\"\n        end_time = time.time() + timeout\n        while time.time() < end_time:\n            try:\n                o += self.sock.recv(1024)\n                if len(o) > 0:\n                    break\n            except:\n                time.sleep(0.01)\n        if len(o) > 0:\n            return json.loads(o)\n        else:\n            return None\n\n    def __build_cmd(self, cmdline):\n        cmdargs = cmdline.split()\n        qmpcmd = { 'execute': cmdargs[0], 'arguments': {} }\n        for arg in cmdargs[1:]:\n            opt = arg.split('=')\n            try:\n                value = int(opt[1])\n            except ValueError:\n                value = opt[1]\n            qmpcmd['arguments'][opt[0]] = value\n\tprint(\"*cmdline = %s\" % cmdline)\n        return qmpcmd\n\n    def __json_send(self, cmd):\n        # XXX: We have to send any additional char, otherwise\n        # the Server won't read our input\n        self.sock.send(json.dumps(cmd) + ' ')\n\n    def __json_read(self):\n        try:\n            return json.loads(self.sock.recv(1024))\n        except ValueError:\n            return\n\n    def __init__(self, filename, protocol=\"tcp\"):\n        if protocol == \"tcp\":\n            self.filename = (\"localhost\", int(filename))\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        elif protocol == \"unix\":\n            self.filename = filename\n            print self.filename\n            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        #self.sock.setblocking(0)\n        self.sock.settimeout(5)\n\nif __name__ == \"__main__\":\n    parser = OptionParser()\n    parser.add_option('-n', '--num', dest='num', default='10', help='Times want to try')\n    parser.add_option('-f', '--file', dest='port', default='4444', help='QMP port/filename')\n    parser.add_option('-p', '--protocol', dest='protocol',default='tcp', help='QMP protocol')\n    def usage():\n        parser.print_help()\n        sys.exit(1)\n\n    options, args = parser.parse_args()\n\n    print options\n    if len(args) > 0:\n        usage()\n\n    num = int(options.num)\n    qmp_filename = options.port\n    qmp_protocol = options.protocol\n    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)\n    qmp_socket.connect()\n    qmp_socket.send(\"qmp_capabilities\")\n    qmp_socket.close()\n\n##########################################################\n#Usage\n#Options:\n#  -h, --help            show this help message and exit\n#  -n NUM, --num=NUM     Times want to try\n#  -f PORT, --file=PORT  QMP port/filename\n#  -p PROTOCOL, --protocol=PROTOCOL\n#                        QMP protocol\n# e.g: # python xxxxx.py -n $NUM -f $PORT\n##########################################################\n```\n## 参考文档 ##\n关于QMP更详细的文档，可以参考其官方文档：\nhttps://wiki.qemu.org/Documentation/QMP\n\n\n","source":"_posts/qmp-introduction.md","raw":"---\ntitle: QMP 简介\ndate: 2018-12-10 21:42:39\ncategories: QEMU\ntags: [QEMU, QMP]\ndonate: true\n---\n\n## 什么是QMP协议##\nQMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。\n\n## QMP协议有哪些特征##\n1）轻量、基于文本、指令格式易于解析，因为它是json格式的；\n2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；\n3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ \"execute\": \"query-status\" }，这样就可以查询虚拟机的状态。\n\n## QMP协议有哪些模式##\n 有两种模式：Capabilities Negotiation模式和Command模式。\n\n## 那么该如何建立qmp连接呢 ##\n这里简要介绍通过tcp和unix socket使用qmp。\n\n### 通过TCP使用QMP ###\n使用-qmp添加qmp相关参数：\n\n``` bash\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp tcp:localhost:1234,server,nowait\n```\n新开一个终端使用telnet 链接localhost：1234\n\n``` bash\ntelnet localhost 1234\n```\n之后就可以使用qmp的命令和虚拟机交互了\n\n```\n[root@localhost ~]# telnet localhost 1234\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\n### 通过unix socket使用QMP ###\n使用unix socket创建qmp：\n\n```\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait\n```\n\n使用nc连接该socket:\n\n```\nnc -U /tmp/qmp-test\n```\n\n之后就一样了。\n\n```\n[root@localhost qmp]# nc -U /tmp/qmp-test\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\nQMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。\n\n### 自动批量发送QMP命令\n\n可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。\n\n```\n# QEMU Monitor Protocol Python class\n#\n# Copyright (C) 2009 Red Hat Inc.\n#\n# This work is licensed under the terms of the GNU GPL, version 2.  See\n# the COPYING file in the top-level directory.\n\nimport socket, json, time, commands\nfrom optparse import OptionParser\n\nclass QMPError(Exception):\n    pass\n\nclass QMPConnectError(QMPError):\n    pass\n\nclass QEMUMonitorProtocol:\n    def connect(self):\n        print self.filename\n        self.sock.connect(self.filename)\n        data = self.__json_read()\n        if data == None:\n            raise QMPConnectError\n        if not data.has_key('QMP'):\n            raise QMPConnectError\n        return data['QMP']['capabilities']\n\n    def close(self):\n        self.sock.close()\n\n    def send_raw(self, line):\n        self.sock.send(str(line))\n        return self.__json_read()\n\n    def send(self, cmdline, timeout=30, convert=True):\n        end_time = time.time() + timeout\n        if convert:\n            cmd = self.__build_cmd(cmdline)\n        else:\n            cmd = cmdline\n\t    print(\"*cmdline = %s\" % cmd)\n        print cmd\n        self.__json_send(cmd)\n        while time.time() < end_time:\n            resp = self.__json_read()\n            if resp == None:\n                return (False, None)\n            elif resp.has_key('error'):\n                return (False, resp['error'])\n            elif resp.has_key('return'):\n                return (True, resp['return'])\n\n    def read(self, timeout=30):\n        o = \"\"\n        end_time = time.time() + timeout\n        while time.time() < end_time:\n            try:\n                o += self.sock.recv(1024)\n                if len(o) > 0:\n                    break\n            except:\n                time.sleep(0.01)\n        if len(o) > 0:\n            return json.loads(o)\n        else:\n            return None\n\n    def __build_cmd(self, cmdline):\n        cmdargs = cmdline.split()\n        qmpcmd = { 'execute': cmdargs[0], 'arguments': {} }\n        for arg in cmdargs[1:]:\n            opt = arg.split('=')\n            try:\n                value = int(opt[1])\n            except ValueError:\n                value = opt[1]\n            qmpcmd['arguments'][opt[0]] = value\n\tprint(\"*cmdline = %s\" % cmdline)\n        return qmpcmd\n\n    def __json_send(self, cmd):\n        # XXX: We have to send any additional char, otherwise\n        # the Server won't read our input\n        self.sock.send(json.dumps(cmd) + ' ')\n\n    def __json_read(self):\n        try:\n            return json.loads(self.sock.recv(1024))\n        except ValueError:\n            return\n\n    def __init__(self, filename, protocol=\"tcp\"):\n        if protocol == \"tcp\":\n            self.filename = (\"localhost\", int(filename))\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        elif protocol == \"unix\":\n            self.filename = filename\n            print self.filename\n            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        #self.sock.setblocking(0)\n        self.sock.settimeout(5)\n\nif __name__ == \"__main__\":\n    parser = OptionParser()\n    parser.add_option('-n', '--num', dest='num', default='10', help='Times want to try')\n    parser.add_option('-f', '--file', dest='port', default='4444', help='QMP port/filename')\n    parser.add_option('-p', '--protocol', dest='protocol',default='tcp', help='QMP protocol')\n    def usage():\n        parser.print_help()\n        sys.exit(1)\n\n    options, args = parser.parse_args()\n\n    print options\n    if len(args) > 0:\n        usage()\n\n    num = int(options.num)\n    qmp_filename = options.port\n    qmp_protocol = options.protocol\n    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)\n    qmp_socket.connect()\n    qmp_socket.send(\"qmp_capabilities\")\n    qmp_socket.close()\n\n##########################################################\n#Usage\n#Options:\n#  -h, --help            show this help message and exit\n#  -n NUM, --num=NUM     Times want to try\n#  -f PORT, --file=PORT  QMP port/filename\n#  -p PROTOCOL, --protocol=PROTOCOL\n#                        QMP protocol\n# e.g: # python xxxxx.py -n $NUM -f $PORT\n##########################################################\n```\n## 参考文档 ##\n关于QMP更详细的文档，可以参考其官方文档：\nhttps://wiki.qemu.org/Documentation/QMP\n\n\n","slug":"qmp-introduction","published":1,"updated":"2018-12-10T14:15:44.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpigecwe0006bpo4u6t9cg87","content":"<h2 id=\"什么是QMP协议\"><a href=\"#什么是QMP协议\" class=\"headerlink\" title=\"什么是QMP协议\"></a>什么是QMP协议</h2><p>QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h2 id=\"QMP协议有哪些特征\"><a href=\"#QMP协议有哪些特征\" class=\"headerlink\" title=\"QMP协议有哪些特征\"></a>QMP协议有哪些特征</h2><p>1）轻量、基于文本、指令格式易于解析，因为它是json格式的；<br>2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；<br>3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。</p>\n<h2 id=\"QMP协议有哪些模式\"><a href=\"#QMP协议有哪些模式\" class=\"headerlink\" title=\"QMP协议有哪些模式\"></a>QMP协议有哪些模式</h2><p> 有两种模式：Capabilities Negotiation模式和Command模式。</p>\n<h2 id=\"那么该如何建立qmp连接呢\"><a href=\"#那么该如何建立qmp连接呢\" class=\"headerlink\" title=\"那么该如何建立qmp连接呢\"></a>那么该如何建立qmp连接呢</h2><p>这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h3 id=\"通过TCP使用QMP\"><a href=\"#通过TCP使用QMP\" class=\"headerlink\" title=\"通过TCP使用QMP\"></a>通过TCP使用QMP</h3><p>使用-qmp添加qmp相关参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -<span class=\"built_in\">enable</span>-kvm -qmp tcp:localhost:1234,server,nowait</span><br></pre></td></tr></table></figure>\n<p>新开一个终端使用telnet 链接localhost：1234</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 1234</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用qmp的命令和虚拟机交互了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# telnet localhost 1234</span><br><span class=\"line\">Trying ::1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is &apos;^]&apos;.</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过unix-socket使用QMP\"><a href=\"#通过unix-socket使用QMP\" class=\"headerlink\" title=\"通过unix socket使用QMP\"></a>通过unix socket使用QMP</h3><p>使用unix socket创建qmp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait</span><br></pre></td></tr></table></figure>\n<p>使用nc连接该socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -U /tmp/qmp-test</span><br></pre></td></tr></table></figure>\n<p>之后就一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost qmp]# nc -U /tmp/qmp-test</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。</p>\n<h3 id=\"自动批量发送QMP命令\"><a href=\"#自动批量发送QMP命令\" class=\"headerlink\" title=\"自动批量发送QMP命令\"></a>自动批量发送QMP命令</h3><p>可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># QEMU Monitor Protocol Python class</span><br><span class=\"line\">#</span><br><span class=\"line\"># Copyright (C) 2009 Red Hat Inc.</span><br><span class=\"line\">#</span><br><span class=\"line\"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class=\"line\"># the COPYING file in the top-level directory.</span><br><span class=\"line\"></span><br><span class=\"line\">import socket, json, time, commands</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPError(Exception):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPConnectError(QMPError):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QEMUMonitorProtocol:</span><br><span class=\"line\">    def connect(self):</span><br><span class=\"line\">        print self.filename</span><br><span class=\"line\">        self.sock.connect(self.filename)</span><br><span class=\"line\">        data = self.__json_read()</span><br><span class=\"line\">        if data == None:</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        if not data.has_key(&apos;QMP&apos;):</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        return data[&apos;QMP&apos;][&apos;capabilities&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">    def close(self):</span><br><span class=\"line\">        self.sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send_raw(self, line):</span><br><span class=\"line\">        self.sock.send(str(line))</span><br><span class=\"line\">        return self.__json_read()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send(self, cmdline, timeout=30, convert=True):</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        if convert:</span><br><span class=\"line\">            cmd = self.__build_cmd(cmdline)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            cmd = cmdline</span><br><span class=\"line\">\t    print(&quot;*cmdline = %s&quot; % cmd)</span><br><span class=\"line\">        print cmd</span><br><span class=\"line\">        self.__json_send(cmd)</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            resp = self.__json_read()</span><br><span class=\"line\">            if resp == None:</span><br><span class=\"line\">                return (False, None)</span><br><span class=\"line\">            elif resp.has_key(&apos;error&apos;):</span><br><span class=\"line\">                return (False, resp[&apos;error&apos;])</span><br><span class=\"line\">            elif resp.has_key(&apos;return&apos;):</span><br><span class=\"line\">                return (True, resp[&apos;return&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">    def read(self, timeout=30):</span><br><span class=\"line\">        o = &quot;&quot;</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                o += self.sock.recv(1024)</span><br><span class=\"line\">                if len(o) &gt; 0:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                time.sleep(0.01)</span><br><span class=\"line\">        if len(o) &gt; 0:</span><br><span class=\"line\">            return json.loads(o)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return None</span><br><span class=\"line\"></span><br><span class=\"line\">    def __build_cmd(self, cmdline):</span><br><span class=\"line\">        cmdargs = cmdline.split()</span><br><span class=\"line\">        qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125;</span><br><span class=\"line\">        for arg in cmdargs[1:]:</span><br><span class=\"line\">            opt = arg.split(&apos;=&apos;)</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                value = int(opt[1])</span><br><span class=\"line\">            except ValueError:</span><br><span class=\"line\">                value = opt[1]</span><br><span class=\"line\">            qmpcmd[&apos;arguments&apos;][opt[0]] = value</span><br><span class=\"line\">\tprint(&quot;*cmdline = %s&quot; % cmdline)</span><br><span class=\"line\">        return qmpcmd</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_send(self, cmd):</span><br><span class=\"line\">        # XXX: We have to send any additional char, otherwise</span><br><span class=\"line\">        # the Server won&apos;t read our input</span><br><span class=\"line\">        self.sock.send(json.dumps(cmd) + &apos; &apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_read(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            return json.loads(self.sock.recv(1024))</span><br><span class=\"line\">        except ValueError:</span><br><span class=\"line\">            return</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, filename, protocol=&quot;tcp&quot;):</span><br><span class=\"line\">        if protocol == &quot;tcp&quot;:</span><br><span class=\"line\">            self.filename = (&quot;localhost&quot;, int(filename))</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">        elif protocol == &quot;unix&quot;:</span><br><span class=\"line\">            self.filename = filename</span><br><span class=\"line\">            print self.filename</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class=\"line\">        #self.sock.setblocking(0)</span><br><span class=\"line\">        self.sock.settimeout(5)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    parser = OptionParser()</span><br><span class=\"line\">    parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;)</span><br><span class=\"line\">    def usage():</span><br><span class=\"line\">        parser.print_help()</span><br><span class=\"line\">        sys.exit(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    options, args = parser.parse_args()</span><br><span class=\"line\"></span><br><span class=\"line\">    print options</span><br><span class=\"line\">    if len(args) &gt; 0:</span><br><span class=\"line\">        usage()</span><br><span class=\"line\"></span><br><span class=\"line\">    num = int(options.num)</span><br><span class=\"line\">    qmp_filename = options.port</span><br><span class=\"line\">    qmp_protocol = options.protocol</span><br><span class=\"line\">    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)</span><br><span class=\"line\">    qmp_socket.connect()</span><br><span class=\"line\">    qmp_socket.send(&quot;qmp_capabilities&quot;)</span><br><span class=\"line\">    qmp_socket.close()</span><br><span class=\"line\"></span><br><span class=\"line\">##########################################################</span><br><span class=\"line\">#Usage</span><br><span class=\"line\">#Options:</span><br><span class=\"line\">#  -h, --help            show this help message and exit</span><br><span class=\"line\">#  -n NUM, --num=NUM     Times want to try</span><br><span class=\"line\">#  -f PORT, --file=PORT  QMP port/filename</span><br><span class=\"line\">#  -p PROTOCOL, --protocol=PROTOCOL</span><br><span class=\"line\">#                        QMP protocol</span><br><span class=\"line\"># e.g: # python xxxxx.py -n $NUM -f $PORT</span><br><span class=\"line\">##########################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>关于QMP更详细的文档，可以参考其官方文档：<br><a href=\"https://wiki.qemu.org/Documentation/QMP\" target=\"_blank\" rel=\"noopener\">https://wiki.qemu.org/Documentation/QMP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是QMP协议\"><a href=\"#什么是QMP协议\" class=\"headerlink\" title=\"什么是QMP协议\"></a>什么是QMP协议</h2><p>QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h2 id=\"QMP协议有哪些特征\"><a href=\"#QMP协议有哪些特征\" class=\"headerlink\" title=\"QMP协议有哪些特征\"></a>QMP协议有哪些特征</h2><p>1）轻量、基于文本、指令格式易于解析，因为它是json格式的；<br>2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；<br>3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。</p>\n<h2 id=\"QMP协议有哪些模式\"><a href=\"#QMP协议有哪些模式\" class=\"headerlink\" title=\"QMP协议有哪些模式\"></a>QMP协议有哪些模式</h2><p> 有两种模式：Capabilities Negotiation模式和Command模式。</p>\n<h2 id=\"那么该如何建立qmp连接呢\"><a href=\"#那么该如何建立qmp连接呢\" class=\"headerlink\" title=\"那么该如何建立qmp连接呢\"></a>那么该如何建立qmp连接呢</h2><p>这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h3 id=\"通过TCP使用QMP\"><a href=\"#通过TCP使用QMP\" class=\"headerlink\" title=\"通过TCP使用QMP\"></a>通过TCP使用QMP</h3><p>使用-qmp添加qmp相关参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -<span class=\"built_in\">enable</span>-kvm -qmp tcp:localhost:1234,server,nowait</span><br></pre></td></tr></table></figure>\n<p>新开一个终端使用telnet 链接localhost：1234</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 1234</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用qmp的命令和虚拟机交互了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# telnet localhost 1234</span><br><span class=\"line\">Trying ::1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is &apos;^]&apos;.</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过unix-socket使用QMP\"><a href=\"#通过unix-socket使用QMP\" class=\"headerlink\" title=\"通过unix socket使用QMP\"></a>通过unix socket使用QMP</h3><p>使用unix socket创建qmp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait</span><br></pre></td></tr></table></figure>\n<p>使用nc连接该socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -U /tmp/qmp-test</span><br></pre></td></tr></table></figure>\n<p>之后就一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost qmp]# nc -U /tmp/qmp-test</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。</p>\n<h3 id=\"自动批量发送QMP命令\"><a href=\"#自动批量发送QMP命令\" class=\"headerlink\" title=\"自动批量发送QMP命令\"></a>自动批量发送QMP命令</h3><p>可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># QEMU Monitor Protocol Python class</span><br><span class=\"line\">#</span><br><span class=\"line\"># Copyright (C) 2009 Red Hat Inc.</span><br><span class=\"line\">#</span><br><span class=\"line\"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class=\"line\"># the COPYING file in the top-level directory.</span><br><span class=\"line\"></span><br><span class=\"line\">import socket, json, time, commands</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPError(Exception):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPConnectError(QMPError):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QEMUMonitorProtocol:</span><br><span class=\"line\">    def connect(self):</span><br><span class=\"line\">        print self.filename</span><br><span class=\"line\">        self.sock.connect(self.filename)</span><br><span class=\"line\">        data = self.__json_read()</span><br><span class=\"line\">        if data == None:</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        if not data.has_key(&apos;QMP&apos;):</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        return data[&apos;QMP&apos;][&apos;capabilities&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">    def close(self):</span><br><span class=\"line\">        self.sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send_raw(self, line):</span><br><span class=\"line\">        self.sock.send(str(line))</span><br><span class=\"line\">        return self.__json_read()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send(self, cmdline, timeout=30, convert=True):</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        if convert:</span><br><span class=\"line\">            cmd = self.__build_cmd(cmdline)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            cmd = cmdline</span><br><span class=\"line\">\t    print(&quot;*cmdline = %s&quot; % cmd)</span><br><span class=\"line\">        print cmd</span><br><span class=\"line\">        self.__json_send(cmd)</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            resp = self.__json_read()</span><br><span class=\"line\">            if resp == None:</span><br><span class=\"line\">                return (False, None)</span><br><span class=\"line\">            elif resp.has_key(&apos;error&apos;):</span><br><span class=\"line\">                return (False, resp[&apos;error&apos;])</span><br><span class=\"line\">            elif resp.has_key(&apos;return&apos;):</span><br><span class=\"line\">                return (True, resp[&apos;return&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">    def read(self, timeout=30):</span><br><span class=\"line\">        o = &quot;&quot;</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                o += self.sock.recv(1024)</span><br><span class=\"line\">                if len(o) &gt; 0:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                time.sleep(0.01)</span><br><span class=\"line\">        if len(o) &gt; 0:</span><br><span class=\"line\">            return json.loads(o)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return None</span><br><span class=\"line\"></span><br><span class=\"line\">    def __build_cmd(self, cmdline):</span><br><span class=\"line\">        cmdargs = cmdline.split()</span><br><span class=\"line\">        qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125;</span><br><span class=\"line\">        for arg in cmdargs[1:]:</span><br><span class=\"line\">            opt = arg.split(&apos;=&apos;)</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                value = int(opt[1])</span><br><span class=\"line\">            except ValueError:</span><br><span class=\"line\">                value = opt[1]</span><br><span class=\"line\">            qmpcmd[&apos;arguments&apos;][opt[0]] = value</span><br><span class=\"line\">\tprint(&quot;*cmdline = %s&quot; % cmdline)</span><br><span class=\"line\">        return qmpcmd</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_send(self, cmd):</span><br><span class=\"line\">        # XXX: We have to send any additional char, otherwise</span><br><span class=\"line\">        # the Server won&apos;t read our input</span><br><span class=\"line\">        self.sock.send(json.dumps(cmd) + &apos; &apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_read(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            return json.loads(self.sock.recv(1024))</span><br><span class=\"line\">        except ValueError:</span><br><span class=\"line\">            return</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, filename, protocol=&quot;tcp&quot;):</span><br><span class=\"line\">        if protocol == &quot;tcp&quot;:</span><br><span class=\"line\">            self.filename = (&quot;localhost&quot;, int(filename))</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">        elif protocol == &quot;unix&quot;:</span><br><span class=\"line\">            self.filename = filename</span><br><span class=\"line\">            print self.filename</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class=\"line\">        #self.sock.setblocking(0)</span><br><span class=\"line\">        self.sock.settimeout(5)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    parser = OptionParser()</span><br><span class=\"line\">    parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;)</span><br><span class=\"line\">    def usage():</span><br><span class=\"line\">        parser.print_help()</span><br><span class=\"line\">        sys.exit(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    options, args = parser.parse_args()</span><br><span class=\"line\"></span><br><span class=\"line\">    print options</span><br><span class=\"line\">    if len(args) &gt; 0:</span><br><span class=\"line\">        usage()</span><br><span class=\"line\"></span><br><span class=\"line\">    num = int(options.num)</span><br><span class=\"line\">    qmp_filename = options.port</span><br><span class=\"line\">    qmp_protocol = options.protocol</span><br><span class=\"line\">    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)</span><br><span class=\"line\">    qmp_socket.connect()</span><br><span class=\"line\">    qmp_socket.send(&quot;qmp_capabilities&quot;)</span><br><span class=\"line\">    qmp_socket.close()</span><br><span class=\"line\"></span><br><span class=\"line\">##########################################################</span><br><span class=\"line\">#Usage</span><br><span class=\"line\">#Options:</span><br><span class=\"line\">#  -h, --help            show this help message and exit</span><br><span class=\"line\">#  -n NUM, --num=NUM     Times want to try</span><br><span class=\"line\">#  -f PORT, --file=PORT  QMP port/filename</span><br><span class=\"line\">#  -p PROTOCOL, --protocol=PROTOCOL</span><br><span class=\"line\">#                        QMP protocol</span><br><span class=\"line\"># e.g: # python xxxxx.py -n $NUM -f $PORT</span><br><span class=\"line\">##########################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>关于QMP更详细的文档，可以参考其官方文档：<br><a href=\"https://wiki.qemu.org/Documentation/QMP\" target=\"_blank\" rel=\"noopener\">https://wiki.qemu.org/Documentation/QMP</a></p>\n"},{"title":"KVM 虚拟化原理2— QEMU启动过程","donate":true,"date":"2018-12-10T14:57:17.000Z","_content":"\n## 虚拟机启动过程\n\n```hljs\n第一步，获取到kvm句柄\nkvmfd = open(\"/dev/kvm\", O_RDWR);\n第二步，创建虚拟机，获取到虚拟机句柄。\nvmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);\n第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。\nioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);\n第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。\n第五步，创建vCPU，并为vCPU分配内存空间。\nioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);\nvcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n第五步，创建vCPU个数的线程并运行虚拟机。\nioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。\n这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。\n```\n\n```hljs\nopen(\"/dev/kvm\")\nioctl(KVM_CREATE_VM)\nioctl(KVM_CREATE_VCPU)\nfor (;;) {\n     ioctl(KVM_RUN)\n     switch (exit_reason) {\n     case KVM_EXIT_IO:  /* ... */\n     case KVM_EXIT_HLT: /* ... */\n     }\n}\n```\n\n关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。\n\n[KVM ioctl接口文档](https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt)\n\n## 先来一个KVM API开胃菜\n\n下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.  \n这是一个at&t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。  \n这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。  \n最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。  \n4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出\n\n```hljs\n.globl _start\n    .code16\n_start:\n    mov $0x3f8, %dx\n    add %bl, %al\n    add $'0', %al\n    out %al, (%dx)\n    mov $'\\n', %al\n    out %al, (%dx)\n    hlt\n```\n\n我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件\n\n```hljs\nas -32 bin.S -o bin.o\nld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o\n```\n\n查看一下二进制格式\n\n```hljs\n➜  demo1 hexdump -C bin.bin\n00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|\n0000000c\n对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n```\n\n```hljs\n#include <err.h>\n#include <fcntl.h>\n#include <linux/kvm.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int kvm, vmfd, vcpufd, ret;\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n    uint8_t *mem;\n    struct kvm_sregs sregs;\n    size_t mmap_size;\n    struct kvm_run *run;\n\n    // 获取 kvm 句柄\n    kvm = open(\"/dev/kvm\", O_RDWR | O_CLOEXEC);\n    if (kvm == -1)\n        err(1, \"/dev/kvm\");\n\n    // 确保是正确的 API 版本\n    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_API_VERSION\");\n    if (ret != 12)\n        errx(1, \"KVM_GET_API_VERSION %d, expected 12\", ret);\n\n    // 创建一虚拟机\n    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);\n    if (vmfd == -1)\n        err(1, \"KVM_CREATE_VM\");\n\n    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中\n    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if (!mem)\n        err(1, \"allocating guest memory\");\n    memcpy(mem, code, sizeof(code));\n\n    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录\n    struct kvm_userspace_memory_region region = {\n        .slot = 0,\n        .guest_phys_addr = 0x1000,\n        .memory_size = 0x1000,\n        .userspace_addr = (uint64_t)mem,\n    };\n    // 设置 KVM 的内存区域\n    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &region);\n    if (ret == -1)\n        err(1, \"KVM_SET_USER_MEMORY_REGION\");\n\n    // 创建虚拟CPU\n    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);\n    if (vcpufd == -1)\n        err(1, \"KVM_CREATE_VCPU\");\n\n    // 获取 KVM 运行时结构的大小\n    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_VCPU_MMAP_SIZE\");\n    mmap_size = ret;\n    if (mmap_size < sizeof(*run))\n        errx(1, \"KVM_GET_VCPU_MMAP_SIZE unexpectedly small\");\n    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息\n    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);\n    if (!run)\n        err(1, \"mmap vcpu\");\n\n    // 获取特殊寄存器\n    ret = ioctl(vcpufd, KVM_GET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_GET_SREGS\");\n    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置\n    sregs.cs.base = 0;\n    sregs.cs.selector = 0;\n    // KVM_SET_SREGS 设置特殊寄存器\n    ret = ioctl(vcpufd, KVM_SET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_SET_SREGS\");\n\n\n    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。\n    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令\n    struct kvm_regs regs = {\n        .rip = 0x1000,\n        .rax = 2,    // 设置 ax 寄存器初始值为 2\n        .rbx = 2,    // 同理\n        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错\n    };\n    ret = ioctl(vcpufd, KVM_SET_REGS, &regs);\n    if (ret == -1)\n        err(1, \"KVM_SET_REGS\");\n\n    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令\n    while (1) {\n        // 开始运行虚拟机\n        ret = ioctl(vcpufd, KVM_RUN, NULL);\n        if (ret == -1)\n            err(1, \"KVM_RUN\");\n        // 获取虚拟机退出原因\n        switch (run->exit_reason) {\n        case KVM_EXIT_HLT:\n            puts(\"KVM_EXIT_HLT\");\n            return 0;\n        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以\n        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器\n        // 后面CPU虚拟化会讲到这部分\n        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到\n        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备\n        case KVM_EXIT_IO:\n            if (run->io.direction == KVM_EXIT_IO_OUT && run->io.size == 1 && run->io.port == 0x3f8 && run->io.count == 1)\n                putchar(*(((char *)run) + run->io.data_offset));\n            else\n                errx(1, \"unhandled KVM_EXIT_IO\");\n            break;\n        case KVM_EXIT_FAIL_ENTRY:\n            errx(1, \"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx\",\n                 (unsigned long long)run->fail_entry.hardware_entry_failure_reason);\n        case KVM_EXIT_INTERNAL_ERROR:\n            errx(1, \"KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x\", run->internal.suberror);\n        default:\n            errx(1, \"exit_reason = 0x%x\", run->exit_reason);\n        }\n    }\n}\n```\n\n编译并运行这个demo\n\n```hljs\ngcc -g demo.c -o demo\n➜  demo1 ./demo\n4\nKVM_EXIT_HLT\n```\n\n## 另外一个简单的QEMU emulator demo\n\n[IBM的徐同学有做过介绍](http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/)，在此基础上我再详细介绍一下qemu-kvm的启动过程。\n\n```hljs\n.globl _start\n    .code16\n_start:\n    xorw %ax, %ax   # 将 ax 寄存器清零\n\nloop1:\n    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&t汇编的操作数和Intel的相反。\n    inc %ax         # ax 值加一\n    jmp loop1       # 继续循环\n```\n\n这个汇编的作用就是一直不停的向0x10端口输出一字节的值。\n\n从main函数开始说起\n\n```hljs\nint main(int argc, char **argv) {\n    int ret = 0;\n    // 初始化kvm结构体\n    struct kvm *kvm = kvm_init();\n\n    if (kvm == NULL) {\n        fprintf(stderr, \"kvm init fauilt\\n\");\n        return -1;\n    }\n\n    // 创建VM，并分配内存空间\n    if (kvm_create_vm(kvm, RAM_SIZE) < 0) {\n        fprintf(stderr, \"create vm fault\\n\");\n        return -1;\n    }\n\n    // 加载镜像\n    load_binary(kvm);\n\n    // only support one vcpu now\n    kvm->vcpu_number = 1;\n    // 创建执行现场\n    kvm->vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);\n\n    // 启动虚拟机\n    kvm_run_vm(kvm);\n\n    kvm_clean_vm(kvm);\n    kvm_clean_vcpu(kvm->vcpus);\n    kvm_clean(kvm);\n}\n```\n\n第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。\n\n```hljs\nstruct kvm {\n   int dev_fd;              // /dev/kvm 的句柄\n   int vm_fd;               // GUEST 的句柄\n   __u64 ram_size;          // GUEST 的内存大小\n   __u64 ram_start;         // GUEST 的内存起始地址，\n                            // 这个地址是qemu emulator通过mmap映射的地址\n\n   int kvm_version;         \n   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、\n                                           // 允许对guest的地址做分段。将多个slot组成线性地址\n\n   struct vcpu *vcpus;      // vcpu 数组\n   int vcpu_number;         // vcpu 个数\n};\n```\n\n初始化 kvm 结构体。\n\n```hljs\nstruct kvm *kvm_init(void) {\n    struct kvm *kvm = malloc(sizeof(struct kvm));\n    kvm->dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄\n\n    if (kvm->dev_fd < 0) {\n        perror(\"open kvm device fault: \");\n        return NULL;\n    }\n\n    kvm->kvm_version = ioctl(kvm->dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本\n\n    return kvm;\n}\n```\n\n第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。\n\n```hljs\nint kvm_create_vm(struct kvm *kvm, int ram_size) {\n    int ret = 0;\n    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄\n    kvm->vm_fd = ioctl(kvm->dev_fd, KVM_CREATE_VM, 0);\n\n    if (kvm->vm_fd < 0) {\n        perror(\"can not create vm\");\n        return -1;\n    }\n\n    // 为 kvm 分配内存。通过系统调用.\n    kvm->ram_size = ram_size;\n    kvm->ram_start =  (__u64)mmap(NULL, kvm->ram_size, \n                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, \n                -1, 0);\n\n    if ((void *)kvm->ram_start == MAP_FAILED) {\n        perror(\"can not mmap ram\");\n        return -1;\n    }\n\n    // kvm->mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口\n    // 只有一个内存槽\n    kvm->mem.slot = 0;\n    // guest 物理内存起始地址\n    kvm->mem.guest_phys_addr = 0;\n    // 虚拟机内存大小\n    kvm->mem.memory_size = kvm->ram_size;\n    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest\n    kvm->mem.userspace_addr = kvm->ram_start;\n\n    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。\n    ret = ioctl(kvm->vm_fd, KVM_SET_USER_MEMORY_REGION, &(kvm->mem));\n\n    if (ret < 0) {\n        perror(\"can not set user memory region\");\n        return ret;\n    }\n    return ret;\n}\n```\n\n接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。\n\n```hljs\nvoid load_binary(struct kvm *kvm) {\n    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）\n\n    if (fd < 0) {\n        fprintf(stderr, \"can not open binary file\\n\");\n        exit(1);\n    }\n\n    int ret = 0;\n    char *p = (char *)kvm->ram_start;\n\n    while(1) {\n        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中\n        if (ret <= 0) {\n            break;\n        }\n        printf(\"read size: %d\", ret);\n        p += ret;\n    }\n}\n```\n\n加载完镜像后，需要初始化vCPU，以便能够运行镜像内容\n\n```hljs\nstruct vcpu {\n    int vcpu_id;                 // vCPU id，vCPU\n    int vcpu_fd;                 // vCPU 句柄\n    pthread_t vcpu_thread;       // vCPU 线程句柄\n    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文\n    int kvm_run_mmap_size;       // 运行时结构大小\n    struct kvm_regs regs;        // vCPU的寄存器\n    struct kvm_sregs sregs;      // vCPU的特殊寄存器\n    void *(*vcpu_thread_func)(void *);  // 线程执行函数\n};\n\nstruct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) {\n    // 申请vcpu结构\n    struct vcpu *vcpu = malloc(sizeof(struct vcpu));\n    // 只有一个 vCPU，所以这里只初始化一个\n    vcpu->vcpu_id = 0;\n    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm->vm_fd（由KVM_CREATE_VM返回）\n    vcpu->vcpu_fd = ioctl(kvm->vm_fd, KVM_CREATE_VCPU, vcpu->vcpu_id);\n\n    if (vcpu->vcpu_fd < 0) {\n        perror(\"can not create vcpu\");\n        return NULL;\n    }\n\n    // 获取KVM运行时结构大小\n    vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (vcpu->kvm_run_mmap_size < 0) {\n        perror(\"can not get vcpu mmsize\");\n        return NULL;\n    }\n\n    printf(\"%d\\n\", vcpu->kvm_run_mmap_size);\n    // 将 vcpu_fd 的内存映射给 vcpu->kvm_run结构。相当于一个关联操作\n    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息\n    vcpu->kvm_run = mmap(NULL, vcpu->kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu->vcpu_fd, 0);\n\n    if (vcpu->kvm_run == MAP_FAILED) {\n        perror(\"can not mmap kvm_run\");\n        return NULL;\n    }\n\n    // 设置线程执行函数\n    vcpu->vcpu_thread_func = fn;\n    return vcpu;\n}\n```\n\n最后一步，以上工作就绪后，启动虚拟机。\n\n```hljs\nvoid kvm_run_vm(struct kvm *kvm) {\n    int i = 0;\n\n    for (i = 0; i < kvm->vcpu_number; i++) {\n        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程\n        if (pthread_create(&(kvm->vcpus->vcpu_thread), (const pthread_attr_t *)NULL, kvm->vcpus[i].vcpu_thread_func, kvm) != 0) {\n            perror(\"can not create kvm thread\");\n            exit(1);\n        }\n    }\n\n    pthread_join(kvm->vcpus->vcpu_thread, NULL);\n}\n```\n\n启动虚拟机其实就是创建线程，并执行相应的线程回调函数。  \n线程回调函数在kvm_init_vcpu的时候传入\n\n```hljs\nvoid *kvm_cpu_thread(void *data) {\n    // 获取参数\n    struct kvm *kvm = (struct kvm *)data;\n    int ret = 0;\n    // 设置KVM的参数\n    kvm_reset_vcpu(kvm->vcpus);\n\n    while (1) {\n        printf(\"KVM start run\\n\");\n        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。\n        ret = ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n\n        if (ret < 0) {\n            fprintf(stderr, \"KVM_RUN failed\\n\");\n            exit(1);\n        }\n\n        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存\n        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因\n        switch (kvm->vcpus->kvm_run->exit_reason) {\n        case KVM_EXIT_UNKNOWN:\n            printf(\"KVM_EXIT_UNKNOWN\\n\");\n            break;\n        case KVM_EXIT_DEBUG:\n            printf(\"KVM_EXIT_DEBUG\\n\");\n            break;\n        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并\n        // 把执行权交给emulator\n        case KVM_EXIT_IO:\n            printf(\"KVM_EXIT_IO\\n\");\n            printf(\"out port: %d, data: %d\\n\", \n                kvm->vcpus->kvm_run->io.port,  \n                *(int *)((char *)(kvm->vcpus->kvm_run) + kvm->vcpus->kvm_run->io.data_offset)\n                );\n            sleep(1);\n            break;\n        // 虚拟机执行了memory map IO操作\n        case KVM_EXIT_MMIO:\n            printf(\"KVM_EXIT_MMIO\\n\");\n            break;\n        case KVM_EXIT_INTR:\n            printf(\"KVM_EXIT_INTR\\n\");\n            break;\n        case KVM_EXIT_SHUTDOWN:\n            printf(\"KVM_EXIT_SHUTDOWN\\n\");\n            goto exit_kvm;\n            break;\n        default:\n            printf(\"KVM PANIC\\n\");\n            goto exit_kvm;\n        }\n    }\n\nexit_kvm:\n    return 0;\n}\n\nvoid kvm_reset_vcpu (struct vcpu *vcpu) {\n    if (ioctl(vcpu->vcpu_fd, KVM_GET_SREGS, &(vcpu->sregs)) < 0) {\n        perror(\"can not get sregs\\n\");\n        exit(1);\n    }\n    // #define CODE_START 0x1000\n    /* sregs 结构体\n        x86\n        struct kvm_sregs {\n            struct kvm_segment cs, ds, es, fs, gs, ss;\n            struct kvm_segment tr, ldt;\n            struct kvm_dtable gdt, idt;\n            __u64 cr0, cr2, cr3, cr4, cr8;\n            __u64 efer;\n            __u64 apic_base;\n            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];\n        };\n    */\n    // cs 为code start寄存器，存放了程序的起始地址\n    vcpu->sregs.cs.selector = CODE_START;\n    vcpu->sregs.cs.base = CODE_START * 16;\n    // ss 为堆栈寄存器，存放了堆栈的起始位置\n    vcpu->sregs.ss.selector = CODE_START;\n    vcpu->sregs.ss.base = CODE_START * 16;\n    // ds 为数据段寄存器，存放了数据开始地址\n    vcpu->sregs.ds.selector = CODE_START;\n    vcpu->sregs.ds.base = CODE_START *16;\n    // es 为附加段寄存器\n    vcpu->sregs.es.selector = CODE_START;\n    vcpu->sregs.es.base = CODE_START * 16;\n    // fs, gs 同样为段寄存器\n    vcpu->sregs.fs.selector = CODE_START;\n    vcpu->sregs.fs.base = CODE_START * 16;\n    vcpu->sregs.gs.selector = CODE_START;\n\n    // 为vCPU设置以上寄存器的值\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_SREGS, &vcpu->sregs) < 0) {\n        perror(\"can not set sregs\");\n        exit(1);\n    }\n\n    // 设置寄存器标志位\n    vcpu->regs.rflags = 0x0000000000000002ULL;\n    // rip 表示了程序的起始指针，地址为 0x0000000\n    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位\n    // 所以虚拟机开始的时候会直接运行binary\n    vcpu->regs.rip = 0;\n    // rsp 为堆栈顶\n    vcpu->regs.rsp = 0xffffffff;\n    // rbp 为堆栈底部\n    vcpu->regs.rbp= 0;\n\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_REGS, &(vcpu->regs)) < 0) {\n        perror(\"KVM SET REGS\\n\");\n        exit(1);\n    }\n}\n```\n\n运行一下结果，可以看到当虚拟机执行了指令 `out %ax, $0x10` 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。  \n宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。\n\n```hljs\n➜  kvmsample git:(master) ✗ ./kvmsample\nread size: 712288\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 0\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 1\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 2\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 3\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 4\n...\n```\n\n## 总结\n\n虚拟机的启动过程基本上可以这么总结：  \n创建kvm句柄->创建vm->分配内存->加载镜像到内存->启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。\n\n当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。\n","source":"_posts/kvm-boot.md","raw":"title: KVM 虚拟化原理2— QEMU启动过程\ndonate: true\ndate: 2018-12-10 22:57:17\ncategories: KVM\ntags:\n---\n\n## 虚拟机启动过程\n\n```hljs\n第一步，获取到kvm句柄\nkvmfd = open(\"/dev/kvm\", O_RDWR);\n第二步，创建虚拟机，获取到虚拟机句柄。\nvmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);\n第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。\nioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);\n第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。\n第五步，创建vCPU，并为vCPU分配内存空间。\nioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);\nvcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n第五步，创建vCPU个数的线程并运行虚拟机。\nioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。\n这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。\n```\n\n```hljs\nopen(\"/dev/kvm\")\nioctl(KVM_CREATE_VM)\nioctl(KVM_CREATE_VCPU)\nfor (;;) {\n     ioctl(KVM_RUN)\n     switch (exit_reason) {\n     case KVM_EXIT_IO:  /* ... */\n     case KVM_EXIT_HLT: /* ... */\n     }\n}\n```\n\n关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。\n\n[KVM ioctl接口文档](https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt)\n\n## 先来一个KVM API开胃菜\n\n下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.  \n这是一个at&t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。  \n这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。  \n最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。  \n4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出\n\n```hljs\n.globl _start\n    .code16\n_start:\n    mov $0x3f8, %dx\n    add %bl, %al\n    add $'0', %al\n    out %al, (%dx)\n    mov $'\\n', %al\n    out %al, (%dx)\n    hlt\n```\n\n我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件\n\n```hljs\nas -32 bin.S -o bin.o\nld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o\n```\n\n查看一下二进制格式\n\n```hljs\n➜  demo1 hexdump -C bin.bin\n00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|\n0000000c\n对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n```\n\n```hljs\n#include <err.h>\n#include <fcntl.h>\n#include <linux/kvm.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int kvm, vmfd, vcpufd, ret;\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n    uint8_t *mem;\n    struct kvm_sregs sregs;\n    size_t mmap_size;\n    struct kvm_run *run;\n\n    // 获取 kvm 句柄\n    kvm = open(\"/dev/kvm\", O_RDWR | O_CLOEXEC);\n    if (kvm == -1)\n        err(1, \"/dev/kvm\");\n\n    // 确保是正确的 API 版本\n    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_API_VERSION\");\n    if (ret != 12)\n        errx(1, \"KVM_GET_API_VERSION %d, expected 12\", ret);\n\n    // 创建一虚拟机\n    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);\n    if (vmfd == -1)\n        err(1, \"KVM_CREATE_VM\");\n\n    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中\n    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if (!mem)\n        err(1, \"allocating guest memory\");\n    memcpy(mem, code, sizeof(code));\n\n    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录\n    struct kvm_userspace_memory_region region = {\n        .slot = 0,\n        .guest_phys_addr = 0x1000,\n        .memory_size = 0x1000,\n        .userspace_addr = (uint64_t)mem,\n    };\n    // 设置 KVM 的内存区域\n    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &region);\n    if (ret == -1)\n        err(1, \"KVM_SET_USER_MEMORY_REGION\");\n\n    // 创建虚拟CPU\n    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);\n    if (vcpufd == -1)\n        err(1, \"KVM_CREATE_VCPU\");\n\n    // 获取 KVM 运行时结构的大小\n    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_VCPU_MMAP_SIZE\");\n    mmap_size = ret;\n    if (mmap_size < sizeof(*run))\n        errx(1, \"KVM_GET_VCPU_MMAP_SIZE unexpectedly small\");\n    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息\n    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);\n    if (!run)\n        err(1, \"mmap vcpu\");\n\n    // 获取特殊寄存器\n    ret = ioctl(vcpufd, KVM_GET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_GET_SREGS\");\n    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置\n    sregs.cs.base = 0;\n    sregs.cs.selector = 0;\n    // KVM_SET_SREGS 设置特殊寄存器\n    ret = ioctl(vcpufd, KVM_SET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_SET_SREGS\");\n\n\n    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。\n    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令\n    struct kvm_regs regs = {\n        .rip = 0x1000,\n        .rax = 2,    // 设置 ax 寄存器初始值为 2\n        .rbx = 2,    // 同理\n        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错\n    };\n    ret = ioctl(vcpufd, KVM_SET_REGS, &regs);\n    if (ret == -1)\n        err(1, \"KVM_SET_REGS\");\n\n    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令\n    while (1) {\n        // 开始运行虚拟机\n        ret = ioctl(vcpufd, KVM_RUN, NULL);\n        if (ret == -1)\n            err(1, \"KVM_RUN\");\n        // 获取虚拟机退出原因\n        switch (run->exit_reason) {\n        case KVM_EXIT_HLT:\n            puts(\"KVM_EXIT_HLT\");\n            return 0;\n        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以\n        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器\n        // 后面CPU虚拟化会讲到这部分\n        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到\n        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备\n        case KVM_EXIT_IO:\n            if (run->io.direction == KVM_EXIT_IO_OUT && run->io.size == 1 && run->io.port == 0x3f8 && run->io.count == 1)\n                putchar(*(((char *)run) + run->io.data_offset));\n            else\n                errx(1, \"unhandled KVM_EXIT_IO\");\n            break;\n        case KVM_EXIT_FAIL_ENTRY:\n            errx(1, \"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx\",\n                 (unsigned long long)run->fail_entry.hardware_entry_failure_reason);\n        case KVM_EXIT_INTERNAL_ERROR:\n            errx(1, \"KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x\", run->internal.suberror);\n        default:\n            errx(1, \"exit_reason = 0x%x\", run->exit_reason);\n        }\n    }\n}\n```\n\n编译并运行这个demo\n\n```hljs\ngcc -g demo.c -o demo\n➜  demo1 ./demo\n4\nKVM_EXIT_HLT\n```\n\n## 另外一个简单的QEMU emulator demo\n\n[IBM的徐同学有做过介绍](http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/)，在此基础上我再详细介绍一下qemu-kvm的启动过程。\n\n```hljs\n.globl _start\n    .code16\n_start:\n    xorw %ax, %ax   # 将 ax 寄存器清零\n\nloop1:\n    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&t汇编的操作数和Intel的相反。\n    inc %ax         # ax 值加一\n    jmp loop1       # 继续循环\n```\n\n这个汇编的作用就是一直不停的向0x10端口输出一字节的值。\n\n从main函数开始说起\n\n```hljs\nint main(int argc, char **argv) {\n    int ret = 0;\n    // 初始化kvm结构体\n    struct kvm *kvm = kvm_init();\n\n    if (kvm == NULL) {\n        fprintf(stderr, \"kvm init fauilt\\n\");\n        return -1;\n    }\n\n    // 创建VM，并分配内存空间\n    if (kvm_create_vm(kvm, RAM_SIZE) < 0) {\n        fprintf(stderr, \"create vm fault\\n\");\n        return -1;\n    }\n\n    // 加载镜像\n    load_binary(kvm);\n\n    // only support one vcpu now\n    kvm->vcpu_number = 1;\n    // 创建执行现场\n    kvm->vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);\n\n    // 启动虚拟机\n    kvm_run_vm(kvm);\n\n    kvm_clean_vm(kvm);\n    kvm_clean_vcpu(kvm->vcpus);\n    kvm_clean(kvm);\n}\n```\n\n第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。\n\n```hljs\nstruct kvm {\n   int dev_fd;              // /dev/kvm 的句柄\n   int vm_fd;               // GUEST 的句柄\n   __u64 ram_size;          // GUEST 的内存大小\n   __u64 ram_start;         // GUEST 的内存起始地址，\n                            // 这个地址是qemu emulator通过mmap映射的地址\n\n   int kvm_version;         \n   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、\n                                           // 允许对guest的地址做分段。将多个slot组成线性地址\n\n   struct vcpu *vcpus;      // vcpu 数组\n   int vcpu_number;         // vcpu 个数\n};\n```\n\n初始化 kvm 结构体。\n\n```hljs\nstruct kvm *kvm_init(void) {\n    struct kvm *kvm = malloc(sizeof(struct kvm));\n    kvm->dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄\n\n    if (kvm->dev_fd < 0) {\n        perror(\"open kvm device fault: \");\n        return NULL;\n    }\n\n    kvm->kvm_version = ioctl(kvm->dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本\n\n    return kvm;\n}\n```\n\n第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。\n\n```hljs\nint kvm_create_vm(struct kvm *kvm, int ram_size) {\n    int ret = 0;\n    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄\n    kvm->vm_fd = ioctl(kvm->dev_fd, KVM_CREATE_VM, 0);\n\n    if (kvm->vm_fd < 0) {\n        perror(\"can not create vm\");\n        return -1;\n    }\n\n    // 为 kvm 分配内存。通过系统调用.\n    kvm->ram_size = ram_size;\n    kvm->ram_start =  (__u64)mmap(NULL, kvm->ram_size, \n                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, \n                -1, 0);\n\n    if ((void *)kvm->ram_start == MAP_FAILED) {\n        perror(\"can not mmap ram\");\n        return -1;\n    }\n\n    // kvm->mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口\n    // 只有一个内存槽\n    kvm->mem.slot = 0;\n    // guest 物理内存起始地址\n    kvm->mem.guest_phys_addr = 0;\n    // 虚拟机内存大小\n    kvm->mem.memory_size = kvm->ram_size;\n    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest\n    kvm->mem.userspace_addr = kvm->ram_start;\n\n    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。\n    ret = ioctl(kvm->vm_fd, KVM_SET_USER_MEMORY_REGION, &(kvm->mem));\n\n    if (ret < 0) {\n        perror(\"can not set user memory region\");\n        return ret;\n    }\n    return ret;\n}\n```\n\n接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。\n\n```hljs\nvoid load_binary(struct kvm *kvm) {\n    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）\n\n    if (fd < 0) {\n        fprintf(stderr, \"can not open binary file\\n\");\n        exit(1);\n    }\n\n    int ret = 0;\n    char *p = (char *)kvm->ram_start;\n\n    while(1) {\n        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中\n        if (ret <= 0) {\n            break;\n        }\n        printf(\"read size: %d\", ret);\n        p += ret;\n    }\n}\n```\n\n加载完镜像后，需要初始化vCPU，以便能够运行镜像内容\n\n```hljs\nstruct vcpu {\n    int vcpu_id;                 // vCPU id，vCPU\n    int vcpu_fd;                 // vCPU 句柄\n    pthread_t vcpu_thread;       // vCPU 线程句柄\n    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文\n    int kvm_run_mmap_size;       // 运行时结构大小\n    struct kvm_regs regs;        // vCPU的寄存器\n    struct kvm_sregs sregs;      // vCPU的特殊寄存器\n    void *(*vcpu_thread_func)(void *);  // 线程执行函数\n};\n\nstruct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) {\n    // 申请vcpu结构\n    struct vcpu *vcpu = malloc(sizeof(struct vcpu));\n    // 只有一个 vCPU，所以这里只初始化一个\n    vcpu->vcpu_id = 0;\n    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm->vm_fd（由KVM_CREATE_VM返回）\n    vcpu->vcpu_fd = ioctl(kvm->vm_fd, KVM_CREATE_VCPU, vcpu->vcpu_id);\n\n    if (vcpu->vcpu_fd < 0) {\n        perror(\"can not create vcpu\");\n        return NULL;\n    }\n\n    // 获取KVM运行时结构大小\n    vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (vcpu->kvm_run_mmap_size < 0) {\n        perror(\"can not get vcpu mmsize\");\n        return NULL;\n    }\n\n    printf(\"%d\\n\", vcpu->kvm_run_mmap_size);\n    // 将 vcpu_fd 的内存映射给 vcpu->kvm_run结构。相当于一个关联操作\n    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息\n    vcpu->kvm_run = mmap(NULL, vcpu->kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu->vcpu_fd, 0);\n\n    if (vcpu->kvm_run == MAP_FAILED) {\n        perror(\"can not mmap kvm_run\");\n        return NULL;\n    }\n\n    // 设置线程执行函数\n    vcpu->vcpu_thread_func = fn;\n    return vcpu;\n}\n```\n\n最后一步，以上工作就绪后，启动虚拟机。\n\n```hljs\nvoid kvm_run_vm(struct kvm *kvm) {\n    int i = 0;\n\n    for (i = 0; i < kvm->vcpu_number; i++) {\n        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程\n        if (pthread_create(&(kvm->vcpus->vcpu_thread), (const pthread_attr_t *)NULL, kvm->vcpus[i].vcpu_thread_func, kvm) != 0) {\n            perror(\"can not create kvm thread\");\n            exit(1);\n        }\n    }\n\n    pthread_join(kvm->vcpus->vcpu_thread, NULL);\n}\n```\n\n启动虚拟机其实就是创建线程，并执行相应的线程回调函数。  \n线程回调函数在kvm_init_vcpu的时候传入\n\n```hljs\nvoid *kvm_cpu_thread(void *data) {\n    // 获取参数\n    struct kvm *kvm = (struct kvm *)data;\n    int ret = 0;\n    // 设置KVM的参数\n    kvm_reset_vcpu(kvm->vcpus);\n\n    while (1) {\n        printf(\"KVM start run\\n\");\n        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。\n        ret = ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n\n        if (ret < 0) {\n            fprintf(stderr, \"KVM_RUN failed\\n\");\n            exit(1);\n        }\n\n        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存\n        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因\n        switch (kvm->vcpus->kvm_run->exit_reason) {\n        case KVM_EXIT_UNKNOWN:\n            printf(\"KVM_EXIT_UNKNOWN\\n\");\n            break;\n        case KVM_EXIT_DEBUG:\n            printf(\"KVM_EXIT_DEBUG\\n\");\n            break;\n        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并\n        // 把执行权交给emulator\n        case KVM_EXIT_IO:\n            printf(\"KVM_EXIT_IO\\n\");\n            printf(\"out port: %d, data: %d\\n\", \n                kvm->vcpus->kvm_run->io.port,  \n                *(int *)((char *)(kvm->vcpus->kvm_run) + kvm->vcpus->kvm_run->io.data_offset)\n                );\n            sleep(1);\n            break;\n        // 虚拟机执行了memory map IO操作\n        case KVM_EXIT_MMIO:\n            printf(\"KVM_EXIT_MMIO\\n\");\n            break;\n        case KVM_EXIT_INTR:\n            printf(\"KVM_EXIT_INTR\\n\");\n            break;\n        case KVM_EXIT_SHUTDOWN:\n            printf(\"KVM_EXIT_SHUTDOWN\\n\");\n            goto exit_kvm;\n            break;\n        default:\n            printf(\"KVM PANIC\\n\");\n            goto exit_kvm;\n        }\n    }\n\nexit_kvm:\n    return 0;\n}\n\nvoid kvm_reset_vcpu (struct vcpu *vcpu) {\n    if (ioctl(vcpu->vcpu_fd, KVM_GET_SREGS, &(vcpu->sregs)) < 0) {\n        perror(\"can not get sregs\\n\");\n        exit(1);\n    }\n    // #define CODE_START 0x1000\n    /* sregs 结构体\n        x86\n        struct kvm_sregs {\n            struct kvm_segment cs, ds, es, fs, gs, ss;\n            struct kvm_segment tr, ldt;\n            struct kvm_dtable gdt, idt;\n            __u64 cr0, cr2, cr3, cr4, cr8;\n            __u64 efer;\n            __u64 apic_base;\n            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];\n        };\n    */\n    // cs 为code start寄存器，存放了程序的起始地址\n    vcpu->sregs.cs.selector = CODE_START;\n    vcpu->sregs.cs.base = CODE_START * 16;\n    // ss 为堆栈寄存器，存放了堆栈的起始位置\n    vcpu->sregs.ss.selector = CODE_START;\n    vcpu->sregs.ss.base = CODE_START * 16;\n    // ds 为数据段寄存器，存放了数据开始地址\n    vcpu->sregs.ds.selector = CODE_START;\n    vcpu->sregs.ds.base = CODE_START *16;\n    // es 为附加段寄存器\n    vcpu->sregs.es.selector = CODE_START;\n    vcpu->sregs.es.base = CODE_START * 16;\n    // fs, gs 同样为段寄存器\n    vcpu->sregs.fs.selector = CODE_START;\n    vcpu->sregs.fs.base = CODE_START * 16;\n    vcpu->sregs.gs.selector = CODE_START;\n\n    // 为vCPU设置以上寄存器的值\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_SREGS, &vcpu->sregs) < 0) {\n        perror(\"can not set sregs\");\n        exit(1);\n    }\n\n    // 设置寄存器标志位\n    vcpu->regs.rflags = 0x0000000000000002ULL;\n    // rip 表示了程序的起始指针，地址为 0x0000000\n    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位\n    // 所以虚拟机开始的时候会直接运行binary\n    vcpu->regs.rip = 0;\n    // rsp 为堆栈顶\n    vcpu->regs.rsp = 0xffffffff;\n    // rbp 为堆栈底部\n    vcpu->regs.rbp= 0;\n\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_REGS, &(vcpu->regs)) < 0) {\n        perror(\"KVM SET REGS\\n\");\n        exit(1);\n    }\n}\n```\n\n运行一下结果，可以看到当虚拟机执行了指令 `out %ax, $0x10` 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。  \n宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。\n\n```hljs\n➜  kvmsample git:(master) ✗ ./kvmsample\nread size: 712288\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 0\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 1\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 2\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 3\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 4\n...\n```\n\n## 总结\n\n虚拟机的启动过程基本上可以这么总结：  \n创建kvm句柄->创建vm->分配内存->加载镜像到内存->启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。\n\n当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。\n","slug":"kvm-boot","published":1,"updated":"2018-12-10T15:15:23.349Z","_id":"cjpigfqzv000hbpo45c840ig4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"虚拟机启动过程\"><a href=\"#虚拟机启动过程\" class=\"headerlink\" title=\"虚拟机启动过程\"></a>虚拟机启动过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步，获取到kvm句柄</span><br><span class=\"line\">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class=\"line\">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class=\"line\">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class=\"line\">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class=\"line\">ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class=\"line\">第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。</span><br><span class=\"line\">第五步，创建vCPU，并为vCPU分配内存空间。</span><br><span class=\"line\">ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);</span><br><span class=\"line\">vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\">第五步，创建vCPU个数的线程并运行虚拟机。</span><br><span class=\"line\">ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\">第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class=\"line\">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/kvm&quot;)</span><br><span class=\"line\">ioctl(KVM_CREATE_VM)</span><br><span class=\"line\">ioctl(KVM_CREATE_VCPU)</span><br><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">     ioctl(KVM_RUN)</span><br><span class=\"line\">     switch (exit_reason) &#123;</span><br><span class=\"line\">     case KVM_EXIT_IO:  /* ... */</span><br><span class=\"line\">     case KVM_EXIT_HLT: /* ... */</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt\" target=\"_blank\" rel=\"noopener\">KVM ioctl接口文档</a></p>\n<h2 id=\"先来一个KVM-API开胃菜\"><a href=\"#先来一个KVM-API开胃菜\" class=\"headerlink\" title=\"先来一个KVM API开胃菜\"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    mov $0x3f8, %dx</span><br><span class=\"line\">    add %bl, %al</span><br><span class=\"line\">    add $&apos;0&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    mov $&apos;\\n&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    hlt</span><br></pre></td></tr></table></figure>\n<p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as -32 bin.S -o bin.o</span><br><span class=\"line\">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure>\n<p>查看一下二进制格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  demo1 hexdump -C bin.bin</span><br><span class=\"line\">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class=\"line\">0000000c</span><br><span class=\"line\">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;err.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;linux/kvm.h&gt;</span><br><span class=\"line\">#include &lt;stdint.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;</span><br><span class=\"line\">#include &lt;sys/mman.h&gt;</span><br><span class=\"line\">#include &lt;sys/stat.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int kvm, vmfd, vcpufd, ret;</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uint8_t *mem;</span><br><span class=\"line\">    struct kvm_sregs sregs;</span><br><span class=\"line\">    size_t mmap_size;</span><br><span class=\"line\">    struct kvm_run *run;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 kvm 句柄</span><br><span class=\"line\">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class=\"line\">    if (kvm == -1)</span><br><span class=\"line\">        err(1, &quot;/dev/kvm&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 确保是正确的 API 版本</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class=\"line\">    if (ret != 12)</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一虚拟机</span><br><span class=\"line\">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class=\"line\">    if (vmfd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class=\"line\">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class=\"line\">    if (!mem)</span><br><span class=\"line\">        err(1, &quot;allocating guest memory&quot;);</span><br><span class=\"line\">    memcpy(mem, code, sizeof(code));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class=\"line\">    struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">        .slot = 0,</span><br><span class=\"line\">        .guest_phys_addr = 0x1000,</span><br><span class=\"line\">        .memory_size = 0x1000,</span><br><span class=\"line\">        .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 设置 KVM 的内存区域</span><br><span class=\"line\">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建虚拟CPU</span><br><span class=\"line\">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class=\"line\">    if (vcpufd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 KVM 运行时结构的大小</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class=\"line\">    mmap_size = ret;</span><br><span class=\"line\">    if (mmap_size &lt; sizeof(*run))</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class=\"line\">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息</span><br><span class=\"line\">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class=\"line\">    if (!run)</span><br><span class=\"line\">        err(1, &quot;mmap vcpu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class=\"line\">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class=\"line\">    sregs.cs.base = 0;</span><br><span class=\"line\">    sregs.cs.selector = 0;</span><br><span class=\"line\">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class=\"line\">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class=\"line\">    struct kvm_regs regs = &#123;</span><br><span class=\"line\">        .rip = 0x1000,</span><br><span class=\"line\">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class=\"line\">        .rbx = 2,    // 同理</span><br><span class=\"line\">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        // 开始运行虚拟机</span><br><span class=\"line\">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">            err(1, &quot;KVM_RUN&quot;);</span><br><span class=\"line\">        // 获取虚拟机退出原因</span><br><span class=\"line\">        switch (run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_HLT:</span><br><span class=\"line\">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class=\"line\">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class=\"line\">        // 后面CPU虚拟化会讲到这部分</span><br><span class=\"line\">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class=\"line\">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class=\"line\">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class=\"line\">            else</span><br><span class=\"line\">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class=\"line\">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class=\"line\">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译并运行这个demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g demo.c -o demo</span><br><span class=\"line\">➜  demo1 ./demo</span><br><span class=\"line\">4</span><br><span class=\"line\">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>\n<h2 id=\"另外一个简单的QEMU-emulator-demo\"><a href=\"#另外一个简单的QEMU-emulator-demo\" class=\"headerlink\" title=\"另外一个简单的QEMU emulator demo\"></a>另外一个简单的QEMU emulator demo</h2><p><a href=\"http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/\" target=\"_blank\" rel=\"noopener\">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class=\"line\"></span><br><span class=\"line\">loop1:</span><br><span class=\"line\">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class=\"line\">    inc %ax         # ax 值加一</span><br><span class=\"line\">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure>\n<p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p>\n<p>从main函数开始说起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char **argv) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 初始化kvm结构体</span><br><span class=\"line\">    struct kvm *kvm = kvm_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm == NULL) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;kvm init fauilt\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建VM，并分配内存空间</span><br><span class=\"line\">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;create vm fault\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加载镜像</span><br><span class=\"line\">    load_binary(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    // only support one vcpu now</span><br><span class=\"line\">    kvm-&gt;vcpu_number = 1;</span><br><span class=\"line\">    // 创建执行现场</span><br><span class=\"line\">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动虚拟机</span><br><span class=\"line\">    kvm_run_vm(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm_clean_vm(kvm);</span><br><span class=\"line\">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\">    kvm_clean(kvm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm &#123;</span><br><span class=\"line\">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class=\"line\">   int vm_fd;               // GUEST 的句柄</span><br><span class=\"line\">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class=\"line\">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class=\"line\">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class=\"line\"></span><br><span class=\"line\">   int kvm_version;         </span><br><span class=\"line\">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class=\"line\">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class=\"line\"></span><br><span class=\"line\">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class=\"line\">   int vcpu_number;         // vcpu 个数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>初始化 kvm 结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm *kvm_init(void) &#123;</span><br><span class=\"line\">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class=\"line\">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;open kvm device fault: &quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class=\"line\"></span><br><span class=\"line\">    return kvm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class=\"line\">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vm&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 kvm 分配内存。通过系统调用.</span><br><span class=\"line\">    kvm-&gt;ram_size = ram_size;</span><br><span class=\"line\">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class=\"line\">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class=\"line\">                -1, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap ram&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class=\"line\">    // 只有一个内存槽</span><br><span class=\"line\">    kvm-&gt;mem.slot = 0;</span><br><span class=\"line\">    // guest 物理内存起始地址</span><br><span class=\"line\">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class=\"line\">    // 虚拟机内存大小</span><br><span class=\"line\">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class=\"line\">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class=\"line\">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class=\"line\">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ret &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set user memory region&quot;);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_binary(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fd &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;can not open binary file\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class=\"line\">        if (ret &lt;= 0) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printf(&quot;read size: %d&quot;, ret);</span><br><span class=\"line\">        p += ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct vcpu &#123;</span><br><span class=\"line\">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class=\"line\">    int vcpu_fd;                 // vCPU 句柄</span><br><span class=\"line\">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class=\"line\">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class=\"line\">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class=\"line\">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class=\"line\">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class=\"line\">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class=\"line\">    // 申请vcpu结构</span><br><span class=\"line\">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class=\"line\">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class=\"line\">    vcpu-&gt;vcpu_id = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class=\"line\">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vcpu&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取KVM运行时结构大小</span><br><span class=\"line\">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class=\"line\">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class=\"line\">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class=\"line\">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置线程执行函数</span><br><span class=\"line\">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class=\"line\">    return vcpu;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一步，以上工作就绪后，启动虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class=\"line\">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class=\"line\">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class=\"line\">            perror(&quot;can not create kvm thread&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *kvm_cpu_thread(void *data) &#123;</span><br><span class=\"line\">    // 获取参数</span><br><span class=\"line\">    struct kvm *kvm = (struct kvm *)data;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 设置KVM的参数</span><br><span class=\"line\">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        printf(&quot;KVM start run\\n&quot;);</span><br><span class=\"line\">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class=\"line\">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (ret &lt; 0) &#123;</span><br><span class=\"line\">            fprintf(stderr, &quot;KVM_RUN failed\\n&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class=\"line\">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class=\"line\">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_UNKNOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_UNKNOWN\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_DEBUG:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_DEBUG\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class=\"line\">        // 把执行权交给emulator</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_IO\\n&quot;);</span><br><span class=\"line\">            printf(&quot;out port: %d, data: %d\\n&quot;, </span><br><span class=\"line\">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class=\"line\">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class=\"line\">                );</span><br><span class=\"line\">            sleep(1);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了memory map IO操作</span><br><span class=\"line\">        case KVM_EXIT_MMIO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_MMIO\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_INTR:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_INTR\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_SHUTDOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_SHUTDOWN\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            printf(&quot;KVM PANIC\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_kvm:</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get sregs\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // #define CODE_START 0x1000</span><br><span class=\"line\">    /* sregs 结构体</span><br><span class=\"line\">        x86</span><br><span class=\"line\">        struct kvm_sregs &#123;</span><br><span class=\"line\">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class=\"line\">            struct kvm_segment tr, ldt;</span><br><span class=\"line\">            struct kvm_dtable gdt, idt;</span><br><span class=\"line\">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class=\"line\">            __u64 efer;</span><br><span class=\"line\">            __u64 apic_base;</span><br><span class=\"line\">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class=\"line\">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class=\"line\">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class=\"line\">    // es 为附加段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class=\"line\">    // fs, gs 同样为段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class=\"line\">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为vCPU设置以上寄存器的值</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set sregs&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置寄存器标志位</span><br><span class=\"line\">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class=\"line\">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class=\"line\">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class=\"line\">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class=\"line\">    vcpu-&gt;regs.rip = 0;</span><br><span class=\"line\">    // rsp 为堆栈顶</span><br><span class=\"line\">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class=\"line\">    // rbp 为堆栈底部</span><br><span class=\"line\">    vcpu-&gt;regs.rbp= 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;KVM SET REGS\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class=\"line\">read size: 712288</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 0</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 1</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 2</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 3</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p>\n<p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"虚拟机启动过程\"><a href=\"#虚拟机启动过程\" class=\"headerlink\" title=\"虚拟机启动过程\"></a>虚拟机启动过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步，获取到kvm句柄</span><br><span class=\"line\">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class=\"line\">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class=\"line\">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class=\"line\">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class=\"line\">ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class=\"line\">第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。</span><br><span class=\"line\">第五步，创建vCPU，并为vCPU分配内存空间。</span><br><span class=\"line\">ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);</span><br><span class=\"line\">vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\">第五步，创建vCPU个数的线程并运行虚拟机。</span><br><span class=\"line\">ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\">第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class=\"line\">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/kvm&quot;)</span><br><span class=\"line\">ioctl(KVM_CREATE_VM)</span><br><span class=\"line\">ioctl(KVM_CREATE_VCPU)</span><br><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">     ioctl(KVM_RUN)</span><br><span class=\"line\">     switch (exit_reason) &#123;</span><br><span class=\"line\">     case KVM_EXIT_IO:  /* ... */</span><br><span class=\"line\">     case KVM_EXIT_HLT: /* ... */</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt\" target=\"_blank\" rel=\"noopener\">KVM ioctl接口文档</a></p>\n<h2 id=\"先来一个KVM-API开胃菜\"><a href=\"#先来一个KVM-API开胃菜\" class=\"headerlink\" title=\"先来一个KVM API开胃菜\"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    mov $0x3f8, %dx</span><br><span class=\"line\">    add %bl, %al</span><br><span class=\"line\">    add $&apos;0&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    mov $&apos;\\n&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    hlt</span><br></pre></td></tr></table></figure>\n<p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as -32 bin.S -o bin.o</span><br><span class=\"line\">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure>\n<p>查看一下二进制格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  demo1 hexdump -C bin.bin</span><br><span class=\"line\">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class=\"line\">0000000c</span><br><span class=\"line\">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;err.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;linux/kvm.h&gt;</span><br><span class=\"line\">#include &lt;stdint.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;</span><br><span class=\"line\">#include &lt;sys/mman.h&gt;</span><br><span class=\"line\">#include &lt;sys/stat.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int kvm, vmfd, vcpufd, ret;</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uint8_t *mem;</span><br><span class=\"line\">    struct kvm_sregs sregs;</span><br><span class=\"line\">    size_t mmap_size;</span><br><span class=\"line\">    struct kvm_run *run;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 kvm 句柄</span><br><span class=\"line\">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class=\"line\">    if (kvm == -1)</span><br><span class=\"line\">        err(1, &quot;/dev/kvm&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 确保是正确的 API 版本</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class=\"line\">    if (ret != 12)</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一虚拟机</span><br><span class=\"line\">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class=\"line\">    if (vmfd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class=\"line\">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class=\"line\">    if (!mem)</span><br><span class=\"line\">        err(1, &quot;allocating guest memory&quot;);</span><br><span class=\"line\">    memcpy(mem, code, sizeof(code));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class=\"line\">    struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">        .slot = 0,</span><br><span class=\"line\">        .guest_phys_addr = 0x1000,</span><br><span class=\"line\">        .memory_size = 0x1000,</span><br><span class=\"line\">        .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 设置 KVM 的内存区域</span><br><span class=\"line\">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建虚拟CPU</span><br><span class=\"line\">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class=\"line\">    if (vcpufd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 KVM 运行时结构的大小</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class=\"line\">    mmap_size = ret;</span><br><span class=\"line\">    if (mmap_size &lt; sizeof(*run))</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class=\"line\">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息</span><br><span class=\"line\">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class=\"line\">    if (!run)</span><br><span class=\"line\">        err(1, &quot;mmap vcpu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class=\"line\">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class=\"line\">    sregs.cs.base = 0;</span><br><span class=\"line\">    sregs.cs.selector = 0;</span><br><span class=\"line\">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class=\"line\">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class=\"line\">    struct kvm_regs regs = &#123;</span><br><span class=\"line\">        .rip = 0x1000,</span><br><span class=\"line\">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class=\"line\">        .rbx = 2,    // 同理</span><br><span class=\"line\">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        // 开始运行虚拟机</span><br><span class=\"line\">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">            err(1, &quot;KVM_RUN&quot;);</span><br><span class=\"line\">        // 获取虚拟机退出原因</span><br><span class=\"line\">        switch (run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_HLT:</span><br><span class=\"line\">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class=\"line\">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class=\"line\">        // 后面CPU虚拟化会讲到这部分</span><br><span class=\"line\">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class=\"line\">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class=\"line\">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class=\"line\">            else</span><br><span class=\"line\">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class=\"line\">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class=\"line\">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译并运行这个demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g demo.c -o demo</span><br><span class=\"line\">➜  demo1 ./demo</span><br><span class=\"line\">4</span><br><span class=\"line\">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>\n<h2 id=\"另外一个简单的QEMU-emulator-demo\"><a href=\"#另外一个简单的QEMU-emulator-demo\" class=\"headerlink\" title=\"另外一个简单的QEMU emulator demo\"></a>另外一个简单的QEMU emulator demo</h2><p><a href=\"http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/\" target=\"_blank\" rel=\"noopener\">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class=\"line\"></span><br><span class=\"line\">loop1:</span><br><span class=\"line\">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class=\"line\">    inc %ax         # ax 值加一</span><br><span class=\"line\">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure>\n<p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p>\n<p>从main函数开始说起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char **argv) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 初始化kvm结构体</span><br><span class=\"line\">    struct kvm *kvm = kvm_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm == NULL) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;kvm init fauilt\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建VM，并分配内存空间</span><br><span class=\"line\">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;create vm fault\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加载镜像</span><br><span class=\"line\">    load_binary(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    // only support one vcpu now</span><br><span class=\"line\">    kvm-&gt;vcpu_number = 1;</span><br><span class=\"line\">    // 创建执行现场</span><br><span class=\"line\">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动虚拟机</span><br><span class=\"line\">    kvm_run_vm(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm_clean_vm(kvm);</span><br><span class=\"line\">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\">    kvm_clean(kvm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm &#123;</span><br><span class=\"line\">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class=\"line\">   int vm_fd;               // GUEST 的句柄</span><br><span class=\"line\">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class=\"line\">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class=\"line\">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class=\"line\"></span><br><span class=\"line\">   int kvm_version;         </span><br><span class=\"line\">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class=\"line\">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class=\"line\"></span><br><span class=\"line\">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class=\"line\">   int vcpu_number;         // vcpu 个数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>初始化 kvm 结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm *kvm_init(void) &#123;</span><br><span class=\"line\">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class=\"line\">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;open kvm device fault: &quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class=\"line\"></span><br><span class=\"line\">    return kvm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class=\"line\">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vm&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 kvm 分配内存。通过系统调用.</span><br><span class=\"line\">    kvm-&gt;ram_size = ram_size;</span><br><span class=\"line\">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class=\"line\">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class=\"line\">                -1, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap ram&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class=\"line\">    // 只有一个内存槽</span><br><span class=\"line\">    kvm-&gt;mem.slot = 0;</span><br><span class=\"line\">    // guest 物理内存起始地址</span><br><span class=\"line\">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class=\"line\">    // 虚拟机内存大小</span><br><span class=\"line\">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class=\"line\">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class=\"line\">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class=\"line\">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ret &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set user memory region&quot;);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_binary(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fd &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;can not open binary file\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class=\"line\">        if (ret &lt;= 0) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printf(&quot;read size: %d&quot;, ret);</span><br><span class=\"line\">        p += ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct vcpu &#123;</span><br><span class=\"line\">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class=\"line\">    int vcpu_fd;                 // vCPU 句柄</span><br><span class=\"line\">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class=\"line\">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class=\"line\">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class=\"line\">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class=\"line\">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class=\"line\">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class=\"line\">    // 申请vcpu结构</span><br><span class=\"line\">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class=\"line\">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class=\"line\">    vcpu-&gt;vcpu_id = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class=\"line\">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vcpu&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取KVM运行时结构大小</span><br><span class=\"line\">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class=\"line\">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class=\"line\">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class=\"line\">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置线程执行函数</span><br><span class=\"line\">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class=\"line\">    return vcpu;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一步，以上工作就绪后，启动虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class=\"line\">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class=\"line\">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class=\"line\">            perror(&quot;can not create kvm thread&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *kvm_cpu_thread(void *data) &#123;</span><br><span class=\"line\">    // 获取参数</span><br><span class=\"line\">    struct kvm *kvm = (struct kvm *)data;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 设置KVM的参数</span><br><span class=\"line\">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        printf(&quot;KVM start run\\n&quot;);</span><br><span class=\"line\">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class=\"line\">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (ret &lt; 0) &#123;</span><br><span class=\"line\">            fprintf(stderr, &quot;KVM_RUN failed\\n&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class=\"line\">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class=\"line\">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_UNKNOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_UNKNOWN\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_DEBUG:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_DEBUG\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class=\"line\">        // 把执行权交给emulator</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_IO\\n&quot;);</span><br><span class=\"line\">            printf(&quot;out port: %d, data: %d\\n&quot;, </span><br><span class=\"line\">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class=\"line\">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class=\"line\">                );</span><br><span class=\"line\">            sleep(1);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了memory map IO操作</span><br><span class=\"line\">        case KVM_EXIT_MMIO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_MMIO\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_INTR:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_INTR\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_SHUTDOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_SHUTDOWN\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            printf(&quot;KVM PANIC\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_kvm:</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get sregs\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // #define CODE_START 0x1000</span><br><span class=\"line\">    /* sregs 结构体</span><br><span class=\"line\">        x86</span><br><span class=\"line\">        struct kvm_sregs &#123;</span><br><span class=\"line\">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class=\"line\">            struct kvm_segment tr, ldt;</span><br><span class=\"line\">            struct kvm_dtable gdt, idt;</span><br><span class=\"line\">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class=\"line\">            __u64 efer;</span><br><span class=\"line\">            __u64 apic_base;</span><br><span class=\"line\">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class=\"line\">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class=\"line\">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class=\"line\">    // es 为附加段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class=\"line\">    // fs, gs 同样为段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class=\"line\">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为vCPU设置以上寄存器的值</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set sregs&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置寄存器标志位</span><br><span class=\"line\">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class=\"line\">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class=\"line\">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class=\"line\">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class=\"line\">    vcpu-&gt;regs.rip = 0;</span><br><span class=\"line\">    // rsp 为堆栈顶</span><br><span class=\"line\">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class=\"line\">    // rbp 为堆栈底部</span><br><span class=\"line\">    vcpu-&gt;regs.rbp= 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;KVM SET REGS\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class=\"line\">read size: 712288</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 0</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 1</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 2</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 3</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p>\n<p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p>\n"},{"title":"KVM 虚拟化原理3--CPU","donate":true,"date":"2018-12-10T15:16:24.000Z","_content":"## CPU 虚拟化简介\n\n上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。\n\n用一张图来解释更为贴切。\n\n![](vcpu-follow.png)\n\nVMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。\n\n## Intel-V 技术\n\nIntel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。\n\n### Intel-V虚拟化技术结构\n\nIntel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。  \n比如说一个IO操作：\n\n```hljs\nint nread = read(fd, buffer, 1024);\n```\n\n当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。\n\n```hljs\nmovel　　$3,%eax\nmovel　　fd,%ebx\nmovel　　buffer,%ecx\nmovel　　1024,%edx　　　　　　\nint　　  $0x80\n```\n\nIntel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。\n\n![](vcpu-ring.png)\n\nIntel的虚拟架构基本上分两个部分:\n\n* 虚拟机监视器\n* 客户机（Guest VM)\n\n#### 虚拟机监视器（Virtual-machine monitors - VMM)\n\n虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。\n\n#### Guest\n\n这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。  \nGuest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。\n\n#### VMM 与 Guest 的切换\n\n![](vmm_guest_switch.png)\n\nGuest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU->kvm_run->exit_reason。VMM根据exit_reason做相应的处理。\n\n#### VMM 的生命周期\n\n如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。  \n第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。\n\n#### VMCS （Virtual-Machine control structure)\n\n顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。\n\n#### Guest exit Reason\n\n下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。\n\n```hljs\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, \n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, \n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,\n     // 访问了IO设备\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr, \n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    // 访问了MSR寄存器\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    // Guest执行了HLT指令，Demo开胃菜就是这个指令\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]                    = handle_invd,\n    [EXIT_REASON_INVLPG]                  = handle_invlpg,\n    [EXIT_REASON_RDPMC]                   = handle_rdpmc,\n    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）\n    [EXIT_REASON_VMCALL]                  = handle_vmcall, \n    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n    [EXIT_REASON_VMREAD]                  = handle_vmread,\n    [EXIT_REASON_VMRESUME]                = handle_vmresume,\n    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n    [EXIT_REASON_VMOFF]                   = handle_vmoff,\n    [EXIT_REASON_VMON]                    = handle_vmon,\n\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    // 访问了高级PCI设备\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    // 进程切换\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    // ept 是Intel的一个硬件内存虚拟化技术\n    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    // 执行了暂停指令\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n    [EXIT_REASON_INVEPT]                  = handle_invept,\n};\n```\n\n## 总结\n\nKVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。  \nCPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。\n","source":"_posts/kvm-cpu.md","raw":"---\ntitle: KVM 虚拟化原理3--CPU\ndonate: true\ndate: 2018-12-10 23:16:24\ncategories:\ntags:\n---\n## CPU 虚拟化简介\n\n上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。\n\n用一张图来解释更为贴切。\n\n![](vcpu-follow.png)\n\nVMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。\n\n## Intel-V 技术\n\nIntel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。\n\n### Intel-V虚拟化技术结构\n\nIntel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。  \n比如说一个IO操作：\n\n```hljs\nint nread = read(fd, buffer, 1024);\n```\n\n当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。\n\n```hljs\nmovel　　$3,%eax\nmovel　　fd,%ebx\nmovel　　buffer,%ecx\nmovel　　1024,%edx　　　　　　\nint　　  $0x80\n```\n\nIntel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。\n\n![](vcpu-ring.png)\n\nIntel的虚拟架构基本上分两个部分:\n\n* 虚拟机监视器\n* 客户机（Guest VM)\n\n#### 虚拟机监视器（Virtual-machine monitors - VMM)\n\n虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。\n\n#### Guest\n\n这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。  \nGuest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。\n\n#### VMM 与 Guest 的切换\n\n![](vmm_guest_switch.png)\n\nGuest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU->kvm_run->exit_reason。VMM根据exit_reason做相应的处理。\n\n#### VMM 的生命周期\n\n如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。  \n第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。\n\n#### VMCS （Virtual-Machine control structure)\n\n顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。\n\n#### Guest exit Reason\n\n下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。\n\n```hljs\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, \n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, \n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,\n     // 访问了IO设备\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr, \n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    // 访问了MSR寄存器\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    // Guest执行了HLT指令，Demo开胃菜就是这个指令\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]                    = handle_invd,\n    [EXIT_REASON_INVLPG]                  = handle_invlpg,\n    [EXIT_REASON_RDPMC]                   = handle_rdpmc,\n    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）\n    [EXIT_REASON_VMCALL]                  = handle_vmcall, \n    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n    [EXIT_REASON_VMREAD]                  = handle_vmread,\n    [EXIT_REASON_VMRESUME]                = handle_vmresume,\n    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n    [EXIT_REASON_VMOFF]                   = handle_vmoff,\n    [EXIT_REASON_VMON]                    = handle_vmon,\n\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    // 访问了高级PCI设备\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    // 进程切换\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    // ept 是Intel的一个硬件内存虚拟化技术\n    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    // 执行了暂停指令\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n    [EXIT_REASON_INVEPT]                  = handle_invept,\n};\n```\n\n## 总结\n\nKVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。  \nCPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。\n","slug":"kvm-cpu","published":1,"updated":"2018-12-10T15:26:15.033Z","_id":"cjpigmd2c0001c2o4lwjrap0a","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CPU-虚拟化简介\"><a href=\"#CPU-虚拟化简介\" class=\"headerlink\" title=\"CPU 虚拟化简介\"></a>CPU 虚拟化简介</h2><p>上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。</p>\n<p>用一张图来解释更为贴切。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-follow.png\" alt=\"\"></p>\n<p>VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。</p>\n<h2 id=\"Intel-V-技术\"><a href=\"#Intel-V-技术\" class=\"headerlink\" title=\"Intel-V 技术\"></a>Intel-V 技术</h2><p>Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。</p>\n<h3 id=\"Intel-V虚拟化技术结构\"><a href=\"#Intel-V虚拟化技术结构\" class=\"headerlink\" title=\"Intel-V虚拟化技术结构\"></a>Intel-V虚拟化技术结构</h3><p>Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。<br>比如说一个IO操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int nread = read(fd, buffer, 1024);</span><br></pre></td></tr></table></figure>\n<p>当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movel　　$3,%eax</span><br><span class=\"line\">movel　　fd,%ebx</span><br><span class=\"line\">movel　　buffer,%ecx</span><br><span class=\"line\">movel　　1024,%edx　　　　　　</span><br><span class=\"line\">int　　  $0x80</span><br></pre></td></tr></table></figure>\n<p>Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-ring.png\" alt=\"\"></p>\n<p>Intel的虚拟架构基本上分两个部分:</p>\n<ul>\n<li>虚拟机监视器</li>\n<li>客户机（Guest VM)</li>\n</ul>\n<h4 id=\"虚拟机监视器（Virtual-machine-monitors-VMM\"><a href=\"#虚拟机监视器（Virtual-machine-monitors-VMM\" class=\"headerlink\" title=\"虚拟机监视器（Virtual-machine monitors - VMM)\"></a>虚拟机监视器（Virtual-machine monitors - VMM)</h4><p>虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。</p>\n<h4 id=\"Guest\"><a href=\"#Guest\" class=\"headerlink\" title=\"Guest\"></a>Guest</h4><p>这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。<br>Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。</p>\n<h4 id=\"VMM-与-Guest-的切换\"><a href=\"#VMM-与-Guest-的切换\" class=\"headerlink\" title=\"VMM 与 Guest 的切换\"></a>VMM 与 Guest 的切换</h4><p><img src=\"/2018/12/10/kvm-cpu/vmm_guest_switch.png\" alt=\"\"></p>\n<p>Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。</p>\n<h4 id=\"VMM-的生命周期\"><a href=\"#VMM-的生命周期\" class=\"headerlink\" title=\"VMM 的生命周期\"></a>VMM 的生命周期</h4><p>如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。<br>第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。</p>\n<h4 id=\"VMCS-（Virtual-Machine-control-structure\"><a href=\"#VMCS-（Virtual-Machine-control-structure\" class=\"headerlink\" title=\"VMCS （Virtual-Machine control structure)\"></a>VMCS （Virtual-Machine control structure)</h4><p>顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。</p>\n<h4 id=\"Guest-exit-Reason\"><a href=\"#Guest-exit-Reason\" class=\"headerlink\" title=\"Guest exit Reason\"></a>Guest exit Reason</h4><p>下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123;</span><br><span class=\"line\">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, </span><br><span class=\"line\">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, </span><br><span class=\"line\">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,</span><br><span class=\"line\">     // 访问了IO设备</span><br><span class=\"line\">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试</span><br><span class=\"line\">    [EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">    [EXIT_REASON_DR_ACCESS]               = handle_dr, </span><br><span class=\"line\">    [EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">    // 访问了MSR寄存器</span><br><span class=\"line\">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">    // Guest执行了HLT指令，Demo开胃菜就是这个指令</span><br><span class=\"line\">    [EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">    [EXIT_REASON_INVD]                    = handle_invd,</span><br><span class=\"line\">    [EXIT_REASON_INVLPG]                  = handle_invlpg,</span><br><span class=\"line\">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）</span><br><span class=\"line\">    [EXIT_REASON_VMCALL]                  = handle_vmcall, </span><br><span class=\"line\">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,</span><br><span class=\"line\">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">    [EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">    [EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">    [EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">    [EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\"></span><br><span class=\"line\">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">    // 访问了高级PCI设备</span><br><span class=\"line\">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">    // 进程切换</span><br><span class=\"line\">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">    // ept 是Intel的一个硬件内存虚拟化技术</span><br><span class=\"line\">    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,</span><br><span class=\"line\">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">    // 执行了暂停指令</span><br><span class=\"line\">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。<br>CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CPU-虚拟化简介\"><a href=\"#CPU-虚拟化简介\" class=\"headerlink\" title=\"CPU 虚拟化简介\"></a>CPU 虚拟化简介</h2><p>上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。</p>\n<p>用一张图来解释更为贴切。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-follow.png\" alt=\"\"></p>\n<p>VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。</p>\n<h2 id=\"Intel-V-技术\"><a href=\"#Intel-V-技术\" class=\"headerlink\" title=\"Intel-V 技术\"></a>Intel-V 技术</h2><p>Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。</p>\n<h3 id=\"Intel-V虚拟化技术结构\"><a href=\"#Intel-V虚拟化技术结构\" class=\"headerlink\" title=\"Intel-V虚拟化技术结构\"></a>Intel-V虚拟化技术结构</h3><p>Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。<br>比如说一个IO操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int nread = read(fd, buffer, 1024);</span><br></pre></td></tr></table></figure>\n<p>当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movel　　$3,%eax</span><br><span class=\"line\">movel　　fd,%ebx</span><br><span class=\"line\">movel　　buffer,%ecx</span><br><span class=\"line\">movel　　1024,%edx　　　　　　</span><br><span class=\"line\">int　　  $0x80</span><br></pre></td></tr></table></figure>\n<p>Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-ring.png\" alt=\"\"></p>\n<p>Intel的虚拟架构基本上分两个部分:</p>\n<ul>\n<li>虚拟机监视器</li>\n<li>客户机（Guest VM)</li>\n</ul>\n<h4 id=\"虚拟机监视器（Virtual-machine-monitors-VMM\"><a href=\"#虚拟机监视器（Virtual-machine-monitors-VMM\" class=\"headerlink\" title=\"虚拟机监视器（Virtual-machine monitors - VMM)\"></a>虚拟机监视器（Virtual-machine monitors - VMM)</h4><p>虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。</p>\n<h4 id=\"Guest\"><a href=\"#Guest\" class=\"headerlink\" title=\"Guest\"></a>Guest</h4><p>这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。<br>Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。</p>\n<h4 id=\"VMM-与-Guest-的切换\"><a href=\"#VMM-与-Guest-的切换\" class=\"headerlink\" title=\"VMM 与 Guest 的切换\"></a>VMM 与 Guest 的切换</h4><p><img src=\"/2018/12/10/kvm-cpu/vmm_guest_switch.png\" alt=\"\"></p>\n<p>Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。</p>\n<h4 id=\"VMM-的生命周期\"><a href=\"#VMM-的生命周期\" class=\"headerlink\" title=\"VMM 的生命周期\"></a>VMM 的生命周期</h4><p>如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。<br>第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。</p>\n<h4 id=\"VMCS-（Virtual-Machine-control-structure\"><a href=\"#VMCS-（Virtual-Machine-control-structure\" class=\"headerlink\" title=\"VMCS （Virtual-Machine control structure)\"></a>VMCS （Virtual-Machine control structure)</h4><p>顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。</p>\n<h4 id=\"Guest-exit-Reason\"><a href=\"#Guest-exit-Reason\" class=\"headerlink\" title=\"Guest exit Reason\"></a>Guest exit Reason</h4><p>下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123;</span><br><span class=\"line\">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, </span><br><span class=\"line\">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, </span><br><span class=\"line\">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,</span><br><span class=\"line\">     // 访问了IO设备</span><br><span class=\"line\">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试</span><br><span class=\"line\">    [EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">    [EXIT_REASON_DR_ACCESS]               = handle_dr, </span><br><span class=\"line\">    [EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">    // 访问了MSR寄存器</span><br><span class=\"line\">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">    // Guest执行了HLT指令，Demo开胃菜就是这个指令</span><br><span class=\"line\">    [EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">    [EXIT_REASON_INVD]                    = handle_invd,</span><br><span class=\"line\">    [EXIT_REASON_INVLPG]                  = handle_invlpg,</span><br><span class=\"line\">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）</span><br><span class=\"line\">    [EXIT_REASON_VMCALL]                  = handle_vmcall, </span><br><span class=\"line\">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,</span><br><span class=\"line\">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">    [EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">    [EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">    [EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">    [EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\"></span><br><span class=\"line\">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">    // 访问了高级PCI设备</span><br><span class=\"line\">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">    // 进程切换</span><br><span class=\"line\">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">    // ept 是Intel的一个硬件内存虚拟化技术</span><br><span class=\"line\">    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,</span><br><span class=\"line\">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">    // 执行了暂停指令</span><br><span class=\"line\">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。<br>CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。</p>\n"},{"title":"KVM 虚拟化原理4--内存","donate":true,"date":"2018-12-10T15:28:02.000Z","_content":"\n## 内存虚拟化简介\n\n前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。\n\n## 传统的地址转换\n\n在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。  \n通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。  \n首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。\n\n```hljs\n逻辑地址 ==> 线性地址 ==> 物理地址\n```\n\n逻辑地址和线性地址之间通过简单的偏移来完成。  \n![](logical_address.png)\n\n一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。\n\n为什么要这么做？据说是Intel为了保证兼容性。\n\n逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。\n\n传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。  \n页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。\n\n![](page.png)\n\n## KVM中的内存结构\n\n由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n    Guest线性地址 \n          |\n   Guest物理地址(GPA)\n          |             Guest\n   ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n      HV线性地址\n          |\n    HV物理地址(HPA)\n```\n\nWhat's the fu*k ？这么多...  \n别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n   Guest物理地址(GPA)\n          |             Guest\n  ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n    HV物理地址(HPA)\n```\n\n前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。\n\n## 软件虚拟化方式实现\n\n第一层转换，由GVA->GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在[第二章KVM启动过程](http://www.cnblogs.com/Bozh/p/5753379.html)的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。\n\n![](gpa_hpa.png)\n\n```hljs\nstruct kvm_userspace_memory_region region = {\n    .slot = 0,\n    .guest_phys_addr = 0x1000,\n    .memory_size = 0x1000,\n    .userspace_addr = (uint64_t)mem,\n};\n```\n\n可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射`userspace_addr`，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。\n\n![](gpa_hpa2.png)\n\n软件模拟的虚拟化方式由qemu-kvm来负责维护GPA->HVA的转换，然后再经过一次HVA->HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。\n\n## 影子页表的虚拟化方式\n\n影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。  \n在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，[CPU虚拟化章节](http://www.cnblogs.com/Bozh/p/5757274.html) EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。\n\n![](gpa_hpa3_shadow.png)\n\n影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA->HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA->PA)，然后影子页表记录GVA->GPA->HVA->HPA。这样产生GVA->GPA的直接关系，保存到影子页表中。\n\n![](gpa_hpa4.png)\n\n影子页表的引入，减少了GVA->HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。\n\n## EPT硬件加速的虚拟化方式\n\n![](gpa_hpa5_ept.png)\nEPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA->HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA->HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。  \n在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。\n\n## 总结\n\nKVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。  \nKVM经过软件模拟->影子页表->EPT的技术的进化，效率也越来越高。\n","source":"_posts/kvm-memory.md","raw":"---\ntitle: KVM 虚拟化原理4--内存\ndonate: true\ndate: 2018-12-10 23:28:02\ncategories:\ntags:\n---\n\n## 内存虚拟化简介\n\n前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。\n\n## 传统的地址转换\n\n在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。  \n通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。  \n首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。\n\n```hljs\n逻辑地址 ==> 线性地址 ==> 物理地址\n```\n\n逻辑地址和线性地址之间通过简单的偏移来完成。  \n![](logical_address.png)\n\n一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。\n\n为什么要这么做？据说是Intel为了保证兼容性。\n\n逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。\n\n传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。  \n页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。\n\n![](page.png)\n\n## KVM中的内存结构\n\n由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n    Guest线性地址 \n          |\n   Guest物理地址(GPA)\n          |             Guest\n   ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n      HV线性地址\n          |\n    HV物理地址(HPA)\n```\n\nWhat's the fu*k ？这么多...  \n别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n   Guest物理地址(GPA)\n          |             Guest\n  ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n    HV物理地址(HPA)\n```\n\n前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。\n\n## 软件虚拟化方式实现\n\n第一层转换，由GVA->GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在[第二章KVM启动过程](http://www.cnblogs.com/Bozh/p/5753379.html)的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。\n\n![](gpa_hpa.png)\n\n```hljs\nstruct kvm_userspace_memory_region region = {\n    .slot = 0,\n    .guest_phys_addr = 0x1000,\n    .memory_size = 0x1000,\n    .userspace_addr = (uint64_t)mem,\n};\n```\n\n可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射`userspace_addr`，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。\n\n![](gpa_hpa2.png)\n\n软件模拟的虚拟化方式由qemu-kvm来负责维护GPA->HVA的转换，然后再经过一次HVA->HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。\n\n## 影子页表的虚拟化方式\n\n影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。  \n在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，[CPU虚拟化章节](http://www.cnblogs.com/Bozh/p/5757274.html) EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。\n\n![](gpa_hpa3_shadow.png)\n\n影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA->HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA->PA)，然后影子页表记录GVA->GPA->HVA->HPA。这样产生GVA->GPA的直接关系，保存到影子页表中。\n\n![](gpa_hpa4.png)\n\n影子页表的引入，减少了GVA->HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。\n\n## EPT硬件加速的虚拟化方式\n\n![](gpa_hpa5_ept.png)\nEPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA->HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA->HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。  \n在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。\n\n## 总结\n\nKVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。  \nKVM经过软件模拟->影子页表->EPT的技术的进化，效率也越来越高。\n","slug":"kvm-memory","published":1,"updated":"2018-12-10T15:42:56.429Z","_id":"cjpih1b9h0002c2o4wd3thgha","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"内存虚拟化简介\"><a href=\"#内存虚拟化简介\" class=\"headerlink\" title=\"内存虚拟化简介\"></a>内存虚拟化简介</h2><p>前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。</p>\n<h2 id=\"传统的地址转换\"><a href=\"#传统的地址转换\" class=\"headerlink\" title=\"传统的地址转换\"></a>传统的地址转换</h2><p>在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。<br>通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。<br>首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逻辑地址 ==&gt; 线性地址 ==&gt; 物理地址</span><br></pre></td></tr></table></figure>\n<p>逻辑地址和线性地址之间通过简单的偏移来完成。<br><img src=\"/2018/12/10/kvm-memory/logical_address.png\" alt=\"\"></p>\n<p>一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。</p>\n<p>为什么要这么做？据说是Intel为了保证兼容性。</p>\n<p>逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。</p>\n<p>传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。<br>页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。</p>\n<p><img src=\"/2018/12/10/kvm-memory/page.png\" alt=\"\"></p>\n<h2 id=\"KVM中的内存结构\"><a href=\"#KVM中的内存结构\" class=\"headerlink\" title=\"KVM中的内存结构\"></a>KVM中的内存结构</h2><p>由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    Guest线性地址 </span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">   ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">      HV线性地址</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>What’s the fu*k ？这么多…<br>别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">  ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。</p>\n<h2 id=\"软件虚拟化方式实现\"><a href=\"#软件虚拟化方式实现\" class=\"headerlink\" title=\"软件虚拟化方式实现\"></a>软件虚拟化方式实现</h2><p>第一层转换，由GVA-&gt;GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在<a href=\"http://www.cnblogs.com/Bozh/p/5753379.html\" target=\"_blank\" rel=\"noopener\">第二章KVM启动过程</a>的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">    .slot = 0,</span><br><span class=\"line\">    .guest_phys_addr = 0x1000,</span><br><span class=\"line\">    .memory_size = 0x1000,</span><br><span class=\"line\">    .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射<code>userspace_addr</code>，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa2.png\" alt=\"\"></p>\n<p>软件模拟的虚拟化方式由qemu-kvm来负责维护GPA-&gt;HVA的转换，然后再经过一次HVA-&gt;HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。</p>\n<h2 id=\"影子页表的虚拟化方式\"><a href=\"#影子页表的虚拟化方式\" class=\"headerlink\" title=\"影子页表的虚拟化方式\"></a>影子页表的虚拟化方式</h2><p>影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。<br>在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，<a href=\"http://www.cnblogs.com/Bozh/p/5757274.html\" target=\"_blank\" rel=\"noopener\">CPU虚拟化章节</a> EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa3_shadow.png\" alt=\"\"></p>\n<p>影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA-&gt;HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA-&gt;PA)，然后影子页表记录GVA-&gt;GPA-&gt;HVA-&gt;HPA。这样产生GVA-&gt;GPA的直接关系，保存到影子页表中。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa4.png\" alt=\"\"></p>\n<p>影子页表的引入，减少了GVA-&gt;HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。</p>\n<h2 id=\"EPT硬件加速的虚拟化方式\"><a href=\"#EPT硬件加速的虚拟化方式\" class=\"headerlink\" title=\"EPT硬件加速的虚拟化方式\"></a>EPT硬件加速的虚拟化方式</h2><p><img src=\"/2018/12/10/kvm-memory/gpa_hpa5_ept.png\" alt=\"\"><br>EPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA-&gt;HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA-&gt;HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。<br>在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。<br>KVM经过软件模拟-&gt;影子页表-&gt;EPT的技术的进化，效率也越来越高。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存虚拟化简介\"><a href=\"#内存虚拟化简介\" class=\"headerlink\" title=\"内存虚拟化简介\"></a>内存虚拟化简介</h2><p>前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。</p>\n<h2 id=\"传统的地址转换\"><a href=\"#传统的地址转换\" class=\"headerlink\" title=\"传统的地址转换\"></a>传统的地址转换</h2><p>在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。<br>通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。<br>首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逻辑地址 ==&gt; 线性地址 ==&gt; 物理地址</span><br></pre></td></tr></table></figure>\n<p>逻辑地址和线性地址之间通过简单的偏移来完成。<br><img src=\"/2018/12/10/kvm-memory/logical_address.png\" alt=\"\"></p>\n<p>一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。</p>\n<p>为什么要这么做？据说是Intel为了保证兼容性。</p>\n<p>逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。</p>\n<p>传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。<br>页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。</p>\n<p><img src=\"/2018/12/10/kvm-memory/page.png\" alt=\"\"></p>\n<h2 id=\"KVM中的内存结构\"><a href=\"#KVM中的内存结构\" class=\"headerlink\" title=\"KVM中的内存结构\"></a>KVM中的内存结构</h2><p>由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    Guest线性地址 </span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">   ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">      HV线性地址</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>What’s the fu*k ？这么多…<br>别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">  ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。</p>\n<h2 id=\"软件虚拟化方式实现\"><a href=\"#软件虚拟化方式实现\" class=\"headerlink\" title=\"软件虚拟化方式实现\"></a>软件虚拟化方式实现</h2><p>第一层转换，由GVA-&gt;GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在<a href=\"http://www.cnblogs.com/Bozh/p/5753379.html\" target=\"_blank\" rel=\"noopener\">第二章KVM启动过程</a>的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">    .slot = 0,</span><br><span class=\"line\">    .guest_phys_addr = 0x1000,</span><br><span class=\"line\">    .memory_size = 0x1000,</span><br><span class=\"line\">    .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射<code>userspace_addr</code>，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa2.png\" alt=\"\"></p>\n<p>软件模拟的虚拟化方式由qemu-kvm来负责维护GPA-&gt;HVA的转换，然后再经过一次HVA-&gt;HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。</p>\n<h2 id=\"影子页表的虚拟化方式\"><a href=\"#影子页表的虚拟化方式\" class=\"headerlink\" title=\"影子页表的虚拟化方式\"></a>影子页表的虚拟化方式</h2><p>影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。<br>在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，<a href=\"http://www.cnblogs.com/Bozh/p/5757274.html\" target=\"_blank\" rel=\"noopener\">CPU虚拟化章节</a> EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa3_shadow.png\" alt=\"\"></p>\n<p>影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA-&gt;HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA-&gt;PA)，然后影子页表记录GVA-&gt;GPA-&gt;HVA-&gt;HPA。这样产生GVA-&gt;GPA的直接关系，保存到影子页表中。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa4.png\" alt=\"\"></p>\n<p>影子页表的引入，减少了GVA-&gt;HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。</p>\n<h2 id=\"EPT硬件加速的虚拟化方式\"><a href=\"#EPT硬件加速的虚拟化方式\" class=\"headerlink\" title=\"EPT硬件加速的虚拟化方式\"></a>EPT硬件加速的虚拟化方式</h2><p><img src=\"/2018/12/10/kvm-memory/gpa_hpa5_ept.png\" alt=\"\"><br>EPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA-&gt;HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA-&gt;HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。<br>在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。<br>KVM经过软件模拟-&gt;影子页表-&gt;EPT的技术的进化，效率也越来越高。</p>\n"}],"PostAsset":[{"_id":"source/_posts/kvm-overview/01_brief.png","slug":"01_brief.png","post":"cjpigecwd0004bpo4wtccakqg","modified":0,"renderable":0},{"_id":"source/_posts/kvm-overview/02_kvm_framework.png","slug":"02_kvm_framework.png","post":"cjpigecwd0004bpo4wtccakqg","modified":0,"renderable":0},{"_id":"source/_posts/kvm-cpu/vcpu-follow.png","slug":"vcpu-follow.png","post":"cjpigmd2c0001c2o4lwjrap0a","modified":0,"renderable":0},{"_id":"source/_posts/kvm-cpu/vcpu-ring.png","slug":"vcpu-ring.png","post":"cjpigmd2c0001c2o4lwjrap0a","modified":0,"renderable":0},{"_id":"source/_posts/kvm-cpu/vmm_guest_switch.png","slug":"vmm_guest_switch.png","post":"cjpigmd2c0001c2o4lwjrap0a","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/logical_address.png","slug":"logical_address.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/page.png","slug":"page.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa.png","slug":"gpa_hpa.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa2.png","slug":"gpa_hpa2.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa3_shadow.png","slug":"gpa_hpa3_shadow.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa4.png","slug":"gpa_hpa4.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa5_ept.png","slug":"gpa_hpa5_ept.png","post":"cjpih1b9h0002c2o4wd3thgha","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjpigecwd0004bpo4wtccakqg","category_id":"cjpigecwf0007bpo4obwalb4g","_id":"cjpigecwi000cbpo4c90e5b3w"},{"post_id":"cjpigecwe0006bpo4u6t9cg87","category_id":"cjpigecwh0009bpo4lbsrv9ft","_id":"cjpigecwi000ebpo41m5ds86u"},{"post_id":"cjpigfqzv000hbpo45c840ig4","category_id":"cjpigecwf0007bpo4obwalb4g","_id":"cjpiggsaq0000c2o4tzp1yeru"}],"PostTag":[{"post_id":"cjpigecwd0004bpo4wtccakqg","tag_id":"cjpigecwg0008bpo49p2v8x5w","_id":"cjpigecwi000bbpo40dcfmucu"},{"post_id":"cjpigecwe0006bpo4u6t9cg87","tag_id":"cjpigecwh000abpo4hfhd44bx","_id":"cjpigecwi000fbpo4wt9qd0xh"},{"post_id":"cjpigecwe0006bpo4u6t9cg87","tag_id":"cjpigecwi000dbpo41c6g3wci","_id":"cjpigecwj000gbpo40acr5i9h"}],"Tag":[{"name":"KVM","_id":"cjpigecwg0008bpo49p2v8x5w"},{"name":"QEMU","_id":"cjpigecwh000abpo4hfhd44bx"},{"name":"QMP","_id":"cjpigecwi000dbpo41c6g3wci"}]}}
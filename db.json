{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js_bak","path":"lib/three/three-waves.min.js_bak","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"213c8b0866f9d99a3b78fdd376ec9eadcd763b42","modified":1543211864120},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543198210432},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1543198210432},{"_id":"themes/hexo-theme-next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1543198210432},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543198210432},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543198210432},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1543198210432},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543198210432},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1543198210432},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1543198210432},{"_id":"themes/hexo-theme-next/_config.yml","hash":"d2f92faed8810e495b08d1f914115db77e969767","modified":1543336066265},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1543198210432},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1543198210432},{"_id":"themes/hexo-theme-next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1543198210436},{"_id":"themes/hexo-theme-next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1543198210436},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1543198210436},{"_id":"source/_posts/hello-world.md","hash":"e88db5dbf1609a8411c7f8307859eb967d8fdf49","modified":1543237996228},{"_id":"source/_posts/hexo-next主题.md","hash":"d0b14dbfcc520c5f945a948f52480ae0c6d1d3a7","modified":1543200799808},{"_id":"source/_posts/kvm-boot.md","hash":"8fcf3225cabe09891f52bd1aca8ed96f9118d959","modified":1544495570364},{"_id":"source/_posts/kvm-cpu.md","hash":"2a9d95ea8dab7e782fdc9253b675767e640304b5","modified":1544495426704},{"_id":"source/_posts/kvm-memory.md","hash":"1381e915de14fa7e306ea951cc1b67af5c1f8660","modified":1544495407672},{"_id":"source/_posts/kvm-overview.md","hash":"ccfade8fb710d73cd2064c71f965fe53151a4a8c","modified":1544457482649},{"_id":"source/_posts/kvm-src-1.md","hash":"2b19509b28a95d2d1af603cbd38924aae00490d8","modified":1544495336744},{"_id":"source/_posts/qmp-introduction.md","hash":"e6f95bfcdf6a88e42171de5cb0520d9d3d29aa3e","modified":1544451344125},{"_id":"source/about/index.md","hash":"e5e02ed5a161f10cf2ab5a4d50ade6c2e73f13ce","modified":1543372889397},{"_id":"source/categories/index.md","hash":"dfe874275a566036eb6b54f5358d382ec37538bf","modified":1543311556150},{"_id":"source/tags/index.md","hash":"73e754758d6f78e0d6920a20aa1a0d605ba7c537","modified":1543311582526},{"_id":"themes/hexo-theme-next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1543198210440},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1543198210400},{"_id":"themes/hexo-theme-next/.git/config","hash":"91b6a53b2a7f929b698734717a38d4ac169f0c1f","modified":1543198210400},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/COMMIT_EDITMSG","hash":"82729f05b01f87a211af7d69e046176cdcc7ab3c","modified":1543333401074},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1543198210400},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1543198210432},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1543198210432},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1543198210432},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1543198210440},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1543198210436},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1543198210436},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543198210440},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1543198210436},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543198210476},{"_id":"themes/hexo-theme-next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543198210432},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"themes/hexo-theme-next/.git/index","hash":"3598db9cc34308d07646d915fdefbb4bf7ed5086","modified":1543333373278},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543198210476},{"_id":"source/_posts/.kvm-src-1.md.swp","hash":"48cf217ce51b2152f6cdd29780b769bc5f354947","modified":1544492126104},{"_id":"source/_posts/kvm-cpu/vmm_guest_switch.png","hash":"211beafc6cf39027f8d5d4603f14658a668e9c51","modified":1470814108000},{"_id":"source/_posts/kvm-memory/gpa_hpa2.png","hash":"dced64d97cf2b9ffe18649a44abe3449f2af87da","modified":1471334754000},{"_id":"source/_posts/kvm-memory/gpa_hpa3_shadow.png","hash":"e94f9351b678e66ca82407b6af2640c0de5dec5a","modified":1471335724000},{"_id":"source/_posts/kvm-memory/gpa_hpa4.png","hash":"69d2ca2ad87b8a8ffc4224abcb9cfcb9f05209b4","modified":1471336218000},{"_id":"source/_posts/kvm-memory/logical_address.png","hash":"b6442991e95d16255a2033b1f74d5a44d8efff7a","modified":1471331488000},{"_id":"source/_posts/kvm-memory/gpa_hpa.png","hash":"d427367cd272b4c65dbe629222bf70f476cf7137","modified":1471335474000},{"_id":"source/_posts/kvm-overview/01_brief.png","hash":"687e4d3b8975842568b8692cb9090910df33445f","modified":1470648291000},{"_id":"source/_posts/kvm-src-1/hypervisor-1.png","hash":"ac25ea8a50243dbf82940578fab9a0cd17cc1fd7","modified":1487490004000},{"_id":"source/_posts/kvm-src-1/kvm_process-1.png","hash":"62c4e736cff35431026a35d5817aa5cb44d808f4","modified":1487490001000},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1543198193796},{"_id":"source/_posts/kvm-src-1/kvm_arch_map-1.png","hash":"ce3effcc254c76ec71d6d7c12fbcd5533706b179","modified":1487490004000},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1543198193796},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"7899dfb6b1e8375d06734c944de28ca158867dca","modified":1543333401154},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1543250462395},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"2e898366e8b1581738008a97d28a3c1afaae4e3f","modified":1543207664956},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"8150414f0a87608cae78ba34cb24c7fce4002533","modified":1543214420596},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"9c3d2d7ede7ffd27c791a29db19ab8317665039a","modified":1543221165956},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"afcca4ae19c97826780dd5407ecad0cff7f29e90","modified":1543332776650},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1543198210440},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/alipay.png","hash":"4a8675d1848a77f4ac793c186840bd79600e9111","modified":1543247222251},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"d373a666d28b34e5bef952342860120f96c64d91","modified":1543215417196},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"02ee033f52051d3895703689c2601acac03dc02c","modified":1543215417196},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543198210448},{"_id":"source/_posts/kvm-memory/gpa_hpa5_ept.png","hash":"0b4e906c590a8a680ebe710ec37440b120ca1ef4","modified":1471337979000},{"_id":"source/_posts/kvm-overview/02_kvm_framework.png","hash":"c8890d45a5d37bf3f5ced9fcc6ec5cbf020cb03e","modified":1470648411000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210436},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/images/wechatpay.png","hash":"394c68c9698cccf0d0e290f4468e2cf72bc8df3d","modified":1543247241147},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"0c5c7400b4e2d1a3105f7bd5a583d0c05421a20f","modified":1543234343420},{"_id":"source/_posts/kvm-memory/page.png","hash":"f619079a24e1a1d13ef6c54e01eebe465568d57a","modified":1471332158000},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"a8222a434109f21997ad0e1143a230bbe747181b","modified":1543333401154},{"_id":"themes/hexo-theme-next/.git/objects/22/66940d887bf6631b3ebd1264ac572c34772e46","hash":"207d1151a2b8f1752aeb159583e76122c414ffd0","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/16/9eb2ffc05e35418f585ed0487ba4c53c81c0fc","hash":"bf05272bfcdfdf7106ab0c29217fcddd3ac0c155","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/29/1894f5eba941248cada13c37dd1e7dd7e3a4cf","hash":"cc17c71a3a44cfe7e0332ab179caceec99aa7c2e","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/2b/d3fc90fe5ded62417df9fd9ddd5b08c325c730","hash":"25b075de2c6836f147fc8d511e2ebb8a8f9cac1b","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/37/90f333a12cefd3603ca79dcb78d20b7a810cac","hash":"792a0ee8f1f45ba3e4696f713a9f6e51d7356e01","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/42/9b7aa202fdeec5b4ae60a250f8c294c2b37161","hash":"e6faba39cbfe676b4d1683864777d526f8f16834","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/4d/ff25b6103052fe7e6fb4bc05e96318c2702c60","hash":"9338ff871c8e62ca0b8a4f8147b7ff5147eaf361","modified":1543213422496},{"_id":"themes/hexo-theme-next/.git/objects/50/9a5a91aea147f43be646b147b7aa56b29952bf","hash":"3cd7d3c34ac06c079fdf4877d3efd65664e3a91f","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/5f/0f701a148ccea42bb90bb1fe6aa8da0ee82ed5","hash":"95b29a7f4946bcb7c188e2e545758e6a55238dca","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/3c/f3acf314c7973644712dcd78cc58756a2993c8","hash":"52dd0ae9c1e2440f3855ef53ba7e61e9ceb913d6","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/62/4905967631578ddd59926ac54bb0f1e563e5d5","hash":"ffa36487638400ed4af9bd805b91a0d90490521a","modified":1543214775404},{"_id":"themes/hexo-theme-next/.git/objects/60/402a030ead238a99d8ca318ab562e8b83d7b25","hash":"7b54a97b25bdab0da95190d3f84087ce5679f710","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/63/34bf60cd1176d515d2d68f6d4bad95c7bccbf7","hash":"f8317764623f8de89c9dc4506772b6be275fc695","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/69/5688e4bc12d5ab3eeed7aaf6088351562b7525","hash":"90dc4d64f22a95d19d2c2c111b657f5b35c766ec","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/6e/408fd5cef62b104460275644736facbd6415ca","hash":"b08f34b69701f68d8b7fc46499c81cfab7a936e5","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/78/5c0785dba3931fbb1df61a0df6cde1efe62866","hash":"33b0e20870eeb7edc847609df9d5dc00a4acd203","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/78/e81028366ed7a8460923a4f562daabe8345516","hash":"07d6b10a788a79919e5459bc813687aa481cac04","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/7a/7f5068f043e9be057658f65480031866332001","hash":"af24bffad1bc367a151cdb8d85a98ff9ca21554e","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/82/4452372d95e7755f2384a575dd1ef91c5a7d0a","hash":"b5e09bb736530149d158736bacc065a21b82dcc4","modified":1543297989406},{"_id":"themes/hexo-theme-next/.git/objects/81/df3d0c80e7dd8ecb70f85087c5fb6e15dd2c24","hash":"97fdcd66bc4129e948036762b79a3aef9da749e2","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/86/df50c4e45e3182060968b16a28ae586614e5c7","hash":"316eea2421d3991ea1a65da4fdad2a7ffb8f27ba","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/89/29fad11e9bda2af8598efc8e217e925d6a4048","hash":"4c4f30df5eaa2468d1de8ea2c7513ba6ba56418d","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/90/c0e343f09e51639defc139565f93a61bbcc1bd","hash":"afbf069e6511faf8cb8fd23080c20d2b3f6c7fe5","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/99/92abe1e23367d3fb07f4c6f21574101d063228","hash":"47c4624c0074e8be159c7782348d3f469bdfd9d8","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/9d/41ca9b9b9a8da848a151336f022e2d473d88ac","hash":"febf97bc82d4e16bf9e058a82aa7cc6f1106c48b","modified":1543214785736},{"_id":"themes/hexo-theme-next/.git/objects/a0/b38932cd483608a2f63360949dd0972d7eb7b1","hash":"675e36ce4676a9b54d4878452538373555e1e3bf","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/a7/9331076af22ec66070d83d30f25087acf3d237","hash":"2de7a9d6fbfe649da56439b9e0d9e9459890506f","modified":1543333401154},{"_id":"themes/hexo-theme-next/.git/objects/b1/ec1e651ae883d36e33f8eacf1696d4edef918d","hash":"0c2d52941828d7bd6f0845ed61cbd11d2416553e","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/b2/d2b09f1701f19c58964e55c433ac6be68d91ab","hash":"a74229eaf1047a37b41748f4be37336333abc54e","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/b4/64f6dafab7a41c078014c5d9cc9ab81fac6777","hash":"4dcaadb6c50730a73759b48121de6fe06a8f5603","modified":1543213407988},{"_id":"themes/hexo-theme-next/.git/objects/b9/803934a40f25bfcecd104208511e0fee2e8f0d","hash":"15a8b7fdff7200002cf72e421cc26255a284a94d","modified":1543214785740},{"_id":"themes/hexo-theme-next/.git/objects/bb/eba543f8b15d21c13b248a735d5f5a30560e47","hash":"a2f7da0f8cac0360183a1ab5a86adf3049e793e6","modified":1543250843839},{"_id":"themes/hexo-theme-next/.git/objects/bd/3fe93bdceb73ab30480553cd465eedeb3f4c11","hash":"d1f6a486a29fc3c810af3ef1b581da3c77ed961a","modified":1543250843843},{"_id":"themes/hexo-theme-next/.git/objects/cb/2074bc6441f6c1c5544423450119535dbf1f97","hash":"8f04a1088bcca56f8e9d205907a63f59d07fb269","modified":1543213407992},{"_id":"themes/hexo-theme-next/.git/objects/ce/788c95c0a4dcad866336e2d5e75b9f0b523a9d","hash":"842c27c6fe8420adc5f4eb6b3fb3cd0893c15569","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/ce/7c13317179a91572e7c811b8d957aac6e65213","hash":"f2be785a11d28573284bd19834718a56f4d92ac2","modified":1543333368270},{"_id":"themes/hexo-theme-next/.git/objects/db/dafe0f54bd0dbb1af9898297405916bbf057b8","hash":"60ab3468707e46f709f035338c5e86fde5e9c254","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/e0/eb5c634230d03e1b6585993cf66e92c20f88f3","hash":"e64f6fe1d001eb90367b9afd213d5b671658721a","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/e2/5db23791e767351856c760ab4ef7321e12be93","hash":"8b78f13a8c78413f266530a2361647a9199a8b24","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/e4/53c05ef037b992278f898d5c9b76128235f8cd","hash":"fe57ca5be56ac6ffc6907624f772e7a2d6738f34","modified":1543214785736},{"_id":"themes/hexo-theme-next/.git/objects/e5/2211f4c3f4a0c5c1c951fe6f3be0a701621244","hash":"b29a12dce7b0df391d660db19bf3959024f408a0","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/eb/f65a2b528d8fef462630bfba89eb9c0ee07cda","hash":"3926268976f8f4ca9470bfa8283bd06e394ea881","modified":1543333373274},{"_id":"themes/hexo-theme-next/.git/objects/f1/8ffc0da06b9982954f6b762cacbb5230da2ec5","hash":"179e837adca396486d5df6c25502153a78de42bc","modified":1543214800652},{"_id":"themes/hexo-theme-next/.git/objects/f3/e18667444d17e2fdcd2787d7166f5e44b1e0aa","hash":"c3d64b98defa1154bba3db288049f08bca8b5113","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/f6/ed20eb3a091b588e97c1051b438bbc39c6b690","hash":"7b46f8ebe2b667dd273752bfdf68faf40946a7bb","modified":1543297991614},{"_id":"themes/hexo-theme-next/.git/objects/f8/53efa1038e1371714ff00bcfa76e36487fa528","hash":"b7c7f365e05ef9200b34a2426bc46df4debc0983","modified":1543213404692},{"_id":"themes/hexo-theme-next/.git/objects/ff/6ab5b0ef6de998a784b473bdd558ffd429ad3d","hash":"3a06eb7ef7ea76317bb116bdca0d0ae5bd57925f","modified":1543297991614},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1543198210436},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"4aa55cd424389cf5626aa019c15ef6f3e4da09f2","modified":1543213032024},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1543301721166},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"c01ae2e4235083b6730f9e4a72752bd27376460f","modified":1543236451792},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1543327167994},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1543198210460},{"_id":"source/_posts/kvm-cpu/vcpu-follow.png","hash":"42405e69514a7b136ce6bcaa83c3b04da9c11ed1","modified":1470800509000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"48e5996d879f2e447cc2c644b15b3b93da938e37","modified":1543333318138},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js_bak","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1543331018646},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543198210476},{"_id":"source/_posts/kvm-cpu/vcpu-ring.png","hash":"bebcc569ba07e6b2a362f45df5843a8b114893ad","modified":1470813442000},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543198210472},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"7899dfb6b1e8375d06734c944de28ca158867dca","modified":1543333401154},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1543198210400},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1543198210440},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1543198210444},{"_id":"themes/hexo-theme-next/.git/objects/67/eb67dacdd7f138338aa7d23f13acba6bcdc9a3","hash":"a3decff22ead4b5aeab5a0fb27186b0415b8846f","modified":1543250843843},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543198210460},{"_id":"themes/hexo-theme-next/.git/objects/10/a3e6d45fb6887e8dcaa92d1d758574060025b9","hash":"e50c788f6609ea88fdcdb9c2cae2e29083445959","modified":1543298015130},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543198210476},{"_id":"themes/hexo-theme-next/.git/objects/18/bfd793e92771a5dc982567a8f02b2694123b37","hash":"2a905abb609376ba05d0b432c7fcfb37866bad54","modified":1543250843843},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543198210472},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543198210476},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"c062995329302467dfa0b23c8e61110eea673e08","modified":1543198210400},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1543198210440},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"78946c9e8c497ddd0d8d842f5515c2e452461e82","modified":1543250624783},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"aa979335caa23e77d79833a9c3304395614412a8","modified":1543235620568},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1543198210444},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543198210448},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1543198210452},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543198210460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1543198210464},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543198210464},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1543198210472},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-085ca2fa71864e32c411aee65ef48ec3c9cd3307.idx","hash":"dcb75fb4289ca234c6610fc60f971a0713507ead","modified":1543198210196},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1543198210456},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1543198210476},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1543198210468},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-085ca2fa71864e32c411aee65ef48ec3c9cd3307.pack","hash":"d490685f539b63cd1dd5879b056a8c129f389d66","modified":1543333368000},{"_id":"public/CNAME","hash":"697d8d2c5a646183e54be47e4724d112f232658d","modified":1544492151429},{"_id":"public/search.xml","hash":"de7d1f4d6b85d76653db82e6bcec0d7e4bdc4d63","modified":1544498852138},{"_id":"public/baidusitemap.xml","hash":"0cab674c934910b9567948f83c5f1ce6d58487f8","modified":1544498852133},{"_id":"public/sitemap.xml","hash":"9abf4b18db900d7559f9ed06239c89b16bb392cd","modified":1544498852133},{"_id":"public/2018/12/10/kvm-memory/index.html","hash":"72f5d712cc9e3ce5b85afac564a0f62a327a16a6","modified":1544498852851},{"_id":"public/2018/12/10/kvm-cpu/index.html","hash":"0ec4b736a0e9ef27b0977fed4c6e537957062cbd","modified":1544498852857},{"_id":"public/categories/index.html","hash":"854691f95c1735432d981c5298315c46fe04aa96","modified":1544498852897},{"_id":"public/2018/12/10/kvm-overview/index.html","hash":"4e0b534aa5b7997cb40b9b81a45d2ea2daa1ba93","modified":1544498852857},{"_id":"public/about/index.html","hash":"6ebdcff69453107bf22be5e3fd7eb831a88d13f7","modified":1544498852851},{"_id":"public/tags/index.html","hash":"1d7bb22e25d03e35c0008770bce702da753eb076","modified":1544498852857},{"_id":"public/2018/12/10/qmp-introduction/index.html","hash":"ba74e4ca38160912a13bdf702d1d838f99e2d180","modified":1544498852897},{"_id":"public/2014/12/11/kvm-src-1/index.html","hash":"71c5c5877faf277088ecd4a84bf130c65de9ac20","modified":1544498852857},{"_id":"public/2018/12/10/kvm-boot/index.html","hash":"a92f00c53a40ae522e2f8e358a66f2d8248d901f","modified":1544498852857},{"_id":"public/2018/11/26/hello-world/index.html","hash":"1085c31704b4423d1f25c995f2ee934784b51c91","modified":1544498852857},{"_id":"public/2018/11/26/hexo-next主题/index.html","hash":"db6396702c234abc9c6daf8cdc3e1259871108e1","modified":1544498852857},{"_id":"public/archives/index.html","hash":"697c2ab14ebed4ecc696b71a7a8072ce6bd1eb50","modified":1544498852897},{"_id":"public/categories/KVM/index.html","hash":"d7e6065b5504b545b129dadadbcf53156dc2dbca","modified":1544498852897},{"_id":"public/archives/2014/index.html","hash":"fe95f81025d51c184dbc0e3a75f585952b0f406d","modified":1544498852897},{"_id":"public/archives/2014/12/index.html","hash":"0807683d33a0fd5318b36b080a77a9c77a744b8f","modified":1544498852898},{"_id":"public/categories/QEMU/index.html","hash":"2629f3f17d12cc18e6b111700b31fa47f320b748","modified":1544498852897},{"_id":"public/index.html","hash":"c4e264395d154c92d05d9328d5a50b7338f4ef45","modified":1544498852857},{"_id":"public/archives/2018/index.html","hash":"978875480dece44aa451cbcdf1746edb85197276","modified":1544498852898},{"_id":"public/tags/KVM/index.html","hash":"1ec000dfb1c0582059dbd95787b4e337305575db","modified":1544498852898},{"_id":"public/archives/2018/12/index.html","hash":"43506cae746376c1b3aeae7b6f6c011eec03a609","modified":1544498852898},{"_id":"public/tags/QEMU/index.html","hash":"446e1efed60a58f31793bc4cfd2eb950cafdfeeb","modified":1544498852898},{"_id":"public/tags/QMP/index.html","hash":"bdbc226f7463bdd7bbcb5e12c7c1640602394e12","modified":1544498852898},{"_id":"public/archives/2018/11/index.html","hash":"a44c0ff88896b5c1683789958d3dbac61ef54a98","modified":1544498852898},{"_id":"public/robots.txt","hash":"213c8b0866f9d99a3b78fdd376ec9eadcd763b42","modified":1544492152606},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1544492152606},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1544492152607},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1544492152607},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1544492152607},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1544492152607},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1544492152607},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1544492152607},{"_id":"public/images/favicon-16x16-next.png","hash":"d373a666d28b34e5bef952342860120f96c64d91","modified":1544492152607},{"_id":"public/images/alipay.png","hash":"4a8675d1848a77f4ac793c186840bd79600e9111","modified":1544492152608},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1544492152608},{"_id":"public/images/favicon-32x32-next.png","hash":"02ee033f52051d3895703689c2601acac03dc02c","modified":1544492152608},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1544492152608},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1544492152608},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1544492152608},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1544492152608},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1544492152609},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1544492152609},{"_id":"public/images/wechatpay.png","hash":"394c68c9698cccf0d0e290f4468e2cf72bc8df3d","modified":1544492152609},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1544492152609},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1544492152919},{"_id":"public/lib/three/three-waves.min.js_bak","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1544492152919},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1544492152919},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1544492152919},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1544492152920},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1544492152920},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1544492152920},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1544492152920},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1544492152920},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1544492152920},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1544492152920},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1544492152920},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1544492152920},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1544492152920},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1544492152920},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1544492152920},{"_id":"public/2018/12/10/kvm-cpu/vmm_guest_switch.png","hash":"211beafc6cf39027f8d5d4603f14658a668e9c51","modified":1544492152920},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa3_shadow.png","hash":"e94f9351b678e66ca82407b6af2640c0de5dec5a","modified":1544492152920},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa2.png","hash":"dced64d97cf2b9ffe18649a44abe3449f2af87da","modified":1544492152920},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa4.png","hash":"69d2ca2ad87b8a8ffc4224abcb9cfcb9f05209b4","modified":1544492152920},{"_id":"public/2018/12/10/kvm-memory/logical_address.png","hash":"b6442991e95d16255a2033b1f74d5a44d8efff7a","modified":1544492152920},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa.png","hash":"d427367cd272b4c65dbe629222bf70f476cf7137","modified":1544492152920},{"_id":"public/2014/12/11/kvm-src-1/kvm_arch_map-1.png","hash":"ce3effcc254c76ec71d6d7c12fbcd5533706b179","modified":1544492152920},{"_id":"public/2014/12/11/kvm-src-1/hypervisor-1.png","hash":"ac25ea8a50243dbf82940578fab9a0cd17cc1fd7","modified":1544492152921},{"_id":"public/2014/12/11/kvm-src-1/kvm_process-1.png","hash":"62c4e736cff35431026a35d5817aa5cb44d808f4","modified":1544492152921},{"_id":"public/2018/12/10/kvm-overview/01_brief.png","hash":"687e4d3b8975842568b8692cb9090910df33445f","modified":1544492152921},{"_id":"public/css/main.css","hash":"8d011fedd654c9fe2569ec6211dcd699d2c3627a","modified":1544492153260},{"_id":"public/images/avatar.gif","hash":"0c5c7400b4e2d1a3105f7bd5a583d0c05421a20f","modified":1544492153271},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1544492153283},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1544492153284},{"_id":"public/2018/12/10/kvm-cpu/vcpu-follow.png","hash":"42405e69514a7b136ce6bcaa83c3b04da9c11ed1","modified":1544492153284},{"_id":"public/2018/12/10/kvm-memory/gpa_hpa5_ept.png","hash":"0b4e906c590a8a680ebe710ec37440b120ca1ef4","modified":1544492153284},{"_id":"public/2018/12/10/kvm-overview/02_kvm_framework.png","hash":"c8890d45a5d37bf3f5ced9fcc6ec5cbf020cb03e","modified":1544492153284},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1544492153292},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1544492153292},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1544492153292},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1544492153292},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1544492153292},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1544492153292},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1544492153292},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1544492153292},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1544492153292},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1544492153292},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1544492153292},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1544492153292},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1544492153292},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1544492153292},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1544492153293},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1544492153293},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1544492153293},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1544492153293},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1544492153293},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1544492153293},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1544492153293},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1544492153293},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1544492153293},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1544492153294},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1544492153294},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1544492153294},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1544492153294},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1544492153294},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1544492153294},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1544492153294},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1544492153294},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1544492153294},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1544492153294},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1544492153294},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1544492153294},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1544492153294},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1544492153294},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1544492153294},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1544492153294},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1544492153294},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1544492153294},{"_id":"public/lib/three/three-waves.min.js","hash":"48e5996d879f2e447cc2c644b15b3b93da938e37","modified":1544492153294},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1544492153294},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1544492153294},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1544492153294},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1544492153294},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1544492153295},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1544492153295},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1544492153295},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1544492153295},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1544492153295},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1544492153295},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1544492153295},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1544492153295},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1544492153295},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1544492153295},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1544492153295},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1544492153295},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1544492153295},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1544492153295},{"_id":"public/2018/12/10/kvm-cpu/vcpu-ring.png","hash":"bebcc569ba07e6b2a362f45df5843a8b114893ad","modified":1544492153295},{"_id":"public/2018/12/10/kvm-memory/page.png","hash":"f619079a24e1a1d13ef6c54e01eebe465568d57a","modified":1544492153295},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1544492153303},{"_id":"source/_posts/.kvm-src-2-vm-run.md.swo","hash":"3fe03eaf745e3a2bda81a7dbc8431520911820b0","modified":1544492939116},{"_id":"source/_posts/.kvm-src-2-vm-run.md.swp","hash":"d350823df4aa283ea2b3b23df946dc4c4a49e4ea","modified":1544492545740},{"_id":"source/_posts/kvm-src-2-vm-run.md","hash":"36737acbb611b766f98432ca055f3777904641af","modified":1544495306076},{"_id":"source/_posts/(1);","hash":"997a3bc43a5bc58d1dab1270c632d5275c2ccf7b","modified":1544492425348},{"_id":"source/_posts/kvm-src-3-cpu.md","hash":"1ae5f8d58b54b659b48ea184174862a6a9a027fc","modified":1544497372188},{"_id":"source/_posts/.kvm-src-3-cpu.md.swp","hash":"53f97b47646ef931514239010f7134e010ddf716","modified":1544497372256},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_create_kvm_vm-1.png","hash":"6dc7f590d4de96a4336a790b35c4f23d793f118b","modified":1487490001000},{"_id":"source/_posts/kvm-src-3-cpu/kvm_vmx_intel-1.jpg","hash":"708139be4720ac0b9b83ef1e55c4fb65f9bed63b","modified":1487489996000},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_module_init-1.png","hash":"5b908cf12f81907f4c6297dfcb0c07e2ecaf282d","modified":1487490001000},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_memory_module-1.bmp","hash":"f43631e1a12cda2c0b499d5d2bf134495b0060fd","modified":1487490002000},{"_id":"source/_posts/kvm-src-4-mem.md","hash":"2d5ea1641921b9139f1fcbbfeb646ae0aa631eb4","modified":1544498821008},{"_id":"source/_posts/.kvm-src-4-mem.md.swp","hash":"3dc45583dc1d48da32693341a6d3bfdddea6ef6d","modified":1544498821072},{"_id":"public/2014/12/11/kvm-src-4-mem/index.html","hash":"f5471ceb830d94b80a173e4832f03c57e8d2c0af","modified":1544498852897},{"_id":"public/2014/12/11/kvm-src-3-cpu/index.html","hash":"4208eb79d204de8c4f9fa29c0b38f24334aa6634","modified":1544498852897},{"_id":"public/2014/12/11/kvm-src-2-vm-run/index.html","hash":"e17f1dfcaa00f64f9f38fca1a0705b5bc2f64a70","modified":1544498852897},{"_id":"public/page/2/index.html","hash":"d3ff8178212ebb4db5a1e84d3608a1c04459d131","modified":1544498852897},{"_id":"public/archives/page/2/index.html","hash":"a8ab22d2953d20165126787cbea412103d6e99de","modified":1544498852899},{"_id":"public/2014/12/11/kvm-src-2-vm-run/qemu_create_kvm_vm-1.png","hash":"6dc7f590d4de96a4336a790b35c4f23d793f118b","modified":1544498852899},{"_id":"public/2014/12/11/kvm-src-2-vm-run/qemu_module_init-1.png","hash":"5b908cf12f81907f4c6297dfcb0c07e2ecaf282d","modified":1544498852899},{"_id":"public/2014/12/11/kvm-src-3-cpu/kvm_vmx_intel-1.jpg","hash":"708139be4720ac0b9b83ef1e55c4fb65f9bed63b","modified":1544498852899},{"_id":"public/2014/12/11/kvm-src-2-vm-run/qemu_memory_module-1.bmp","hash":"f43631e1a12cda2c0b499d5d2bf134495b0060fd","modified":1544498853076}],"Category":[{"name":"KVM","_id":"cjpj2qxl30007y0o4r7kiziq7"},{"name":"QEMU","_id":"cjpj2qxlb000fy0o4litygjf7"}],"Data":[],"Page":[{"title":"关于“Yi颗烂樱桃”","date":"2018-11-26T02:54:13.000Z","comments":0,"_content":"\n本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。\n计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。\n就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。\n目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。\n平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。\n希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。\n我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。\n之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。\n欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。\n很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！\n","source":"about/index.md","raw":"---\ntitle: 关于“Yi颗烂樱桃”\ndate: 2018-11-26 10:54:13\ncomments: false\n---\n\n本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。\n计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。\n就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。\n目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。\n平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。\n希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。\n我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。\n之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。\n欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。\n很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！\n","updated":"2018-11-28T02:41:29.397Z","path":"about/index.html","layout":"page","_id":"cjpj2qxky0001y0o4wwj63u8w","content":"<p>本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。<br>计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。<br>就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。<br>目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。<br>平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。<br>希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。<br>我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。<br>之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。<br>欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。<br>很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本人系魔都小小程序员一颗———或者仅仅是“我自己认为程序员”，因为听说真正的“程序员”是有门槛的，我不确定我是不是达到魔都“程序员”的薪金要求。<br>计算机硕士———当然这样的学历在身边完全不值当炫耀，所以，更不敢提母校，生怕给学校抹黑。<br>就职于魔都一家小小的外资企业，从事Linux Kernel相关工作———因为是外企的缘故，可能多是些打杂的事情，还望各路大神不要吐槽。<br>目前正在从事的工作是KVM、QEMU等虚拟化相关的项目，项目本身妙不可言，但想通过这个博客可以总结沉淀一下自己的知识积累，好记性不如烂笔头，就当给自己做笔记了。对于笔记来说“搜索”功能最重要了，所以本博客支持本地搜索功能，耶~~ （好无聊）。<br>平时用的多的语言是C，和Shell，还有一点点Python，但有时候喜欢折腾些新鲜玩意儿，所以，HTML、JS、C++等等语言也都略懂一丢丢。<br>希望这个博客可以坚持5年以上，千万不要让他半途而废了———毕竟我花了整整两天时间，把他搭建的差不多了。<br>我平时爱好不少，coding是最自虐的爱好，喜欢捣鼓电子，搞一些图形化编程（用于教育）包括Scratch、Blockly等；体育运动的话，没事的时候喜欢打打羽毛球，因为年纪大了篮球打不动了，身边的同学们也都太忙凑不齐人了。<br>之所以坚持这个博客使用中文，几个原因，第一,当然是懒,因为之前试图用英语写些文章，但终究没有坚持下来，希望中文可以提高我一点点的热情，不要被生活的琐事给磨灭了；第二，因为最近发现很多开源项目的讨论区里面，都是中文，contributer都崩溃了，所以想着是不是可以顺便为国争光一下下。第三，估计也是最重要的原因，用中文可以不用被语言打断我的思路，可以表述的更准确和明白一些。<br>欢迎小伙伴在各个文章下面留言，但请保持克制，博客能开个评论区不容易，因为国内的环境大家都懂的，感谢配合；很希望有小伙伴一块讨论技术问题，我尽可能回复。<br>很高兴你可以在浩如烟海的互联网中发现“Yi颗烂樱桃”！</p>\n"},{"title":"categories","date":"2018-11-26T03:21:05.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-26 11:21:05\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-27T09:39:16.150Z","path":"categories/index.html","layout":"page","_id":"cjpj2qxl00003y0o45jr4gs7o","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-26T03:23:32.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-26 11:23:32\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-27T09:39:42.526Z","path":"tags/index.html","layout":"page","_id":"cjpj2qxl10005y0o4sjg5dvw3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","donate":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndonate: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-11-26T13:13:16.288Z","updated":"2018-11-26T13:13:16.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpj2qxkv0000y0o45fk8veip","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"hexo+next主题","date":"2018-11-26T02:49:59.000Z","_content":"\n这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。\n另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~\n\n从印象笔记到简书到Hexo\n我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。\n\n但使用了简书3个月之后，我就发现了一些问题：\n\n首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；\n\n其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；\n\n另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；\n\n在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。\n\nHexo部署\nhexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。\n\n安装前提\n安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：\n\nimage-20180809141924679\n安装Hexo\n安装好node.js和git后，可以通过npm来安装Hexo。\n\nnpm install -g hexo-cli\n建站\n之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：\n\nhexo init <folder>\ncd <folder>\nnpm install\n<folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。\n\n文件夹开始初始化了\n站内内容\n新建好的文件夹目录如下：\n\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n这里解释一下各个文件夹的作用：\n\nconfig.yml\n博客的配置文件，博客的名称、关键词、作者、语言、博客主题...设置都在里面。\n\npackage.json\n应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。\n\nscaffolds\nscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。\n\n这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容\n\nsource\nsource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。\n\nthemes\n放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。\n\n初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。\n\nHexo命令\ninit\n新建一个网站。\n\nhexo init <folder>\nnew\n新建文章或页面。\n\nhexo new <layout> \"title\"\n这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。\n\n默认是添加posts。\n\n然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。\n\ngenerate\n生成静态页面\n\nhexo generate\n也可以简写成\n\nhexo g\ndeploy\n将内容部署到网站\n\nhexo deploy\n也可以简写成\n\nhexo -d\npublish\n发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。\n\nhexo publish <layout> <filename>\nserver\n启动服务器，默认情况下，访问网站为http://localhost:4000/\n\nhexo server\n也可以简写成\n\nhexo s\n根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：\n\nhexo n <filename> 新建文章\nhexo s 启动服务器，在本地查看内容\nhexo g 生成静态页面\nhexo deploy 部署到网站\n以上四个步骤。\n\n其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。\n\n搭建好后我们在localhost:4000就可以看到这样的博客内容：\n\nimage-20180809152743968\n实际操作\n我在新建博客之后，做了以下改动：\n\n1. 创建“分类”页面\n新建分类页面\n\nhexo new page categories\n给分类页面添加类型\n\n我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。\n\n---\ntitle: 文章分类\ndate: 2017-05-27 13:47:40\ntype: \"categories\"   #这部分是新添加的\n---\n给模板添加分类属性\n\n现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。\n\ntitle: {{ title }}\ndate: {{ date }}\ncategories:\ntags:\n给文章添加分类\n\n现在我们可以找到一篇文章，然后尝试给它添加分类\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n2. 创建“标签”页面\n创建\"标签\"页的方式和创建“分类”一样。\n\n新建“标签”页面\n\nhexo new page tags\n给标签页面添加类型\n\n我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。\n\ntitle: tags\ndate: 2018-08-06 22:48:29\ntype: \"tags\" #新添加的内容\n给文章添加标签\n\n有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n第二种写法是用-短划线列出来\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: \n- node.js\n- express\n部署域名\n紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。\n\n部署Github\n首先你必须有一个github账号\n\n然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)\n\nimage-20180809153134467\n然后在setting里添加生成页面的选项\n\nimage-20180809153304980\nimage-20180809153343362\n这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径\n\nimage-20180809153610047\n这里注意两小点：\n\n属性和内容之间一定要有一个空格，配置文件有自己的格式规范\n如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程\n我们再用hexo g && hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了\n\nimage-20180809153933270\n部署自己的域名\n首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；\n\n购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；\n\n认证成功后需要解析域名\n\nimage-20180809154942783\nimage-20180809155013659\n记录类型选CNAME，记录值是自己github生成页面的地址。\n\n在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下\n\n这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可\n\nnpm i hexo-generator-cname --save\n最后hexo g && hexo deploy就可以了\n\nNexT主题\nhexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。\n\n首先，NexT也有中文文档，然后我们就可以开始了。\n\n安装\n我是用的git clone的方法，文档中还有其他方法\n\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n设置主题\n在hexo根目录下的配置文件config.yml里设置主题\n\ntheme: next\n配置主题\n接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。\n\n官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用\n\n菜单栏 menu\n原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n注意点：\n\n如果事先没有通过hexo new page <pageName>来创建页面的话，即使在配置文件中取消注释，页面也没法显示\n我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里\n||后面是fontAwesome里的文件对应的名称\nmenu_icons记得选enable: true（默认应该是true）\n我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  读书: /books || book\n  电影: /movies || film\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n主题风格 schemes\n主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。\n\nMuse\n\nimage-20180809164700600\nMist\n\nimage-20180809164749052\nPisces\n\nimage-20180809164925685\nGemini\n\nimage-20180809165023401\n选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。\n\n底部建站时间和图标修改\n修改主题的配置文件：\n\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  since: 2018\n\n  # Icon between year and copyright info.\n  icon: snowflake-o\n\n  # If not defined, will be used `author` from Hexo main config.\n  copyright:\n  # -------------------------------------------------------------\n  # Hexo link (Powered by Hexo).\n  powered: false\n\n  theme:\n    # Theme & scheme info link (Theme - NexT.scheme).\n    enable: false\n    # Version info of NexT after scheme info (vX.X.X).\n    # version: false\n我在这部分做了这样几件事：\n\n把用户的图标从小人user改成了雪花snowflake-o\ncopyright留空，显示成页面author即我的名字\npowered: false把hexo的授权图片取消了\ntheme: enable:false 把主题的内容也取消了\n这样底部信息比较简单。\n\nimage-20180809172835606\n个人社交信息 social\n在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。\n\nsocial:\n  GitHub: https://github.com/XuQuan-nikkkki || github\n  E-Mail: mailto:xuquan1225@hotmail.com || envelope\n  #Google: https://plus.google.com/yourname || google\n  #Twitter: https://twitter.com/yourname || twitter\n  #FB Page: https://www.facebook.com/yourname || facebook\n注意点：\n\n||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标\n建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球\n网站动画效果\n为了网站响应速度我们可以把网站的动画关掉\n\nmotion:\n  enable: false\n但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。\n\nmotion:\n  enable: true\n  async: true\n  \n# Canvas-nest\ncanvas_nest: true\n\n# three_waves\nthree_waves: false\n\n# canvas_lines\ncanvas_lines: false\n\n# canvas_sphere\ncanvas_sphere: false\n评论系统\nNexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。\n\n方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。\n\n# Disqus\ndisqus:\n  enable: true\n  shortname: xuquan\n  count: true\n统计文章字数和阅读时间\npost_wordcount:\n  item_text: true\n  wordcount: true  # 文章字数\n  min2read: true   # 阅读时间\n  totalcount: true  # 总共字数\n  separated_meta: true\n统计阅读次数\n这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：\n\nimage-20180809175133462\n第三方插件\nHexo-admin\nHexo-admin插件允许我们直接在本地页面上修改文章内容。\n\n下载\n\nnpm i hexo-admin --save\n登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\n\nHexo-douban\nhexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。\n\n下载\n\nnpm install hexo-douban --save\n配置\n\n在hexo根目录下的config.yml文件中添加如下内容\n\ndouban:\n  user: \n  builtin: false\n  book:\n    title: 'This is my book title'\n    quote: 'This is my book quote'\n  movie:\n    title: 'This is my movie title'\n    quote: 'This is my movie quote'\n  game:\n    title: 'This is my game title'\n    quote: 'This is my game quote'\n  timeout: 10000 \ntitle和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。\n\nuser就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。\n\n生成页面\n\nhexo douban   #生成读书、电影、游戏三个页面\nhexo douban -b  #生成读书页面\nhexo douban -m  #生成电影页面\nhexo douban -g  #生成游戏页面\n在博客中生成页面\n\n这里就需要用到我们前面提过的hexo new命令了。\n\nhexo new page books\nhexo new page movies\nhexo new page games\n在博客中添加页面\n\n在menu部分添加我们需要添加的页面名称和相对路径\n\nmenu:\n  Home: /\n  Archives: /archives\n  Books: /books     #This is your books page\n  Movies: /movies   #This is your movies page\n  Games: /games   #This is your games page\n部署到博客\n\nhexo g && hexo deploy\n我踩过的坑\niPic图片上传\nhexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。\n\n但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。\n\n我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。\n\n评论系统\n因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。\n","source":"_posts/hexo-next主题.md","raw":"---\ntitle: hexo+next主题\ndate: 2018-11-26 10:49:59\ntags:\n---\n\n这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。\n另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~\n\n从印象笔记到简书到Hexo\n我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。\n\n但使用了简书3个月之后，我就发现了一些问题：\n\n首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；\n\n其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；\n\n另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；\n\n在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。\n\nHexo部署\nhexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。\n\n安装前提\n安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：\n\nimage-20180809141924679\n安装Hexo\n安装好node.js和git后，可以通过npm来安装Hexo。\n\nnpm install -g hexo-cli\n建站\n之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：\n\nhexo init <folder>\ncd <folder>\nnpm install\n<folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。\n\n文件夹开始初始化了\n站内内容\n新建好的文件夹目录如下：\n\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n这里解释一下各个文件夹的作用：\n\nconfig.yml\n博客的配置文件，博客的名称、关键词、作者、语言、博客主题...设置都在里面。\n\npackage.json\n应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。\n\nscaffolds\nscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。\n\n这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容\n\nsource\nsource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。\n\nthemes\n放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。\n\n初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。\n\nHexo命令\ninit\n新建一个网站。\n\nhexo init <folder>\nnew\n新建文章或页面。\n\nhexo new <layout> \"title\"\n这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。\n\n默认是添加posts。\n\n然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。\n\ngenerate\n生成静态页面\n\nhexo generate\n也可以简写成\n\nhexo g\ndeploy\n将内容部署到网站\n\nhexo deploy\n也可以简写成\n\nhexo -d\npublish\n发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。\n\nhexo publish <layout> <filename>\nserver\n启动服务器，默认情况下，访问网站为http://localhost:4000/\n\nhexo server\n也可以简写成\n\nhexo s\n根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：\n\nhexo n <filename> 新建文章\nhexo s 启动服务器，在本地查看内容\nhexo g 生成静态页面\nhexo deploy 部署到网站\n以上四个步骤。\n\n其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。\n\n搭建好后我们在localhost:4000就可以看到这样的博客内容：\n\nimage-20180809152743968\n实际操作\n我在新建博客之后，做了以下改动：\n\n1. 创建“分类”页面\n新建分类页面\n\nhexo new page categories\n给分类页面添加类型\n\n我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。\n\n---\ntitle: 文章分类\ndate: 2017-05-27 13:47:40\ntype: \"categories\"   #这部分是新添加的\n---\n给模板添加分类属性\n\n现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。\n\ntitle: {{ title }}\ndate: {{ date }}\ncategories:\ntags:\n给文章添加分类\n\n现在我们可以找到一篇文章，然后尝试给它添加分类\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n2. 创建“标签”页面\n创建\"标签\"页的方式和创建“分类”一样。\n\n新建“标签”页面\n\nhexo new page tags\n给标签页面添加类型\n\n我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。\n\ntitle: tags\ndate: 2018-08-06 22:48:29\ntype: \"tags\" #新添加的内容\n给文章添加标签\n\n有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: [node.js, express]\n第二种写法是用-短划线列出来\n\nlayout: posts\ntitle: 写给小白的express学习笔记1： express-static文件静态管理\ndate: 2018-06-07 00:38:36\ncategories: 学习笔记\ntags: \n- node.js\n- express\n部署域名\n紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。\n\n部署Github\n首先你必须有一个github账号\n\n然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)\n\nimage-20180809153134467\n然后在setting里添加生成页面的选项\n\nimage-20180809153304980\nimage-20180809153343362\n这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径\n\nimage-20180809153610047\n这里注意两小点：\n\n属性和内容之间一定要有一个空格，配置文件有自己的格式规范\n如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程\n我们再用hexo g && hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了\n\nimage-20180809153933270\n部署自己的域名\n首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；\n\n购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；\n\n认证成功后需要解析域名\n\nimage-20180809154942783\nimage-20180809155013659\n记录类型选CNAME，记录值是自己github生成页面的地址。\n\n在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下\n\n这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可\n\nnpm i hexo-generator-cname --save\n最后hexo g && hexo deploy就可以了\n\nNexT主题\nhexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。\n\n首先，NexT也有中文文档，然后我们就可以开始了。\n\n安装\n我是用的git clone的方法，文档中还有其他方法\n\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n设置主题\n在hexo根目录下的配置文件config.yml里设置主题\n\ntheme: next\n配置主题\n接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。\n\n官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用\n\n菜单栏 menu\n原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n注意点：\n\n如果事先没有通过hexo new page <pageName>来创建页面的话，即使在配置文件中取消注释，页面也没法显示\n我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里\n||后面是fontAwesome里的文件对应的名称\nmenu_icons记得选enable: true（默认应该是true）\n我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。\n\nmenu:\n  home: / || home\n  # about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  读书: /books || book\n  电影: /movies || film\n  archives: /archives/ || archive\n  # schedule: /schedule/ || calendar\n  # sitemap: /sitemap.xml || sitemap\n  # commonweal: /404/ || heartbeat\n主题风格 schemes\n主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。\n\nMuse\n\nimage-20180809164700600\nMist\n\nimage-20180809164749052\nPisces\n\nimage-20180809164925685\nGemini\n\nimage-20180809165023401\n选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。\n\n底部建站时间和图标修改\n修改主题的配置文件：\n\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  since: 2018\n\n  # Icon between year and copyright info.\n  icon: snowflake-o\n\n  # If not defined, will be used `author` from Hexo main config.\n  copyright:\n  # -------------------------------------------------------------\n  # Hexo link (Powered by Hexo).\n  powered: false\n\n  theme:\n    # Theme & scheme info link (Theme - NexT.scheme).\n    enable: false\n    # Version info of NexT after scheme info (vX.X.X).\n    # version: false\n我在这部分做了这样几件事：\n\n把用户的图标从小人user改成了雪花snowflake-o\ncopyright留空，显示成页面author即我的名字\npowered: false把hexo的授权图片取消了\ntheme: enable:false 把主题的内容也取消了\n这样底部信息比较简单。\n\nimage-20180809172835606\n个人社交信息 social\n在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。\n\nsocial:\n  GitHub: https://github.com/XuQuan-nikkkki || github\n  E-Mail: mailto:xuquan1225@hotmail.com || envelope\n  #Google: https://plus.google.com/yourname || google\n  #Twitter: https://twitter.com/yourname || twitter\n  #FB Page: https://www.facebook.com/yourname || facebook\n注意点：\n\n||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标\n建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球\n网站动画效果\n为了网站响应速度我们可以把网站的动画关掉\n\nmotion:\n  enable: false\n但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。\n\nmotion:\n  enable: true\n  async: true\n  \n# Canvas-nest\ncanvas_nest: true\n\n# three_waves\nthree_waves: false\n\n# canvas_lines\ncanvas_lines: false\n\n# canvas_sphere\ncanvas_sphere: false\n评论系统\nNexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。\n\n方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。\n\n# Disqus\ndisqus:\n  enable: true\n  shortname: xuquan\n  count: true\n统计文章字数和阅读时间\npost_wordcount:\n  item_text: true\n  wordcount: true  # 文章字数\n  min2read: true   # 阅读时间\n  totalcount: true  # 总共字数\n  separated_meta: true\n统计阅读次数\n这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：\n\nimage-20180809175133462\n第三方插件\nHexo-admin\nHexo-admin插件允许我们直接在本地页面上修改文章内容。\n\n下载\n\nnpm i hexo-admin --save\n登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\n\nHexo-douban\nhexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。\n\n下载\n\nnpm install hexo-douban --save\n配置\n\n在hexo根目录下的config.yml文件中添加如下内容\n\ndouban:\n  user: \n  builtin: false\n  book:\n    title: 'This is my book title'\n    quote: 'This is my book quote'\n  movie:\n    title: 'This is my movie title'\n    quote: 'This is my movie quote'\n  game:\n    title: 'This is my game title'\n    quote: 'This is my game quote'\n  timeout: 10000 \ntitle和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。\n\nuser就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。\n\n生成页面\n\nhexo douban   #生成读书、电影、游戏三个页面\nhexo douban -b  #生成读书页面\nhexo douban -m  #生成电影页面\nhexo douban -g  #生成游戏页面\n在博客中生成页面\n\n这里就需要用到我们前面提过的hexo new命令了。\n\nhexo new page books\nhexo new page movies\nhexo new page games\n在博客中添加页面\n\n在menu部分添加我们需要添加的页面名称和相对路径\n\nmenu:\n  Home: /\n  Archives: /archives\n  Books: /books     #This is your books page\n  Movies: /movies   #This is your movies page\n  Games: /games   #This is your games page\n部署到博客\n\nhexo g && hexo deploy\n我踩过的坑\niPic图片上传\nhexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。\n\n但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。\n\n我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。\n\n评论系统\n因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。\n","slug":"hexo-next主题","published":1,"updated":"2018-11-26T02:53:19.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpj2qxky0002y0o4x5oiy9jy","content":"<p>这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。<br>另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~</p>\n<p>从印象笔记到简书到Hexo<br>我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。</p>\n<p>但使用了简书3个月之后，我就发现了一些问题：</p>\n<p>首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；</p>\n<p>其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；</p>\n<p>另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；</p>\n<p>在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。</p>\n<p>Hexo部署<br>hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。</p>\n<p>安装前提<br>安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：</p>\n<p>image-20180809141924679<br>安装Hexo<br>安装好node.js和git后，可以通过npm来安装Hexo。</p>\n<p>npm install -g hexo-cli<br>建站<br>之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：</p>\n<p>hexo init <folder><br>cd <folder><br>npm install</folder></folder></p>\n<p><folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。</folder></p>\n<p>文件夹开始初始化了<br>站内内容<br>新建好的文件夹目录如下：</p>\n<p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>这里解释一下各个文件夹的作用：</p>\n<p>config.yml<br>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p>\n<p>package.json<br>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p>\n<p>scaffolds<br>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p>\n<p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p>\n<p>source<br>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p>\n<p>themes<br>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p>\n<p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p>\n<p>Hexo命令<br>init<br>新建一个网站。</p>\n<p>hexo init <folder><br>new<br>新建文章或页面。</folder></p>\n<p>hexo new <layout> “title”<br>这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。</layout></layout></p>\n<p>默认是添加posts。</p>\n<p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p>\n<p>generate<br>生成静态页面</p>\n<p>hexo generate<br>也可以简写成</p>\n<p>hexo g<br>deploy<br>将内容部署到网站</p>\n<p>hexo deploy<br>也可以简写成</p>\n<p>hexo -d<br>publish<br>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p>\n<p>hexo publish <layout> <filename><br>server<br>启动服务器，默认情况下，访问网站为<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></filename></layout></p>\n<p>hexo server<br>也可以简写成</p>\n<p>hexo s<br>根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：</p>\n<p>hexo n <filename> 新建文章<br>hexo s 启动服务器，在本地查看内容<br>hexo g 生成静态页面<br>hexo deploy 部署到网站<br>以上四个步骤。</filename></p>\n<p>其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。</p>\n<p>搭建好后我们在localhost:4000就可以看到这样的博客内容：</p>\n<p>image-20180809152743968<br>实际操作<br>我在新建博客之后，做了以下改动：</p>\n<ol>\n<li>创建“分类”页面<br>新建分类页面</li>\n</ol>\n<p>hexo new page categories<br>给分类页面添加类型</p>\n<p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<hr>\n<p>title: 文章分类<br>date: 2017-05-27 13:47:40</p>\n<h2 id=\"type-“categories”-这部分是新添加的\"><a href=\"#type-“categories”-这部分是新添加的\" class=\"headerlink\" title=\"type: “categories”   #这部分是新添加的\"></a>type: “categories”   #这部分是新添加的</h2><p>给模板添加分类属性</p>\n<p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>\n<p>title: hexo+next主题<br>date: 1543200599000<br>categories:<br>tags:<br>给文章添加分类</p>\n<p>现在我们可以找到一篇文章，然后尝试给它添加分类</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]</p>\n<ol start=\"2\">\n<li>创建“标签”页面<br>创建”标签”页的方式和创建“分类”一样。</li>\n</ol>\n<p>新建“标签”页面</p>\n<p>hexo new page tags<br>给标签页面添加类型</p>\n<p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<p>title: tags<br>date: 2018-08-06 22:48:29<br>type: “tags” #新添加的内容<br>给文章添加标签</p>\n<p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]<br>第二种写法是用-短划线列出来</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: </p>\n<ul>\n<li>node.js</li>\n<li>express<br>部署域名<br>紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。</li>\n</ul>\n<p>部署Github<br>首先你必须有一个github账号</p>\n<p>然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)</p>\n<p>image-20180809153134467<br>然后在setting里添加生成页面的选项</p>\n<p>image-20180809153304980<br>image-20180809153343362<br>这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径</p>\n<p>image-20180809153610047<br>这里注意两小点：</p>\n<p>属性和内容之间一定要有一个空格，配置文件有自己的格式规范<br>如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程<br>我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了</p>\n<p>image-20180809153933270<br>部署自己的域名<br>首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；</p>\n<p>购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；</p>\n<p>认证成功后需要解析域名</p>\n<p>image-20180809154942783<br>image-20180809155013659<br>记录类型选CNAME，记录值是自己github生成页面的地址。</p>\n<p>在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下</p>\n<p>这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可</p>\n<p>npm i hexo-generator-cname –save<br>最后hexo g &amp;&amp; hexo deploy就可以了</p>\n<p>NexT主题<br>hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p>\n<p>首先，NexT也有中文文档，然后我们就可以开始了。</p>\n<p>安装<br>我是用的git clone的方法，文档中还有其他方法</p>\n<p>$ git clone <a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>设置主题<br>在hexo根目录下的配置文件config.yml里设置主题</p>\n<p>theme: next<br>配置主题<br>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。</p>\n<p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p>\n<p>菜单栏 menu<br>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user\"><a href=\"#about-about-user\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar\"><a href=\"#schedule-schedule-calendar\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap\"><a href=\"#sitemap-sitemap-xml-sitemap\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat\"><a href=\"#commonweal-404-heartbeat\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>注意点：</p>\n<p>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示<br>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里<br>||后面是fontAwesome里的文件对应的名称<br>menu_icons记得选enable: true（默认应该是true）<br>我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。</pagename></p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user-1\"><a href=\"#about-about-user-1\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  读书: /books || book<br>  电影: /movies || film<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar-1\"><a href=\"#schedule-schedule-calendar-1\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap-1\"><a href=\"#sitemap-sitemap-xml-sitemap-1\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat-1\"><a href=\"#commonweal-404-heartbeat-1\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>主题风格 schemes<br>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p>\n<p>Muse</p>\n<p>image-20180809164700600<br>Mist</p>\n<p>image-20180809164749052<br>Pisces</p>\n<p>image-20180809164925685<br>Gemini</p>\n<p>image-20180809165023401<br>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p>\n<p>底部建站时间和图标修改<br>修改主题的配置文件：</p>\n<p>footer:</p>\n<h1 id=\"Specify-the-date-when-the-site-was-setup\"><a href=\"#Specify-the-date-when-the-site-was-setup\" class=\"headerlink\" title=\"Specify the date when the site was setup.\"></a>Specify the date when the site was setup.</h1><h1 id=\"If-not-defined-current-year-will-be-used\"><a href=\"#If-not-defined-current-year-will-be-used\" class=\"headerlink\" title=\"If not defined, current year will be used.\"></a>If not defined, current year will be used.</h1><p>  since: 2018</p>\n<h1 id=\"Icon-between-year-and-copyright-info\"><a href=\"#Icon-between-year-and-copyright-info\" class=\"headerlink\" title=\"Icon between year and copyright info.\"></a>Icon between year and copyright info.</h1><p>  icon: snowflake-o</p>\n<h1 id=\"If-not-defined-will-be-used-author-from-Hexo-main-config\"><a href=\"#If-not-defined-will-be-used-author-from-Hexo-main-config\" class=\"headerlink\" title=\"If not defined, will be used author from Hexo main config.\"></a>If not defined, will be used <code>author</code> from Hexo main config.</h1><p>  copyright:</p>\n<h1 id=\"————————————————————\"><a href=\"#————————————————————\" class=\"headerlink\" title=\"————————————————————-\"></a>————————————————————-</h1><h1 id=\"Hexo-link-Powered-by-Hexo\"><a href=\"#Hexo-link-Powered-by-Hexo\" class=\"headerlink\" title=\"Hexo link (Powered by Hexo).\"></a>Hexo link (Powered by Hexo).</h1><p>  powered: false</p>\n<p>  theme:</p>\n<pre><code># Theme &amp; scheme info link (Theme - NexT.scheme).\nenable: false\n# Version info of NexT after scheme info (vX.X.X).\n# version: false\n</code></pre><p>我在这部分做了这样几件事：</p>\n<p>把用户的图标从小人user改成了雪花snowflake-o<br>copyright留空，显示成页面author即我的名字<br>powered: false把hexo的授权图片取消了<br>theme: enable:false 把主题的内容也取消了<br>这样底部信息比较简单。</p>\n<p>image-20180809172835606<br>个人社交信息 social<br>在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。</p>\n<p>social:<br>  GitHub: <a href=\"https://github.com/XuQuan-nikkkki\" target=\"_blank\" rel=\"noopener\">https://github.com/XuQuan-nikkkki</a> || github<br>  E-Mail: mailto:<a href=\"mailto:xuquan1225@hotmail.com\" target=\"_blank\" rel=\"noopener\">xuquan1225@hotmail.com</a> || envelope</p>\n<p>  #Google: <a href=\"https://plus.google.com/yourname\" target=\"_blank\" rel=\"noopener\">https://plus.google.com/yourname</a> || google</p>\n<p>  #Twitter: <a href=\"https://twitter.com/yourname\" target=\"_blank\" rel=\"noopener\">https://twitter.com/yourname</a> || twitter</p>\n<p>  #FB Page: <a href=\"https://www.facebook.com/yourname\" target=\"_blank\" rel=\"noopener\">https://www.facebook.com/yourname</a> || facebook<br>注意点：</p>\n<p>||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标<br>建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球<br>网站动画效果<br>为了网站响应速度我们可以把网站的动画关掉</p>\n<p>motion:<br>  enable: false<br>但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。</p>\n<p>motion:<br>  enable: true<br>  async: true</p>\n<h1 id=\"Canvas-nest\"><a href=\"#Canvas-nest\" class=\"headerlink\" title=\"Canvas-nest\"></a>Canvas-nest</h1><p>canvas_nest: true</p>\n<h1 id=\"three-waves\"><a href=\"#three-waves\" class=\"headerlink\" title=\"three_waves\"></a>three_waves</h1><p>three_waves: false</p>\n<h1 id=\"canvas-lines\"><a href=\"#canvas-lines\" class=\"headerlink\" title=\"canvas_lines\"></a>canvas_lines</h1><p>canvas_lines: false</p>\n<h1 id=\"canvas-sphere\"><a href=\"#canvas-sphere\" class=\"headerlink\" title=\"canvas_sphere\"></a>canvas_sphere</h1><p>canvas_sphere: false<br>评论系统<br>NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。</p>\n<p>方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。</p>\n<h1 id=\"Disqus\"><a href=\"#Disqus\" class=\"headerlink\" title=\"Disqus\"></a>Disqus</h1><p>disqus:<br>  enable: true<br>  shortname: xuquan<br>  count: true<br>统计文章字数和阅读时间<br>post_wordcount:<br>  item_text: true<br>  wordcount: true  # 文章字数<br>  min2read: true   # 阅读时间<br>  totalcount: true  # 总共字数<br>  separated_meta: true<br>统计阅读次数<br>这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：</p>\n<p>image-20180809175133462<br>第三方插件<br>Hexo-admin<br>Hexo-admin插件允许我们直接在本地页面上修改文章内容。</p>\n<p>下载</p>\n<p>npm i hexo-admin –save<br>登录<a href=\"http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容</a></p>\n<p>Hexo-douban<br>hexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。</p>\n<p>下载</p>\n<p>npm install hexo-douban –save<br>配置</p>\n<p>在hexo根目录下的config.yml文件中添加如下内容</p>\n<p>douban:<br>  user:<br>  builtin: false<br>  book:<br>    title: ‘This is my book title’<br>    quote: ‘This is my book quote’<br>  movie:<br>    title: ‘This is my movie title’<br>    quote: ‘This is my movie quote’<br>  game:<br>    title: ‘This is my game title’<br>    quote: ‘This is my game quote’<br>  timeout: 10000<br>title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。</p>\n<p>user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。</p>\n<p>生成页面</p>\n<p>hexo douban   #生成读书、电影、游戏三个页面<br>hexo douban -b  #生成读书页面<br>hexo douban -m  #生成电影页面<br>hexo douban -g  #生成游戏页面<br>在博客中生成页面</p>\n<p>这里就需要用到我们前面提过的hexo new命令了。</p>\n<p>hexo new page books<br>hexo new page movies<br>hexo new page games<br>在博客中添加页面</p>\n<p>在menu部分添加我们需要添加的页面名称和相对路径</p>\n<p>menu:<br>  Home: /<br>  Archives: /archives<br>  Books: /books     #This is your books page<br>  Movies: /movies   #This is your movies page<br>  Games: /games   #This is your games page<br>部署到博客</p>\n<p>hexo g &amp;&amp; hexo deploy<br>我踩过的坑<br>iPic图片上传<br>hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。</p>\n<p>但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。</p>\n<p>我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。</p>\n<p>评论系统<br>因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。<br>另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~</p>\n<p>从印象笔记到简书到Hexo<br>我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。</p>\n<p>但使用了简书3个月之后，我就发现了一些问题：</p>\n<p>首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；</p>\n<p>其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；</p>\n<p>另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；</p>\n<p>在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。</p>\n<p>Hexo部署<br>hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。</p>\n<p>安装前提<br>安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：</p>\n<p>image-20180809141924679<br>安装Hexo<br>安装好node.js和git后，可以通过npm来安装Hexo。</p>\n<p>npm install -g hexo-cli<br>建站<br>之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：</p>\n<p>hexo init <folder><br>cd <folder><br>npm install</folder></folder></p>\n<p><folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。</folder></p>\n<p>文件夹开始初始化了<br>站内内容<br>新建好的文件夹目录如下：</p>\n<p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>这里解释一下各个文件夹的作用：</p>\n<p>config.yml<br>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p>\n<p>package.json<br>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p>\n<p>scaffolds<br>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p>\n<p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p>\n<p>source<br>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p>\n<p>themes<br>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p>\n<p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p>\n<p>Hexo命令<br>init<br>新建一个网站。</p>\n<p>hexo init <folder><br>new<br>新建文章或页面。</folder></p>\n<p>hexo new <layout> “title”<br>这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。</layout></layout></p>\n<p>默认是添加posts。</p>\n<p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p>\n<p>generate<br>生成静态页面</p>\n<p>hexo generate<br>也可以简写成</p>\n<p>hexo g<br>deploy<br>将内容部署到网站</p>\n<p>hexo deploy<br>也可以简写成</p>\n<p>hexo -d<br>publish<br>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p>\n<p>hexo publish <layout> <filename><br>server<br>启动服务器，默认情况下，访问网站为<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></filename></layout></p>\n<p>hexo server<br>也可以简写成</p>\n<p>hexo s<br>根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：</p>\n<p>hexo n <filename> 新建文章<br>hexo s 启动服务器，在本地查看内容<br>hexo g 生成静态页面<br>hexo deploy 部署到网站<br>以上四个步骤。</filename></p>\n<p>其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。</p>\n<p>搭建好后我们在localhost:4000就可以看到这样的博客内容：</p>\n<p>image-20180809152743968<br>实际操作<br>我在新建博客之后，做了以下改动：</p>\n<ol>\n<li>创建“分类”页面<br>新建分类页面</li>\n</ol>\n<p>hexo new page categories<br>给分类页面添加类型</p>\n<p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<hr>\n<p>title: 文章分类<br>date: 2017-05-27 13:47:40</p>\n<h2 id=\"type-“categories”-这部分是新添加的\"><a href=\"#type-“categories”-这部分是新添加的\" class=\"headerlink\" title=\"type: “categories”   #这部分是新添加的\"></a>type: “categories”   #这部分是新添加的</h2><p>给模板添加分类属性</p>\n<p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>\n<p>title: hexo+next主题<br>date: 1543200599000<br>categories:<br>tags:<br>给文章添加分类</p>\n<p>现在我们可以找到一篇文章，然后尝试给它添加分类</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]</p>\n<ol start=\"2\">\n<li>创建“标签”页面<br>创建”标签”页的方式和创建“分类”一样。</li>\n</ol>\n<p>新建“标签”页面</p>\n<p>hexo new page tags<br>给标签页面添加类型</p>\n<p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p>\n<p>title: tags<br>date: 2018-08-06 22:48:29<br>type: “tags” #新添加的内容<br>给文章添加标签</p>\n<p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]<br>第二种写法是用-短划线列出来</p>\n<p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: </p>\n<ul>\n<li>node.js</li>\n<li>express<br>部署域名<br>紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。</li>\n</ul>\n<p>部署Github<br>首先你必须有一个github账号</p>\n<p>然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)</p>\n<p>image-20180809153134467<br>然后在setting里添加生成页面的选项</p>\n<p>image-20180809153304980<br>image-20180809153343362<br>这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径</p>\n<p>image-20180809153610047<br>这里注意两小点：</p>\n<p>属性和内容之间一定要有一个空格，配置文件有自己的格式规范<br>如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程<br>我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了</p>\n<p>image-20180809153933270<br>部署自己的域名<br>首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；</p>\n<p>购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；</p>\n<p>认证成功后需要解析域名</p>\n<p>image-20180809154942783<br>image-20180809155013659<br>记录类型选CNAME，记录值是自己github生成页面的地址。</p>\n<p>在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下</p>\n<p>这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可</p>\n<p>npm i hexo-generator-cname –save<br>最后hexo g &amp;&amp; hexo deploy就可以了</p>\n<p>NexT主题<br>hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p>\n<p>首先，NexT也有中文文档，然后我们就可以开始了。</p>\n<p>安装<br>我是用的git clone的方法，文档中还有其他方法</p>\n<p>$ git clone <a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>设置主题<br>在hexo根目录下的配置文件config.yml里设置主题</p>\n<p>theme: next<br>配置主题<br>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。</p>\n<p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p>\n<p>菜单栏 menu<br>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user\"><a href=\"#about-about-user\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar\"><a href=\"#schedule-schedule-calendar\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap\"><a href=\"#sitemap-sitemap-xml-sitemap\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat\"><a href=\"#commonweal-404-heartbeat\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>注意点：</p>\n<p>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示<br>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里<br>||后面是fontAwesome里的文件对应的名称<br>menu_icons记得选enable: true（默认应该是true）<br>我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。</pagename></p>\n<p>menu:<br>  home: / || home</p>\n<h1 id=\"about-about-user-1\"><a href=\"#about-about-user-1\" class=\"headerlink\" title=\"about: /about/ || user\"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  读书: /books || book<br>  电影: /movies || film<br>  archives: /archives/ || archive</p>\n<h1 id=\"schedule-schedule-calendar-1\"><a href=\"#schedule-schedule-calendar-1\" class=\"headerlink\" title=\"schedule: /schedule/ || calendar\"></a>schedule: /schedule/ || calendar</h1><h1 id=\"sitemap-sitemap-xml-sitemap-1\"><a href=\"#sitemap-sitemap-xml-sitemap-1\" class=\"headerlink\" title=\"sitemap: /sitemap.xml || sitemap\"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id=\"commonweal-404-heartbeat-1\"><a href=\"#commonweal-404-heartbeat-1\" class=\"headerlink\" title=\"commonweal: /404/ || heartbeat\"></a>commonweal: /404/ || heartbeat</h1><p>主题风格 schemes<br>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p>\n<p>Muse</p>\n<p>image-20180809164700600<br>Mist</p>\n<p>image-20180809164749052<br>Pisces</p>\n<p>image-20180809164925685<br>Gemini</p>\n<p>image-20180809165023401<br>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p>\n<p>底部建站时间和图标修改<br>修改主题的配置文件：</p>\n<p>footer:</p>\n<h1 id=\"Specify-the-date-when-the-site-was-setup\"><a href=\"#Specify-the-date-when-the-site-was-setup\" class=\"headerlink\" title=\"Specify the date when the site was setup.\"></a>Specify the date when the site was setup.</h1><h1 id=\"If-not-defined-current-year-will-be-used\"><a href=\"#If-not-defined-current-year-will-be-used\" class=\"headerlink\" title=\"If not defined, current year will be used.\"></a>If not defined, current year will be used.</h1><p>  since: 2018</p>\n<h1 id=\"Icon-between-year-and-copyright-info\"><a href=\"#Icon-between-year-and-copyright-info\" class=\"headerlink\" title=\"Icon between year and copyright info.\"></a>Icon between year and copyright info.</h1><p>  icon: snowflake-o</p>\n<h1 id=\"If-not-defined-will-be-used-author-from-Hexo-main-config\"><a href=\"#If-not-defined-will-be-used-author-from-Hexo-main-config\" class=\"headerlink\" title=\"If not defined, will be used author from Hexo main config.\"></a>If not defined, will be used <code>author</code> from Hexo main config.</h1><p>  copyright:</p>\n<h1 id=\"————————————————————\"><a href=\"#————————————————————\" class=\"headerlink\" title=\"————————————————————-\"></a>————————————————————-</h1><h1 id=\"Hexo-link-Powered-by-Hexo\"><a href=\"#Hexo-link-Powered-by-Hexo\" class=\"headerlink\" title=\"Hexo link (Powered by Hexo).\"></a>Hexo link (Powered by Hexo).</h1><p>  powered: false</p>\n<p>  theme:</p>\n<pre><code># Theme &amp; scheme info link (Theme - NexT.scheme).\nenable: false\n# Version info of NexT after scheme info (vX.X.X).\n# version: false\n</code></pre><p>我在这部分做了这样几件事：</p>\n<p>把用户的图标从小人user改成了雪花snowflake-o<br>copyright留空，显示成页面author即我的名字<br>powered: false把hexo的授权图片取消了<br>theme: enable:false 把主题的内容也取消了<br>这样底部信息比较简单。</p>\n<p>image-20180809172835606<br>个人社交信息 social<br>在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。</p>\n<p>social:<br>  GitHub: <a href=\"https://github.com/XuQuan-nikkkki\" target=\"_blank\" rel=\"noopener\">https://github.com/XuQuan-nikkkki</a> || github<br>  E-Mail: mailto:<a href=\"mailto:xuquan1225@hotmail.com\" target=\"_blank\" rel=\"noopener\">xuquan1225@hotmail.com</a> || envelope</p>\n<p>  #Google: <a href=\"https://plus.google.com/yourname\" target=\"_blank\" rel=\"noopener\">https://plus.google.com/yourname</a> || google</p>\n<p>  #Twitter: <a href=\"https://twitter.com/yourname\" target=\"_blank\" rel=\"noopener\">https://twitter.com/yourname</a> || twitter</p>\n<p>  #FB Page: <a href=\"https://www.facebook.com/yourname\" target=\"_blank\" rel=\"noopener\">https://www.facebook.com/yourname</a> || facebook<br>注意点：</p>\n<p>||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标<br>建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球<br>网站动画效果<br>为了网站响应速度我们可以把网站的动画关掉</p>\n<p>motion:<br>  enable: false<br>但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。</p>\n<p>motion:<br>  enable: true<br>  async: true</p>\n<h1 id=\"Canvas-nest\"><a href=\"#Canvas-nest\" class=\"headerlink\" title=\"Canvas-nest\"></a>Canvas-nest</h1><p>canvas_nest: true</p>\n<h1 id=\"three-waves\"><a href=\"#three-waves\" class=\"headerlink\" title=\"three_waves\"></a>three_waves</h1><p>three_waves: false</p>\n<h1 id=\"canvas-lines\"><a href=\"#canvas-lines\" class=\"headerlink\" title=\"canvas_lines\"></a>canvas_lines</h1><p>canvas_lines: false</p>\n<h1 id=\"canvas-sphere\"><a href=\"#canvas-sphere\" class=\"headerlink\" title=\"canvas_sphere\"></a>canvas_sphere</h1><p>canvas_sphere: false<br>评论系统<br>NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。</p>\n<p>方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。</p>\n<h1 id=\"Disqus\"><a href=\"#Disqus\" class=\"headerlink\" title=\"Disqus\"></a>Disqus</h1><p>disqus:<br>  enable: true<br>  shortname: xuquan<br>  count: true<br>统计文章字数和阅读时间<br>post_wordcount:<br>  item_text: true<br>  wordcount: true  # 文章字数<br>  min2read: true   # 阅读时间<br>  totalcount: true  # 总共字数<br>  separated_meta: true<br>统计阅读次数<br>这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：</p>\n<p>image-20180809175133462<br>第三方插件<br>Hexo-admin<br>Hexo-admin插件允许我们直接在本地页面上修改文章内容。</p>\n<p>下载</p>\n<p>npm i hexo-admin –save<br>登录<a href=\"http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容</a></p>\n<p>Hexo-douban<br>hexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。</p>\n<p>下载</p>\n<p>npm install hexo-douban –save<br>配置</p>\n<p>在hexo根目录下的config.yml文件中添加如下内容</p>\n<p>douban:<br>  user:<br>  builtin: false<br>  book:<br>    title: ‘This is my book title’<br>    quote: ‘This is my book quote’<br>  movie:<br>    title: ‘This is my movie title’<br>    quote: ‘This is my movie quote’<br>  game:<br>    title: ‘This is my game title’<br>    quote: ‘This is my game quote’<br>  timeout: 10000<br>title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。</p>\n<p>user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。</p>\n<p>生成页面</p>\n<p>hexo douban   #生成读书、电影、游戏三个页面<br>hexo douban -b  #生成读书页面<br>hexo douban -m  #生成电影页面<br>hexo douban -g  #生成游戏页面<br>在博客中生成页面</p>\n<p>这里就需要用到我们前面提过的hexo new命令了。</p>\n<p>hexo new page books<br>hexo new page movies<br>hexo new page games<br>在博客中添加页面</p>\n<p>在menu部分添加我们需要添加的页面名称和相对路径</p>\n<p>menu:<br>  Home: /<br>  Archives: /archives<br>  Books: /books     #This is your books page<br>  Movies: /movies   #This is your movies page<br>  Games: /games   #This is your games page<br>部署到博客</p>\n<p>hexo g &amp;&amp; hexo deploy<br>我踩过的坑<br>iPic图片上传<br>hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。</p>\n<p>但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。</p>\n<p>我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。</p>\n<p>评论系统<br>因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。</p>\n"},{"title":"KVM 虚拟化原理2— QEMU启动过程","donate":true,"date":"2018-12-10T14:57:17.000Z","_content":"\n## 虚拟机启动过程\n\n```hljs\n第一步，获取到kvm句柄\nkvmfd = open(\"/dev/kvm\", O_RDWR);\n第二步，创建虚拟机，获取到虚拟机句柄。\nvmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);\n第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。\nioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);\n第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。\n第五步，创建vCPU，并为vCPU分配内存空间。\nioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);\nvcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n第五步，创建vCPU个数的线程并运行虚拟机。\nioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。\n这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。\n```\n\n```hljs\nopen(\"/dev/kvm\")\nioctl(KVM_CREATE_VM)\nioctl(KVM_CREATE_VCPU)\nfor (;;) {\n     ioctl(KVM_RUN)\n     switch (exit_reason) {\n     case KVM_EXIT_IO:  /* ... */\n     case KVM_EXIT_HLT: /* ... */\n     }\n}\n```\n\n关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。\n\n[KVM ioctl接口文档](https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt)\n\n## 先来一个KVM API开胃菜\n\n下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.  \n这是一个at&t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。  \n这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。  \n最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。  \n4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出\n\n```hljs\n.globl _start\n    .code16\n_start:\n    mov $0x3f8, %dx\n    add %bl, %al\n    add $'0', %al\n    out %al, (%dx)\n    mov $'\\n', %al\n    out %al, (%dx)\n    hlt\n```\n\n我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件\n\n```hljs\nas -32 bin.S -o bin.o\nld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o\n```\n\n查看一下二进制格式\n\n```hljs\n➜  demo1 hexdump -C bin.bin\n00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|\n0000000c\n对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n```\n\n```hljs\n#include <err.h>\n#include <fcntl.h>\n#include <linux/kvm.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int kvm, vmfd, vcpufd, ret;\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n    uint8_t *mem;\n    struct kvm_sregs sregs;\n    size_t mmap_size;\n    struct kvm_run *run;\n\n    // 获取 kvm 句柄\n    kvm = open(\"/dev/kvm\", O_RDWR | O_CLOEXEC);\n    if (kvm == -1)\n        err(1, \"/dev/kvm\");\n\n    // 确保是正确的 API 版本\n    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_API_VERSION\");\n    if (ret != 12)\n        errx(1, \"KVM_GET_API_VERSION %d, expected 12\", ret);\n\n    // 创建一虚拟机\n    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);\n    if (vmfd == -1)\n        err(1, \"KVM_CREATE_VM\");\n\n    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中\n    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if (!mem)\n        err(1, \"allocating guest memory\");\n    memcpy(mem, code, sizeof(code));\n\n    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录\n    struct kvm_userspace_memory_region region = {\n        .slot = 0,\n        .guest_phys_addr = 0x1000,\n        .memory_size = 0x1000,\n        .userspace_addr = (uint64_t)mem,\n    };\n    // 设置 KVM 的内存区域\n    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &region);\n    if (ret == -1)\n        err(1, \"KVM_SET_USER_MEMORY_REGION\");\n\n    // 创建虚拟CPU\n    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);\n    if (vcpufd == -1)\n        err(1, \"KVM_CREATE_VCPU\");\n\n    // 获取 KVM 运行时结构的大小\n    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_VCPU_MMAP_SIZE\");\n    mmap_size = ret;\n    if (mmap_size < sizeof(*run))\n        errx(1, \"KVM_GET_VCPU_MMAP_SIZE unexpectedly small\");\n    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息\n    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);\n    if (!run)\n        err(1, \"mmap vcpu\");\n\n    // 获取特殊寄存器\n    ret = ioctl(vcpufd, KVM_GET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_GET_SREGS\");\n    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置\n    sregs.cs.base = 0;\n    sregs.cs.selector = 0;\n    // KVM_SET_SREGS 设置特殊寄存器\n    ret = ioctl(vcpufd, KVM_SET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_SET_SREGS\");\n\n\n    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。\n    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令\n    struct kvm_regs regs = {\n        .rip = 0x1000,\n        .rax = 2,    // 设置 ax 寄存器初始值为 2\n        .rbx = 2,    // 同理\n        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错\n    };\n    ret = ioctl(vcpufd, KVM_SET_REGS, &regs);\n    if (ret == -1)\n        err(1, \"KVM_SET_REGS\");\n\n    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令\n    while (1) {\n        // 开始运行虚拟机\n        ret = ioctl(vcpufd, KVM_RUN, NULL);\n        if (ret == -1)\n            err(1, \"KVM_RUN\");\n        // 获取虚拟机退出原因\n        switch (run->exit_reason) {\n        case KVM_EXIT_HLT:\n            puts(\"KVM_EXIT_HLT\");\n            return 0;\n        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以\n        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器\n        // 后面CPU虚拟化会讲到这部分\n        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到\n        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备\n        case KVM_EXIT_IO:\n            if (run->io.direction == KVM_EXIT_IO_OUT && run->io.size == 1 && run->io.port == 0x3f8 && run->io.count == 1)\n                putchar(*(((char *)run) + run->io.data_offset));\n            else\n                errx(1, \"unhandled KVM_EXIT_IO\");\n            break;\n        case KVM_EXIT_FAIL_ENTRY:\n            errx(1, \"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx\",\n                 (unsigned long long)run->fail_entry.hardware_entry_failure_reason);\n        case KVM_EXIT_INTERNAL_ERROR:\n            errx(1, \"KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x\", run->internal.suberror);\n        default:\n            errx(1, \"exit_reason = 0x%x\", run->exit_reason);\n        }\n    }\n}\n```\n\n编译并运行这个demo\n\n```hljs\ngcc -g demo.c -o demo\n➜  demo1 ./demo\n4\nKVM_EXIT_HLT\n```\n\n## 另外一个简单的QEMU emulator demo\n\n[IBM的徐同学有做过介绍](http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/)，在此基础上我再详细介绍一下qemu-kvm的启动过程。\n\n```hljs\n.globl _start\n    .code16\n_start:\n    xorw %ax, %ax   # 将 ax 寄存器清零\n\nloop1:\n    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&t汇编的操作数和Intel的相反。\n    inc %ax         # ax 值加一\n    jmp loop1       # 继续循环\n```\n\n这个汇编的作用就是一直不停的向0x10端口输出一字节的值。\n\n从main函数开始说起\n\n```hljs\nint main(int argc, char **argv) {\n    int ret = 0;\n    // 初始化kvm结构体\n    struct kvm *kvm = kvm_init();\n\n    if (kvm == NULL) {\n        fprintf(stderr, \"kvm init fauilt\\n\");\n        return -1;\n    }\n\n    // 创建VM，并分配内存空间\n    if (kvm_create_vm(kvm, RAM_SIZE) < 0) {\n        fprintf(stderr, \"create vm fault\\n\");\n        return -1;\n    }\n\n    // 加载镜像\n    load_binary(kvm);\n\n    // only support one vcpu now\n    kvm->vcpu_number = 1;\n    // 创建执行现场\n    kvm->vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);\n\n    // 启动虚拟机\n    kvm_run_vm(kvm);\n\n    kvm_clean_vm(kvm);\n    kvm_clean_vcpu(kvm->vcpus);\n    kvm_clean(kvm);\n}\n```\n\n第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。\n\n```hljs\nstruct kvm {\n   int dev_fd;              // /dev/kvm 的句柄\n   int vm_fd;               // GUEST 的句柄\n   __u64 ram_size;          // GUEST 的内存大小\n   __u64 ram_start;         // GUEST 的内存起始地址，\n                            // 这个地址是qemu emulator通过mmap映射的地址\n\n   int kvm_version;         \n   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、\n                                           // 允许对guest的地址做分段。将多个slot组成线性地址\n\n   struct vcpu *vcpus;      // vcpu 数组\n   int vcpu_number;         // vcpu 个数\n};\n```\n\n初始化 kvm 结构体。\n\n```hljs\nstruct kvm *kvm_init(void) {\n    struct kvm *kvm = malloc(sizeof(struct kvm));\n    kvm->dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄\n\n    if (kvm->dev_fd < 0) {\n        perror(\"open kvm device fault: \");\n        return NULL;\n    }\n\n    kvm->kvm_version = ioctl(kvm->dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本\n\n    return kvm;\n}\n```\n\n第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。\n\n```hljs\nint kvm_create_vm(struct kvm *kvm, int ram_size) {\n    int ret = 0;\n    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄\n    kvm->vm_fd = ioctl(kvm->dev_fd, KVM_CREATE_VM, 0);\n\n    if (kvm->vm_fd < 0) {\n        perror(\"can not create vm\");\n        return -1;\n    }\n\n    // 为 kvm 分配内存。通过系统调用.\n    kvm->ram_size = ram_size;\n    kvm->ram_start =  (__u64)mmap(NULL, kvm->ram_size, \n                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, \n                -1, 0);\n\n    if ((void *)kvm->ram_start == MAP_FAILED) {\n        perror(\"can not mmap ram\");\n        return -1;\n    }\n\n    // kvm->mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口\n    // 只有一个内存槽\n    kvm->mem.slot = 0;\n    // guest 物理内存起始地址\n    kvm->mem.guest_phys_addr = 0;\n    // 虚拟机内存大小\n    kvm->mem.memory_size = kvm->ram_size;\n    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest\n    kvm->mem.userspace_addr = kvm->ram_start;\n\n    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。\n    ret = ioctl(kvm->vm_fd, KVM_SET_USER_MEMORY_REGION, &(kvm->mem));\n\n    if (ret < 0) {\n        perror(\"can not set user memory region\");\n        return ret;\n    }\n    return ret;\n}\n```\n\n接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。\n\n```hljs\nvoid load_binary(struct kvm *kvm) {\n    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）\n\n    if (fd < 0) {\n        fprintf(stderr, \"can not open binary file\\n\");\n        exit(1);\n    }\n\n    int ret = 0;\n    char *p = (char *)kvm->ram_start;\n\n    while(1) {\n        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中\n        if (ret <= 0) {\n            break;\n        }\n        printf(\"read size: %d\", ret);\n        p += ret;\n    }\n}\n```\n\n加载完镜像后，需要初始化vCPU，以便能够运行镜像内容\n\n```hljs\nstruct vcpu {\n    int vcpu_id;                 // vCPU id，vCPU\n    int vcpu_fd;                 // vCPU 句柄\n    pthread_t vcpu_thread;       // vCPU 线程句柄\n    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文\n    int kvm_run_mmap_size;       // 运行时结构大小\n    struct kvm_regs regs;        // vCPU的寄存器\n    struct kvm_sregs sregs;      // vCPU的特殊寄存器\n    void *(*vcpu_thread_func)(void *);  // 线程执行函数\n};\n\nstruct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) {\n    // 申请vcpu结构\n    struct vcpu *vcpu = malloc(sizeof(struct vcpu));\n    // 只有一个 vCPU，所以这里只初始化一个\n    vcpu->vcpu_id = 0;\n    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm->vm_fd（由KVM_CREATE_VM返回）\n    vcpu->vcpu_fd = ioctl(kvm->vm_fd, KVM_CREATE_VCPU, vcpu->vcpu_id);\n\n    if (vcpu->vcpu_fd < 0) {\n        perror(\"can not create vcpu\");\n        return NULL;\n    }\n\n    // 获取KVM运行时结构大小\n    vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (vcpu->kvm_run_mmap_size < 0) {\n        perror(\"can not get vcpu mmsize\");\n        return NULL;\n    }\n\n    printf(\"%d\\n\", vcpu->kvm_run_mmap_size);\n    // 将 vcpu_fd 的内存映射给 vcpu->kvm_run结构。相当于一个关联操作\n    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息\n    vcpu->kvm_run = mmap(NULL, vcpu->kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu->vcpu_fd, 0);\n\n    if (vcpu->kvm_run == MAP_FAILED) {\n        perror(\"can not mmap kvm_run\");\n        return NULL;\n    }\n\n    // 设置线程执行函数\n    vcpu->vcpu_thread_func = fn;\n    return vcpu;\n}\n```\n\n最后一步，以上工作就绪后，启动虚拟机。\n\n```hljs\nvoid kvm_run_vm(struct kvm *kvm) {\n    int i = 0;\n\n    for (i = 0; i < kvm->vcpu_number; i++) {\n        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程\n        if (pthread_create(&(kvm->vcpus->vcpu_thread), (const pthread_attr_t *)NULL, kvm->vcpus[i].vcpu_thread_func, kvm) != 0) {\n            perror(\"can not create kvm thread\");\n            exit(1);\n        }\n    }\n\n    pthread_join(kvm->vcpus->vcpu_thread, NULL);\n}\n```\n\n启动虚拟机其实就是创建线程，并执行相应的线程回调函数。  \n线程回调函数在kvm_init_vcpu的时候传入\n\n```hljs\nvoid *kvm_cpu_thread(void *data) {\n    // 获取参数\n    struct kvm *kvm = (struct kvm *)data;\n    int ret = 0;\n    // 设置KVM的参数\n    kvm_reset_vcpu(kvm->vcpus);\n\n    while (1) {\n        printf(\"KVM start run\\n\");\n        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。\n        ret = ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n\n        if (ret < 0) {\n            fprintf(stderr, \"KVM_RUN failed\\n\");\n            exit(1);\n        }\n\n        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存\n        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因\n        switch (kvm->vcpus->kvm_run->exit_reason) {\n        case KVM_EXIT_UNKNOWN:\n            printf(\"KVM_EXIT_UNKNOWN\\n\");\n            break;\n        case KVM_EXIT_DEBUG:\n            printf(\"KVM_EXIT_DEBUG\\n\");\n            break;\n        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并\n        // 把执行权交给emulator\n        case KVM_EXIT_IO:\n            printf(\"KVM_EXIT_IO\\n\");\n            printf(\"out port: %d, data: %d\\n\", \n                kvm->vcpus->kvm_run->io.port,  \n                *(int *)((char *)(kvm->vcpus->kvm_run) + kvm->vcpus->kvm_run->io.data_offset)\n                );\n            sleep(1);\n            break;\n        // 虚拟机执行了memory map IO操作\n        case KVM_EXIT_MMIO:\n            printf(\"KVM_EXIT_MMIO\\n\");\n            break;\n        case KVM_EXIT_INTR:\n            printf(\"KVM_EXIT_INTR\\n\");\n            break;\n        case KVM_EXIT_SHUTDOWN:\n            printf(\"KVM_EXIT_SHUTDOWN\\n\");\n            goto exit_kvm;\n            break;\n        default:\n            printf(\"KVM PANIC\\n\");\n            goto exit_kvm;\n        }\n    }\n\nexit_kvm:\n    return 0;\n}\n\nvoid kvm_reset_vcpu (struct vcpu *vcpu) {\n    if (ioctl(vcpu->vcpu_fd, KVM_GET_SREGS, &(vcpu->sregs)) < 0) {\n        perror(\"can not get sregs\\n\");\n        exit(1);\n    }\n    // #define CODE_START 0x1000\n    /* sregs 结构体\n        x86\n        struct kvm_sregs {\n            struct kvm_segment cs, ds, es, fs, gs, ss;\n            struct kvm_segment tr, ldt;\n            struct kvm_dtable gdt, idt;\n            __u64 cr0, cr2, cr3, cr4, cr8;\n            __u64 efer;\n            __u64 apic_base;\n            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];\n        };\n    */\n    // cs 为code start寄存器，存放了程序的起始地址\n    vcpu->sregs.cs.selector = CODE_START;\n    vcpu->sregs.cs.base = CODE_START * 16;\n    // ss 为堆栈寄存器，存放了堆栈的起始位置\n    vcpu->sregs.ss.selector = CODE_START;\n    vcpu->sregs.ss.base = CODE_START * 16;\n    // ds 为数据段寄存器，存放了数据开始地址\n    vcpu->sregs.ds.selector = CODE_START;\n    vcpu->sregs.ds.base = CODE_START *16;\n    // es 为附加段寄存器\n    vcpu->sregs.es.selector = CODE_START;\n    vcpu->sregs.es.base = CODE_START * 16;\n    // fs, gs 同样为段寄存器\n    vcpu->sregs.fs.selector = CODE_START;\n    vcpu->sregs.fs.base = CODE_START * 16;\n    vcpu->sregs.gs.selector = CODE_START;\n\n    // 为vCPU设置以上寄存器的值\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_SREGS, &vcpu->sregs) < 0) {\n        perror(\"can not set sregs\");\n        exit(1);\n    }\n\n    // 设置寄存器标志位\n    vcpu->regs.rflags = 0x0000000000000002ULL;\n    // rip 表示了程序的起始指针，地址为 0x0000000\n    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位\n    // 所以虚拟机开始的时候会直接运行binary\n    vcpu->regs.rip = 0;\n    // rsp 为堆栈顶\n    vcpu->regs.rsp = 0xffffffff;\n    // rbp 为堆栈底部\n    vcpu->regs.rbp= 0;\n\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_REGS, &(vcpu->regs)) < 0) {\n        perror(\"KVM SET REGS\\n\");\n        exit(1);\n    }\n}\n```\n\n运行一下结果，可以看到当虚拟机执行了指令 `out %ax, $0x10` 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。  \n宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。\n\n```hljs\n➜  kvmsample git:(master) ✗ ./kvmsample\nread size: 712288\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 0\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 1\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 2\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 3\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 4\n...\n```\n\n## 总结\n\n虚拟机的启动过程基本上可以这么总结：  \n创建kvm句柄->创建vm->分配内存->加载镜像到内存->启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。\n\n当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。\n","source":"_posts/kvm-boot.md","raw":"title: KVM 虚拟化原理2— QEMU启动过程\ndonate: true\ndate: 2018-12-10 22:57:17\ncategories: KVM\ntags: KVM\n---\n\n## 虚拟机启动过程\n\n```hljs\n第一步，获取到kvm句柄\nkvmfd = open(\"/dev/kvm\", O_RDWR);\n第二步，创建虚拟机，获取到虚拟机句柄。\nvmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);\n第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。\nioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);\n第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。\n第五步，创建vCPU，并为vCPU分配内存空间。\nioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);\nvcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n第五步，创建vCPU个数的线程并运行虚拟机。\nioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。\n这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。\n```\n\n```hljs\nopen(\"/dev/kvm\")\nioctl(KVM_CREATE_VM)\nioctl(KVM_CREATE_VCPU)\nfor (;;) {\n     ioctl(KVM_RUN)\n     switch (exit_reason) {\n     case KVM_EXIT_IO:  /* ... */\n     case KVM_EXIT_HLT: /* ... */\n     }\n}\n```\n\n关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。\n\n[KVM ioctl接口文档](https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt)\n\n## 先来一个KVM API开胃菜\n\n下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.  \n这是一个at&t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。  \n这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。  \n最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。  \n4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出\n\n```hljs\n.globl _start\n    .code16\n_start:\n    mov $0x3f8, %dx\n    add %bl, %al\n    add $'0', %al\n    out %al, (%dx)\n    mov $'\\n', %al\n    out %al, (%dx)\n    hlt\n```\n\n我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件\n\n```hljs\nas -32 bin.S -o bin.o\nld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o\n```\n\n查看一下二进制格式\n\n```hljs\n➜  demo1 hexdump -C bin.bin\n00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|\n0000000c\n对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n```\n\n```hljs\n#include <err.h>\n#include <fcntl.h>\n#include <linux/kvm.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int kvm, vmfd, vcpufd, ret;\n    const uint8_t code[] = {\n        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */\n        0x00, 0xd8,       /* add %bl, %al */\n        0x04, '0',        /* add $'0', %al */\n        0xee,             /* out %al, (%dx) */\n        0xb0, '\\n',       /* mov $'\\n', %al */\n        0xee,             /* out %al, (%dx) */\n        0xf4,             /* hlt */\n    };\n    uint8_t *mem;\n    struct kvm_sregs sregs;\n    size_t mmap_size;\n    struct kvm_run *run;\n\n    // 获取 kvm 句柄\n    kvm = open(\"/dev/kvm\", O_RDWR | O_CLOEXEC);\n    if (kvm == -1)\n        err(1, \"/dev/kvm\");\n\n    // 确保是正确的 API 版本\n    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_API_VERSION\");\n    if (ret != 12)\n        errx(1, \"KVM_GET_API_VERSION %d, expected 12\", ret);\n\n    // 创建一虚拟机\n    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);\n    if (vmfd == -1)\n        err(1, \"KVM_CREATE_VM\");\n\n    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中\n    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if (!mem)\n        err(1, \"allocating guest memory\");\n    memcpy(mem, code, sizeof(code));\n\n    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录\n    struct kvm_userspace_memory_region region = {\n        .slot = 0,\n        .guest_phys_addr = 0x1000,\n        .memory_size = 0x1000,\n        .userspace_addr = (uint64_t)mem,\n    };\n    // 设置 KVM 的内存区域\n    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &region);\n    if (ret == -1)\n        err(1, \"KVM_SET_USER_MEMORY_REGION\");\n\n    // 创建虚拟CPU\n    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);\n    if (vcpufd == -1)\n        err(1, \"KVM_CREATE_VCPU\");\n\n    // 获取 KVM 运行时结构的大小\n    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);\n    if (ret == -1)\n        err(1, \"KVM_GET_VCPU_MMAP_SIZE\");\n    mmap_size = ret;\n    if (mmap_size < sizeof(*run))\n        errx(1, \"KVM_GET_VCPU_MMAP_SIZE unexpectedly small\");\n    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息\n    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);\n    if (!run)\n        err(1, \"mmap vcpu\");\n\n    // 获取特殊寄存器\n    ret = ioctl(vcpufd, KVM_GET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_GET_SREGS\");\n    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置\n    sregs.cs.base = 0;\n    sregs.cs.selector = 0;\n    // KVM_SET_SREGS 设置特殊寄存器\n    ret = ioctl(vcpufd, KVM_SET_SREGS, &sregs);\n    if (ret == -1)\n        err(1, \"KVM_SET_SREGS\");\n\n\n    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。\n    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令\n    struct kvm_regs regs = {\n        .rip = 0x1000,\n        .rax = 2,    // 设置 ax 寄存器初始值为 2\n        .rbx = 2,    // 同理\n        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错\n    };\n    ret = ioctl(vcpufd, KVM_SET_REGS, &regs);\n    if (ret == -1)\n        err(1, \"KVM_SET_REGS\");\n\n    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令\n    while (1) {\n        // 开始运行虚拟机\n        ret = ioctl(vcpufd, KVM_RUN, NULL);\n        if (ret == -1)\n            err(1, \"KVM_RUN\");\n        // 获取虚拟机退出原因\n        switch (run->exit_reason) {\n        case KVM_EXIT_HLT:\n            puts(\"KVM_EXIT_HLT\");\n            return 0;\n        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以\n        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器\n        // 后面CPU虚拟化会讲到这部分\n        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到\n        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备\n        case KVM_EXIT_IO:\n            if (run->io.direction == KVM_EXIT_IO_OUT && run->io.size == 1 && run->io.port == 0x3f8 && run->io.count == 1)\n                putchar(*(((char *)run) + run->io.data_offset));\n            else\n                errx(1, \"unhandled KVM_EXIT_IO\");\n            break;\n        case KVM_EXIT_FAIL_ENTRY:\n            errx(1, \"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx\",\n                 (unsigned long long)run->fail_entry.hardware_entry_failure_reason);\n        case KVM_EXIT_INTERNAL_ERROR:\n            errx(1, \"KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x\", run->internal.suberror);\n        default:\n            errx(1, \"exit_reason = 0x%x\", run->exit_reason);\n        }\n    }\n}\n```\n\n编译并运行这个demo\n\n```hljs\ngcc -g demo.c -o demo\n➜  demo1 ./demo\n4\nKVM_EXIT_HLT\n```\n\n## 另外一个简单的QEMU emulator demo\n\n[IBM的徐同学有做过介绍](http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/)，在此基础上我再详细介绍一下qemu-kvm的启动过程。\n\n```hljs\n.globl _start\n    .code16\n_start:\n    xorw %ax, %ax   # 将 ax 寄存器清零\n\nloop1:\n    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&t汇编的操作数和Intel的相反。\n    inc %ax         # ax 值加一\n    jmp loop1       # 继续循环\n```\n\n这个汇编的作用就是一直不停的向0x10端口输出一字节的值。\n\n从main函数开始说起\n\n```hljs\nint main(int argc, char **argv) {\n    int ret = 0;\n    // 初始化kvm结构体\n    struct kvm *kvm = kvm_init();\n\n    if (kvm == NULL) {\n        fprintf(stderr, \"kvm init fauilt\\n\");\n        return -1;\n    }\n\n    // 创建VM，并分配内存空间\n    if (kvm_create_vm(kvm, RAM_SIZE) < 0) {\n        fprintf(stderr, \"create vm fault\\n\");\n        return -1;\n    }\n\n    // 加载镜像\n    load_binary(kvm);\n\n    // only support one vcpu now\n    kvm->vcpu_number = 1;\n    // 创建执行现场\n    kvm->vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);\n\n    // 启动虚拟机\n    kvm_run_vm(kvm);\n\n    kvm_clean_vm(kvm);\n    kvm_clean_vcpu(kvm->vcpus);\n    kvm_clean(kvm);\n}\n```\n\n第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。\n\n```hljs\nstruct kvm {\n   int dev_fd;              // /dev/kvm 的句柄\n   int vm_fd;               // GUEST 的句柄\n   __u64 ram_size;          // GUEST 的内存大小\n   __u64 ram_start;         // GUEST 的内存起始地址，\n                            // 这个地址是qemu emulator通过mmap映射的地址\n\n   int kvm_version;         \n   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、\n                                           // 允许对guest的地址做分段。将多个slot组成线性地址\n\n   struct vcpu *vcpus;      // vcpu 数组\n   int vcpu_number;         // vcpu 个数\n};\n```\n\n初始化 kvm 结构体。\n\n```hljs\nstruct kvm *kvm_init(void) {\n    struct kvm *kvm = malloc(sizeof(struct kvm));\n    kvm->dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄\n\n    if (kvm->dev_fd < 0) {\n        perror(\"open kvm device fault: \");\n        return NULL;\n    }\n\n    kvm->kvm_version = ioctl(kvm->dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本\n\n    return kvm;\n}\n```\n\n第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。\n\n```hljs\nint kvm_create_vm(struct kvm *kvm, int ram_size) {\n    int ret = 0;\n    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄\n    kvm->vm_fd = ioctl(kvm->dev_fd, KVM_CREATE_VM, 0);\n\n    if (kvm->vm_fd < 0) {\n        perror(\"can not create vm\");\n        return -1;\n    }\n\n    // 为 kvm 分配内存。通过系统调用.\n    kvm->ram_size = ram_size;\n    kvm->ram_start =  (__u64)mmap(NULL, kvm->ram_size, \n                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, \n                -1, 0);\n\n    if ((void *)kvm->ram_start == MAP_FAILED) {\n        perror(\"can not mmap ram\");\n        return -1;\n    }\n\n    // kvm->mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口\n    // 只有一个内存槽\n    kvm->mem.slot = 0;\n    // guest 物理内存起始地址\n    kvm->mem.guest_phys_addr = 0;\n    // 虚拟机内存大小\n    kvm->mem.memory_size = kvm->ram_size;\n    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest\n    kvm->mem.userspace_addr = kvm->ram_start;\n\n    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。\n    ret = ioctl(kvm->vm_fd, KVM_SET_USER_MEMORY_REGION, &(kvm->mem));\n\n    if (ret < 0) {\n        perror(\"can not set user memory region\");\n        return ret;\n    }\n    return ret;\n}\n```\n\n接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。\n\n```hljs\nvoid load_binary(struct kvm *kvm) {\n    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）\n\n    if (fd < 0) {\n        fprintf(stderr, \"can not open binary file\\n\");\n        exit(1);\n    }\n\n    int ret = 0;\n    char *p = (char *)kvm->ram_start;\n\n    while(1) {\n        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中\n        if (ret <= 0) {\n            break;\n        }\n        printf(\"read size: %d\", ret);\n        p += ret;\n    }\n}\n```\n\n加载完镜像后，需要初始化vCPU，以便能够运行镜像内容\n\n```hljs\nstruct vcpu {\n    int vcpu_id;                 // vCPU id，vCPU\n    int vcpu_fd;                 // vCPU 句柄\n    pthread_t vcpu_thread;       // vCPU 线程句柄\n    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文\n    int kvm_run_mmap_size;       // 运行时结构大小\n    struct kvm_regs regs;        // vCPU的寄存器\n    struct kvm_sregs sregs;      // vCPU的特殊寄存器\n    void *(*vcpu_thread_func)(void *);  // 线程执行函数\n};\n\nstruct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) {\n    // 申请vcpu结构\n    struct vcpu *vcpu = malloc(sizeof(struct vcpu));\n    // 只有一个 vCPU，所以这里只初始化一个\n    vcpu->vcpu_id = 0;\n    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm->vm_fd（由KVM_CREATE_VM返回）\n    vcpu->vcpu_fd = ioctl(kvm->vm_fd, KVM_CREATE_VCPU, vcpu->vcpu_id);\n\n    if (vcpu->vcpu_fd < 0) {\n        perror(\"can not create vcpu\");\n        return NULL;\n    }\n\n    // 获取KVM运行时结构大小\n    vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (vcpu->kvm_run_mmap_size < 0) {\n        perror(\"can not get vcpu mmsize\");\n        return NULL;\n    }\n\n    printf(\"%d\\n\", vcpu->kvm_run_mmap_size);\n    // 将 vcpu_fd 的内存映射给 vcpu->kvm_run结构。相当于一个关联操作\n    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息\n    vcpu->kvm_run = mmap(NULL, vcpu->kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu->vcpu_fd, 0);\n\n    if (vcpu->kvm_run == MAP_FAILED) {\n        perror(\"can not mmap kvm_run\");\n        return NULL;\n    }\n\n    // 设置线程执行函数\n    vcpu->vcpu_thread_func = fn;\n    return vcpu;\n}\n```\n\n最后一步，以上工作就绪后，启动虚拟机。\n\n```hljs\nvoid kvm_run_vm(struct kvm *kvm) {\n    int i = 0;\n\n    for (i = 0; i < kvm->vcpu_number; i++) {\n        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程\n        if (pthread_create(&(kvm->vcpus->vcpu_thread), (const pthread_attr_t *)NULL, kvm->vcpus[i].vcpu_thread_func, kvm) != 0) {\n            perror(\"can not create kvm thread\");\n            exit(1);\n        }\n    }\n\n    pthread_join(kvm->vcpus->vcpu_thread, NULL);\n}\n```\n\n启动虚拟机其实就是创建线程，并执行相应的线程回调函数。  \n线程回调函数在kvm_init_vcpu的时候传入\n\n```hljs\nvoid *kvm_cpu_thread(void *data) {\n    // 获取参数\n    struct kvm *kvm = (struct kvm *)data;\n    int ret = 0;\n    // 设置KVM的参数\n    kvm_reset_vcpu(kvm->vcpus);\n\n    while (1) {\n        printf(\"KVM start run\\n\");\n        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。\n        ret = ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n\n        if (ret < 0) {\n            fprintf(stderr, \"KVM_RUN failed\\n\");\n            exit(1);\n        }\n\n        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存\n        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因\n        switch (kvm->vcpus->kvm_run->exit_reason) {\n        case KVM_EXIT_UNKNOWN:\n            printf(\"KVM_EXIT_UNKNOWN\\n\");\n            break;\n        case KVM_EXIT_DEBUG:\n            printf(\"KVM_EXIT_DEBUG\\n\");\n            break;\n        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并\n        // 把执行权交给emulator\n        case KVM_EXIT_IO:\n            printf(\"KVM_EXIT_IO\\n\");\n            printf(\"out port: %d, data: %d\\n\", \n                kvm->vcpus->kvm_run->io.port,  \n                *(int *)((char *)(kvm->vcpus->kvm_run) + kvm->vcpus->kvm_run->io.data_offset)\n                );\n            sleep(1);\n            break;\n        // 虚拟机执行了memory map IO操作\n        case KVM_EXIT_MMIO:\n            printf(\"KVM_EXIT_MMIO\\n\");\n            break;\n        case KVM_EXIT_INTR:\n            printf(\"KVM_EXIT_INTR\\n\");\n            break;\n        case KVM_EXIT_SHUTDOWN:\n            printf(\"KVM_EXIT_SHUTDOWN\\n\");\n            goto exit_kvm;\n            break;\n        default:\n            printf(\"KVM PANIC\\n\");\n            goto exit_kvm;\n        }\n    }\n\nexit_kvm:\n    return 0;\n}\n\nvoid kvm_reset_vcpu (struct vcpu *vcpu) {\n    if (ioctl(vcpu->vcpu_fd, KVM_GET_SREGS, &(vcpu->sregs)) < 0) {\n        perror(\"can not get sregs\\n\");\n        exit(1);\n    }\n    // #define CODE_START 0x1000\n    /* sregs 结构体\n        x86\n        struct kvm_sregs {\n            struct kvm_segment cs, ds, es, fs, gs, ss;\n            struct kvm_segment tr, ldt;\n            struct kvm_dtable gdt, idt;\n            __u64 cr0, cr2, cr3, cr4, cr8;\n            __u64 efer;\n            __u64 apic_base;\n            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];\n        };\n    */\n    // cs 为code start寄存器，存放了程序的起始地址\n    vcpu->sregs.cs.selector = CODE_START;\n    vcpu->sregs.cs.base = CODE_START * 16;\n    // ss 为堆栈寄存器，存放了堆栈的起始位置\n    vcpu->sregs.ss.selector = CODE_START;\n    vcpu->sregs.ss.base = CODE_START * 16;\n    // ds 为数据段寄存器，存放了数据开始地址\n    vcpu->sregs.ds.selector = CODE_START;\n    vcpu->sregs.ds.base = CODE_START *16;\n    // es 为附加段寄存器\n    vcpu->sregs.es.selector = CODE_START;\n    vcpu->sregs.es.base = CODE_START * 16;\n    // fs, gs 同样为段寄存器\n    vcpu->sregs.fs.selector = CODE_START;\n    vcpu->sregs.fs.base = CODE_START * 16;\n    vcpu->sregs.gs.selector = CODE_START;\n\n    // 为vCPU设置以上寄存器的值\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_SREGS, &vcpu->sregs) < 0) {\n        perror(\"can not set sregs\");\n        exit(1);\n    }\n\n    // 设置寄存器标志位\n    vcpu->regs.rflags = 0x0000000000000002ULL;\n    // rip 表示了程序的起始指针，地址为 0x0000000\n    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位\n    // 所以虚拟机开始的时候会直接运行binary\n    vcpu->regs.rip = 0;\n    // rsp 为堆栈顶\n    vcpu->regs.rsp = 0xffffffff;\n    // rbp 为堆栈底部\n    vcpu->regs.rbp= 0;\n\n    if (ioctl(vcpu->vcpu_fd, KVM_SET_REGS, &(vcpu->regs)) < 0) {\n        perror(\"KVM SET REGS\\n\");\n        exit(1);\n    }\n}\n```\n\n运行一下结果，可以看到当虚拟机执行了指令 `out %ax, $0x10` 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。  \n宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。\n\n```hljs\n➜  kvmsample git:(master) ✗ ./kvmsample\nread size: 712288\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 0\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 1\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 2\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 3\nKVM start run\nKVM_EXIT_IO\nout port: 16, data: 4\n...\n```\n\n## 总结\n\n虚拟机的启动过程基本上可以这么总结：  \n创建kvm句柄->创建vm->分配内存->加载镜像到内存->启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。\n\n当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。\n","slug":"kvm-boot","published":1,"updated":"2018-12-11T02:32:50.364Z","_id":"cjpj2qxl10004y0o4ettba52g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"虚拟机启动过程\"><a href=\"#虚拟机启动过程\" class=\"headerlink\" title=\"虚拟机启动过程\"></a>虚拟机启动过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步，获取到kvm句柄</span><br><span class=\"line\">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class=\"line\">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class=\"line\">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class=\"line\">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class=\"line\">ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class=\"line\">第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。</span><br><span class=\"line\">第五步，创建vCPU，并为vCPU分配内存空间。</span><br><span class=\"line\">ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);</span><br><span class=\"line\">vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\">第五步，创建vCPU个数的线程并运行虚拟机。</span><br><span class=\"line\">ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\">第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class=\"line\">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/kvm&quot;)</span><br><span class=\"line\">ioctl(KVM_CREATE_VM)</span><br><span class=\"line\">ioctl(KVM_CREATE_VCPU)</span><br><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">     ioctl(KVM_RUN)</span><br><span class=\"line\">     switch (exit_reason) &#123;</span><br><span class=\"line\">     case KVM_EXIT_IO:  /* ... */</span><br><span class=\"line\">     case KVM_EXIT_HLT: /* ... */</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt\" target=\"_blank\" rel=\"noopener\">KVM ioctl接口文档</a></p>\n<h2 id=\"先来一个KVM-API开胃菜\"><a href=\"#先来一个KVM-API开胃菜\" class=\"headerlink\" title=\"先来一个KVM API开胃菜\"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    mov $0x3f8, %dx</span><br><span class=\"line\">    add %bl, %al</span><br><span class=\"line\">    add $&apos;0&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    mov $&apos;\\n&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    hlt</span><br></pre></td></tr></table></figure>\n<p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as -32 bin.S -o bin.o</span><br><span class=\"line\">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure>\n<p>查看一下二进制格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  demo1 hexdump -C bin.bin</span><br><span class=\"line\">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class=\"line\">0000000c</span><br><span class=\"line\">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;err.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;linux/kvm.h&gt;</span><br><span class=\"line\">#include &lt;stdint.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;</span><br><span class=\"line\">#include &lt;sys/mman.h&gt;</span><br><span class=\"line\">#include &lt;sys/stat.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int kvm, vmfd, vcpufd, ret;</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uint8_t *mem;</span><br><span class=\"line\">    struct kvm_sregs sregs;</span><br><span class=\"line\">    size_t mmap_size;</span><br><span class=\"line\">    struct kvm_run *run;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 kvm 句柄</span><br><span class=\"line\">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class=\"line\">    if (kvm == -1)</span><br><span class=\"line\">        err(1, &quot;/dev/kvm&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 确保是正确的 API 版本</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class=\"line\">    if (ret != 12)</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一虚拟机</span><br><span class=\"line\">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class=\"line\">    if (vmfd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class=\"line\">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class=\"line\">    if (!mem)</span><br><span class=\"line\">        err(1, &quot;allocating guest memory&quot;);</span><br><span class=\"line\">    memcpy(mem, code, sizeof(code));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class=\"line\">    struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">        .slot = 0,</span><br><span class=\"line\">        .guest_phys_addr = 0x1000,</span><br><span class=\"line\">        .memory_size = 0x1000,</span><br><span class=\"line\">        .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 设置 KVM 的内存区域</span><br><span class=\"line\">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建虚拟CPU</span><br><span class=\"line\">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class=\"line\">    if (vcpufd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 KVM 运行时结构的大小</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class=\"line\">    mmap_size = ret;</span><br><span class=\"line\">    if (mmap_size &lt; sizeof(*run))</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class=\"line\">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息</span><br><span class=\"line\">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class=\"line\">    if (!run)</span><br><span class=\"line\">        err(1, &quot;mmap vcpu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class=\"line\">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class=\"line\">    sregs.cs.base = 0;</span><br><span class=\"line\">    sregs.cs.selector = 0;</span><br><span class=\"line\">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class=\"line\">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class=\"line\">    struct kvm_regs regs = &#123;</span><br><span class=\"line\">        .rip = 0x1000,</span><br><span class=\"line\">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class=\"line\">        .rbx = 2,    // 同理</span><br><span class=\"line\">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        // 开始运行虚拟机</span><br><span class=\"line\">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">            err(1, &quot;KVM_RUN&quot;);</span><br><span class=\"line\">        // 获取虚拟机退出原因</span><br><span class=\"line\">        switch (run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_HLT:</span><br><span class=\"line\">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class=\"line\">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class=\"line\">        // 后面CPU虚拟化会讲到这部分</span><br><span class=\"line\">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class=\"line\">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class=\"line\">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class=\"line\">            else</span><br><span class=\"line\">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class=\"line\">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class=\"line\">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译并运行这个demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g demo.c -o demo</span><br><span class=\"line\">➜  demo1 ./demo</span><br><span class=\"line\">4</span><br><span class=\"line\">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>\n<h2 id=\"另外一个简单的QEMU-emulator-demo\"><a href=\"#另外一个简单的QEMU-emulator-demo\" class=\"headerlink\" title=\"另外一个简单的QEMU emulator demo\"></a>另外一个简单的QEMU emulator demo</h2><p><a href=\"http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/\" target=\"_blank\" rel=\"noopener\">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class=\"line\"></span><br><span class=\"line\">loop1:</span><br><span class=\"line\">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class=\"line\">    inc %ax         # ax 值加一</span><br><span class=\"line\">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure>\n<p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p>\n<p>从main函数开始说起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char **argv) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 初始化kvm结构体</span><br><span class=\"line\">    struct kvm *kvm = kvm_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm == NULL) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;kvm init fauilt\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建VM，并分配内存空间</span><br><span class=\"line\">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;create vm fault\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加载镜像</span><br><span class=\"line\">    load_binary(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    // only support one vcpu now</span><br><span class=\"line\">    kvm-&gt;vcpu_number = 1;</span><br><span class=\"line\">    // 创建执行现场</span><br><span class=\"line\">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动虚拟机</span><br><span class=\"line\">    kvm_run_vm(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm_clean_vm(kvm);</span><br><span class=\"line\">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\">    kvm_clean(kvm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm &#123;</span><br><span class=\"line\">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class=\"line\">   int vm_fd;               // GUEST 的句柄</span><br><span class=\"line\">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class=\"line\">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class=\"line\">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class=\"line\"></span><br><span class=\"line\">   int kvm_version;         </span><br><span class=\"line\">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class=\"line\">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class=\"line\"></span><br><span class=\"line\">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class=\"line\">   int vcpu_number;         // vcpu 个数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>初始化 kvm 结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm *kvm_init(void) &#123;</span><br><span class=\"line\">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class=\"line\">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;open kvm device fault: &quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class=\"line\"></span><br><span class=\"line\">    return kvm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class=\"line\">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vm&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 kvm 分配内存。通过系统调用.</span><br><span class=\"line\">    kvm-&gt;ram_size = ram_size;</span><br><span class=\"line\">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class=\"line\">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class=\"line\">                -1, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap ram&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class=\"line\">    // 只有一个内存槽</span><br><span class=\"line\">    kvm-&gt;mem.slot = 0;</span><br><span class=\"line\">    // guest 物理内存起始地址</span><br><span class=\"line\">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class=\"line\">    // 虚拟机内存大小</span><br><span class=\"line\">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class=\"line\">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class=\"line\">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class=\"line\">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ret &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set user memory region&quot;);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_binary(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fd &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;can not open binary file\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class=\"line\">        if (ret &lt;= 0) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printf(&quot;read size: %d&quot;, ret);</span><br><span class=\"line\">        p += ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct vcpu &#123;</span><br><span class=\"line\">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class=\"line\">    int vcpu_fd;                 // vCPU 句柄</span><br><span class=\"line\">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class=\"line\">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class=\"line\">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class=\"line\">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class=\"line\">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class=\"line\">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class=\"line\">    // 申请vcpu结构</span><br><span class=\"line\">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class=\"line\">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class=\"line\">    vcpu-&gt;vcpu_id = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class=\"line\">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vcpu&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取KVM运行时结构大小</span><br><span class=\"line\">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class=\"line\">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class=\"line\">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class=\"line\">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置线程执行函数</span><br><span class=\"line\">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class=\"line\">    return vcpu;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一步，以上工作就绪后，启动虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class=\"line\">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class=\"line\">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class=\"line\">            perror(&quot;can not create kvm thread&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *kvm_cpu_thread(void *data) &#123;</span><br><span class=\"line\">    // 获取参数</span><br><span class=\"line\">    struct kvm *kvm = (struct kvm *)data;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 设置KVM的参数</span><br><span class=\"line\">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        printf(&quot;KVM start run\\n&quot;);</span><br><span class=\"line\">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class=\"line\">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (ret &lt; 0) &#123;</span><br><span class=\"line\">            fprintf(stderr, &quot;KVM_RUN failed\\n&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class=\"line\">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class=\"line\">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_UNKNOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_UNKNOWN\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_DEBUG:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_DEBUG\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class=\"line\">        // 把执行权交给emulator</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_IO\\n&quot;);</span><br><span class=\"line\">            printf(&quot;out port: %d, data: %d\\n&quot;, </span><br><span class=\"line\">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class=\"line\">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class=\"line\">                );</span><br><span class=\"line\">            sleep(1);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了memory map IO操作</span><br><span class=\"line\">        case KVM_EXIT_MMIO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_MMIO\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_INTR:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_INTR\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_SHUTDOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_SHUTDOWN\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            printf(&quot;KVM PANIC\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_kvm:</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get sregs\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // #define CODE_START 0x1000</span><br><span class=\"line\">    /* sregs 结构体</span><br><span class=\"line\">        x86</span><br><span class=\"line\">        struct kvm_sregs &#123;</span><br><span class=\"line\">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class=\"line\">            struct kvm_segment tr, ldt;</span><br><span class=\"line\">            struct kvm_dtable gdt, idt;</span><br><span class=\"line\">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class=\"line\">            __u64 efer;</span><br><span class=\"line\">            __u64 apic_base;</span><br><span class=\"line\">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class=\"line\">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class=\"line\">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class=\"line\">    // es 为附加段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class=\"line\">    // fs, gs 同样为段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class=\"line\">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为vCPU设置以上寄存器的值</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set sregs&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置寄存器标志位</span><br><span class=\"line\">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class=\"line\">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class=\"line\">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class=\"line\">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class=\"line\">    vcpu-&gt;regs.rip = 0;</span><br><span class=\"line\">    // rsp 为堆栈顶</span><br><span class=\"line\">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class=\"line\">    // rbp 为堆栈底部</span><br><span class=\"line\">    vcpu-&gt;regs.rbp= 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;KVM SET REGS\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class=\"line\">read size: 712288</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 0</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 1</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 2</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 3</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p>\n<p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"虚拟机启动过程\"><a href=\"#虚拟机启动过程\" class=\"headerlink\" title=\"虚拟机启动过程\"></a>虚拟机启动过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步，获取到kvm句柄</span><br><span class=\"line\">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class=\"line\">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class=\"line\">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class=\"line\">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class=\"line\">ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class=\"line\">第四步，将虚拟机镜像映射到内存，相当于物理机的boot过程，把镜像映射到内存。</span><br><span class=\"line\">第五步，创建vCPU，并为vCPU分配内存空间。</span><br><span class=\"line\">ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);</span><br><span class=\"line\">vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\">第五步，创建vCPU个数的线程并运行虚拟机。</span><br><span class=\"line\">ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\">第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class=\"line\">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/kvm&quot;)</span><br><span class=\"line\">ioctl(KVM_CREATE_VM)</span><br><span class=\"line\">ioctl(KVM_CREATE_VCPU)</span><br><span class=\"line\">for (;;) &#123;</span><br><span class=\"line\">     ioctl(KVM_RUN)</span><br><span class=\"line\">     switch (exit_reason) &#123;</span><br><span class=\"line\">     case KVM_EXIT_IO:  /* ... */</span><br><span class=\"line\">     case KVM_EXIT_HLT: /* ... */</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt\" target=\"_blank\" rel=\"noopener\">KVM ioctl接口文档</a></p>\n<h2 id=\"先来一个KVM-API开胃菜\"><a href=\"#先来一个KVM-API开胃菜\" class=\"headerlink\" title=\"先来一个KVM API开胃菜\"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\\n (并不直接输出\\n，而是换了一行），hlt 指令表示虚拟机退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    mov $0x3f8, %dx</span><br><span class=\"line\">    add %bl, %al</span><br><span class=\"line\">    add $&apos;0&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    mov $&apos;\\n&apos;, %al</span><br><span class=\"line\">    out %al, (%dx)</span><br><span class=\"line\">    hlt</span><br></pre></td></tr></table></figure>\n<p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as -32 bin.S -o bin.o</span><br><span class=\"line\">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure>\n<p>查看一下二进制格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  demo1 hexdump -C bin.bin</span><br><span class=\"line\">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class=\"line\">0000000c</span><br><span class=\"line\">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;err.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;linux/kvm.h&gt;</span><br><span class=\"line\">#include &lt;stdint.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;</span><br><span class=\"line\">#include &lt;sys/mman.h&gt;</span><br><span class=\"line\">#include &lt;sys/stat.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int kvm, vmfd, vcpufd, ret;</span><br><span class=\"line\">    const uint8_t code[] = &#123;</span><br><span class=\"line\">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class=\"line\">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class=\"line\">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xb0, &apos;\\n&apos;,       /* mov $&apos;\\n&apos;, %al */</span><br><span class=\"line\">        0xee,             /* out %al, (%dx) */</span><br><span class=\"line\">        0xf4,             /* hlt */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uint8_t *mem;</span><br><span class=\"line\">    struct kvm_sregs sregs;</span><br><span class=\"line\">    size_t mmap_size;</span><br><span class=\"line\">    struct kvm_run *run;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 kvm 句柄</span><br><span class=\"line\">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class=\"line\">    if (kvm == -1)</span><br><span class=\"line\">        err(1, &quot;/dev/kvm&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 确保是正确的 API 版本</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class=\"line\">    if (ret != 12)</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建一虚拟机</span><br><span class=\"line\">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class=\"line\">    if (vmfd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class=\"line\">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class=\"line\">    if (!mem)</span><br><span class=\"line\">        err(1, &quot;allocating guest memory&quot;);</span><br><span class=\"line\">    memcpy(mem, code, sizeof(code));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class=\"line\">    struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">        .slot = 0,</span><br><span class=\"line\">        .guest_phys_addr = 0x1000,</span><br><span class=\"line\">        .memory_size = 0x1000,</span><br><span class=\"line\">        .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 设置 KVM 的内存区域</span><br><span class=\"line\">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建虚拟CPU</span><br><span class=\"line\">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class=\"line\">    if (vcpufd == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取 KVM 运行时结构的大小</span><br><span class=\"line\">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class=\"line\">    mmap_size = ret;</span><br><span class=\"line\">    if (mmap_size &lt; sizeof(*run))</span><br><span class=\"line\">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class=\"line\">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息</span><br><span class=\"line\">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class=\"line\">    if (!run)</span><br><span class=\"line\">        err(1, &quot;mmap vcpu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class=\"line\">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class=\"line\">    sregs.cs.base = 0;</span><br><span class=\"line\">    sregs.cs.selector = 0;</span><br><span class=\"line\">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class=\"line\">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class=\"line\">    struct kvm_regs regs = &#123;</span><br><span class=\"line\">        .rip = 0x1000,</span><br><span class=\"line\">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class=\"line\">        .rbx = 2,    // 同理</span><br><span class=\"line\">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class=\"line\">    if (ret == -1)</span><br><span class=\"line\">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        // 开始运行虚拟机</span><br><span class=\"line\">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">            err(1, &quot;KVM_RUN&quot;);</span><br><span class=\"line\">        // 获取虚拟机退出原因</span><br><span class=\"line\">        switch (run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_HLT:</span><br><span class=\"line\">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class=\"line\">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class=\"line\">        // 后面CPU虚拟化会讲到这部分</span><br><span class=\"line\">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class=\"line\">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class=\"line\">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class=\"line\">            else</span><br><span class=\"line\">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class=\"line\">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class=\"line\">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class=\"line\">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译并运行这个demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g demo.c -o demo</span><br><span class=\"line\">➜  demo1 ./demo</span><br><span class=\"line\">4</span><br><span class=\"line\">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>\n<h2 id=\"另外一个简单的QEMU-emulator-demo\"><a href=\"#另外一个简单的QEMU-emulator-demo\" class=\"headerlink\" title=\"另外一个简单的QEMU emulator demo\"></a>另外一个简单的QEMU emulator demo</h2><p><a href=\"http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/\" target=\"_blank\" rel=\"noopener\">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.globl _start</span><br><span class=\"line\">    .code16</span><br><span class=\"line\">_start:</span><br><span class=\"line\">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class=\"line\"></span><br><span class=\"line\">loop1:</span><br><span class=\"line\">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class=\"line\">    inc %ax         # ax 值加一</span><br><span class=\"line\">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure>\n<p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p>\n<p>从main函数开始说起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char **argv) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 初始化kvm结构体</span><br><span class=\"line\">    struct kvm *kvm = kvm_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm == NULL) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;kvm init fauilt\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建VM，并分配内存空间</span><br><span class=\"line\">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;create vm fault\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加载镜像</span><br><span class=\"line\">    load_binary(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    // only support one vcpu now</span><br><span class=\"line\">    kvm-&gt;vcpu_number = 1;</span><br><span class=\"line\">    // 创建执行现场</span><br><span class=\"line\">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 启动虚拟机</span><br><span class=\"line\">    kvm_run_vm(kvm);</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm_clean_vm(kvm);</span><br><span class=\"line\">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\">    kvm_clean(kvm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm &#123;</span><br><span class=\"line\">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class=\"line\">   int vm_fd;               // GUEST 的句柄</span><br><span class=\"line\">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class=\"line\">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class=\"line\">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class=\"line\"></span><br><span class=\"line\">   int kvm_version;         </span><br><span class=\"line\">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class=\"line\">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class=\"line\"></span><br><span class=\"line\">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class=\"line\">   int vcpu_number;         // vcpu 个数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>初始化 kvm 结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm *kvm_init(void) &#123;</span><br><span class=\"line\">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class=\"line\">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;open kvm device fault: &quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class=\"line\"></span><br><span class=\"line\">    return kvm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class=\"line\">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vm&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 kvm 分配内存。通过系统调用.</span><br><span class=\"line\">    kvm-&gt;ram_size = ram_size;</span><br><span class=\"line\">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class=\"line\">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class=\"line\">                -1, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap ram&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class=\"line\">    // 只有一个内存槽</span><br><span class=\"line\">    kvm-&gt;mem.slot = 0;</span><br><span class=\"line\">    // guest 物理内存起始地址</span><br><span class=\"line\">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class=\"line\">    // 虚拟机内存大小</span><br><span class=\"line\">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class=\"line\">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class=\"line\">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class=\"line\">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ret &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set user memory region&quot;);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_binary(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fd &lt; 0) &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;can not open binary file\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class=\"line\"></span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class=\"line\">        if (ret &lt;= 0) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printf(&quot;read size: %d&quot;, ret);</span><br><span class=\"line\">        p += ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct vcpu &#123;</span><br><span class=\"line\">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class=\"line\">    int vcpu_fd;                 // vCPU 句柄</span><br><span class=\"line\">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class=\"line\">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class=\"line\">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class=\"line\">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class=\"line\">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class=\"line\">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class=\"line\">    // 申请vcpu结构</span><br><span class=\"line\">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class=\"line\">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class=\"line\">    vcpu-&gt;vcpu_id = 0;</span><br><span class=\"line\">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class=\"line\">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not create vcpu&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取KVM运行时结构大小</span><br><span class=\"line\">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class=\"line\">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class=\"line\">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class=\"line\">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class=\"line\">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置线程执行函数</span><br><span class=\"line\">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class=\"line\">    return vcpu;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一步，以上工作就绪后，启动虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class=\"line\">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class=\"line\">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class=\"line\">            perror(&quot;can not create kvm thread&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *kvm_cpu_thread(void *data) &#123;</span><br><span class=\"line\">    // 获取参数</span><br><span class=\"line\">    struct kvm *kvm = (struct kvm *)data;</span><br><span class=\"line\">    int ret = 0;</span><br><span class=\"line\">    // 设置KVM的参数</span><br><span class=\"line\">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        printf(&quot;KVM start run\\n&quot;);</span><br><span class=\"line\">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class=\"line\">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (ret &lt; 0) &#123;</span><br><span class=\"line\">            fprintf(stderr, &quot;KVM_RUN failed\\n&quot;);</span><br><span class=\"line\">            exit(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class=\"line\">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class=\"line\">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class=\"line\">        case KVM_EXIT_UNKNOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_UNKNOWN\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_DEBUG:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_DEBUG\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class=\"line\">        // 把执行权交给emulator</span><br><span class=\"line\">        case KVM_EXIT_IO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_IO\\n&quot;);</span><br><span class=\"line\">            printf(&quot;out port: %d, data: %d\\n&quot;, </span><br><span class=\"line\">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class=\"line\">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class=\"line\">                );</span><br><span class=\"line\">            sleep(1);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        // 虚拟机执行了memory map IO操作</span><br><span class=\"line\">        case KVM_EXIT_MMIO:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_MMIO\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_INTR:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_INTR\\n&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case KVM_EXIT_SHUTDOWN:</span><br><span class=\"line\">            printf(&quot;KVM_EXIT_SHUTDOWN\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            printf(&quot;KVM PANIC\\n&quot;);</span><br><span class=\"line\">            goto exit_kvm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_kvm:</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not get sregs\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // #define CODE_START 0x1000</span><br><span class=\"line\">    /* sregs 结构体</span><br><span class=\"line\">        x86</span><br><span class=\"line\">        struct kvm_sregs &#123;</span><br><span class=\"line\">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class=\"line\">            struct kvm_segment tr, ldt;</span><br><span class=\"line\">            struct kvm_dtable gdt, idt;</span><br><span class=\"line\">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class=\"line\">            __u64 efer;</span><br><span class=\"line\">            __u64 apic_base;</span><br><span class=\"line\">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class=\"line\">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class=\"line\">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class=\"line\">    // es 为附加段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class=\"line\">    // fs, gs 同样为段寄存器</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class=\"line\">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class=\"line\">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为vCPU设置以上寄存器的值</span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;can not set sregs&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置寄存器标志位</span><br><span class=\"line\">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class=\"line\">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class=\"line\">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class=\"line\">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class=\"line\">    vcpu-&gt;regs.rip = 0;</span><br><span class=\"line\">    // rsp 为堆栈顶</span><br><span class=\"line\">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class=\"line\">    // rbp 为堆栈底部</span><br><span class=\"line\">    vcpu-&gt;regs.rbp= 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class=\"line\">        perror(&quot;KVM SET REGS\\n&quot;);</span><br><span class=\"line\">        exit(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class=\"line\">read size: 712288</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 0</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 1</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 2</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 3</span><br><span class=\"line\">KVM start run</span><br><span class=\"line\">KVM_EXIT_IO</span><br><span class=\"line\">out port: 16, data: 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p>\n<p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p>\n"},{"title":"KVM 虚拟化原理3--CPU","donate":true,"date":"2018-12-10T15:16:24.000Z","_content":"## CPU 虚拟化简介\n\n上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。\n\n用一张图来解释更为贴切。\n\n![](vcpu-follow.png)\n\nVMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。\n\n## Intel-V 技术\n\nIntel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。\n\n### Intel-V虚拟化技术结构\n\nIntel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。  \n比如说一个IO操作：\n\n```hljs\nint nread = read(fd, buffer, 1024);\n```\n\n当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。\n\n```hljs\nmovel　　$3,%eax\nmovel　　fd,%ebx\nmovel　　buffer,%ecx\nmovel　　1024,%edx　　　　　　\nint　　  $0x80\n```\n\nIntel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。\n\n![](vcpu-ring.png)\n\nIntel的虚拟架构基本上分两个部分:\n\n* 虚拟机监视器\n* 客户机（Guest VM)\n\n#### 虚拟机监视器（Virtual-machine monitors - VMM)\n\n虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。\n\n#### Guest\n\n这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。  \nGuest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。\n\n#### VMM 与 Guest 的切换\n\n![](vmm_guest_switch.png)\n\nGuest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU->kvm_run->exit_reason。VMM根据exit_reason做相应的处理。\n\n#### VMM 的生命周期\n\n如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。  \n第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。\n\n#### VMCS （Virtual-Machine control structure)\n\n顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。\n\n#### Guest exit Reason\n\n下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。\n\n```hljs\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, \n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, \n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,\n     // 访问了IO设备\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr, \n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    // 访问了MSR寄存器\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    // Guest执行了HLT指令，Demo开胃菜就是这个指令\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]                    = handle_invd,\n    [EXIT_REASON_INVLPG]                  = handle_invlpg,\n    [EXIT_REASON_RDPMC]                   = handle_rdpmc,\n    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）\n    [EXIT_REASON_VMCALL]                  = handle_vmcall, \n    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n    [EXIT_REASON_VMREAD]                  = handle_vmread,\n    [EXIT_REASON_VMRESUME]                = handle_vmresume,\n    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n    [EXIT_REASON_VMOFF]                   = handle_vmoff,\n    [EXIT_REASON_VMON]                    = handle_vmon,\n\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    // 访问了高级PCI设备\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    // 进程切换\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    // ept 是Intel的一个硬件内存虚拟化技术\n    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    // 执行了暂停指令\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n    [EXIT_REASON_INVEPT]                  = handle_invept,\n};\n```\n\n## 总结\n\nKVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。  \nCPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。\n","source":"_posts/kvm-cpu.md","raw":"---\ntitle: KVM 虚拟化原理3--CPU\ndonate: true\ndate: 2018-12-10 23:16:24\ncategories: KVM\ntags: KVM\n---\n## CPU 虚拟化简介\n\n上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。\n\n用一张图来解释更为贴切。\n\n![](vcpu-follow.png)\n\nVMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。\n\n## Intel-V 技术\n\nIntel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。\n\n### Intel-V虚拟化技术结构\n\nIntel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。  \n比如说一个IO操作：\n\n```hljs\nint nread = read(fd, buffer, 1024);\n```\n\n当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。\n\n```hljs\nmovel　　$3,%eax\nmovel　　fd,%ebx\nmovel　　buffer,%ecx\nmovel　　1024,%edx　　　　　　\nint　　  $0x80\n```\n\nIntel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。\n\n![](vcpu-ring.png)\n\nIntel的虚拟架构基本上分两个部分:\n\n* 虚拟机监视器\n* 客户机（Guest VM)\n\n#### 虚拟机监视器（Virtual-machine monitors - VMM)\n\n虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。\n\n#### Guest\n\n这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。  \nGuest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。\n\n#### VMM 与 Guest 的切换\n\n![](vmm_guest_switch.png)\n\nGuest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU->kvm_run->exit_reason。VMM根据exit_reason做相应的处理。\n\n#### VMM 的生命周期\n\n如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。  \n第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。\n\n#### VMCS （Virtual-Machine control structure)\n\n顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。\n\n#### Guest exit Reason\n\n下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。\n\n```hljs\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, \n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, \n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,\n     // 访问了IO设备\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr, \n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    // 访问了MSR寄存器\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    // Guest执行了HLT指令，Demo开胃菜就是这个指令\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]                    = handle_invd,\n    [EXIT_REASON_INVLPG]                  = handle_invlpg,\n    [EXIT_REASON_RDPMC]                   = handle_rdpmc,\n    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）\n    [EXIT_REASON_VMCALL]                  = handle_vmcall, \n    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,\n    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,\n    [EXIT_REASON_VMREAD]                  = handle_vmread,\n    [EXIT_REASON_VMRESUME]                = handle_vmresume,\n    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,\n    [EXIT_REASON_VMOFF]                   = handle_vmoff,\n    [EXIT_REASON_VMON]                    = handle_vmon,\n\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    // 访问了高级PCI设备\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    // 进程切换\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    // ept 是Intel的一个硬件内存虚拟化技术\n    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    // 执行了暂停指令\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n    [EXIT_REASON_INVEPT]                  = handle_invept,\n};\n```\n\n## 总结\n\nKVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。  \nCPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。\n","slug":"kvm-cpu","published":1,"updated":"2018-12-11T02:30:26.704Z","_id":"cjpj2qxl20006y0o4x7l2g2zg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CPU-虚拟化简介\"><a href=\"#CPU-虚拟化简介\" class=\"headerlink\" title=\"CPU 虚拟化简介\"></a>CPU 虚拟化简介</h2><p>上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。</p>\n<p>用一张图来解释更为贴切。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-follow.png\" alt=\"\"></p>\n<p>VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。</p>\n<h2 id=\"Intel-V-技术\"><a href=\"#Intel-V-技术\" class=\"headerlink\" title=\"Intel-V 技术\"></a>Intel-V 技术</h2><p>Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。</p>\n<h3 id=\"Intel-V虚拟化技术结构\"><a href=\"#Intel-V虚拟化技术结构\" class=\"headerlink\" title=\"Intel-V虚拟化技术结构\"></a>Intel-V虚拟化技术结构</h3><p>Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。<br>比如说一个IO操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int nread = read(fd, buffer, 1024);</span><br></pre></td></tr></table></figure>\n<p>当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movel　　$3,%eax</span><br><span class=\"line\">movel　　fd,%ebx</span><br><span class=\"line\">movel　　buffer,%ecx</span><br><span class=\"line\">movel　　1024,%edx　　　　　　</span><br><span class=\"line\">int　　  $0x80</span><br></pre></td></tr></table></figure>\n<p>Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-ring.png\" alt=\"\"></p>\n<p>Intel的虚拟架构基本上分两个部分:</p>\n<ul>\n<li>虚拟机监视器</li>\n<li>客户机（Guest VM)</li>\n</ul>\n<h4 id=\"虚拟机监视器（Virtual-machine-monitors-VMM\"><a href=\"#虚拟机监视器（Virtual-machine-monitors-VMM\" class=\"headerlink\" title=\"虚拟机监视器（Virtual-machine monitors - VMM)\"></a>虚拟机监视器（Virtual-machine monitors - VMM)</h4><p>虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。</p>\n<h4 id=\"Guest\"><a href=\"#Guest\" class=\"headerlink\" title=\"Guest\"></a>Guest</h4><p>这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。<br>Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。</p>\n<h4 id=\"VMM-与-Guest-的切换\"><a href=\"#VMM-与-Guest-的切换\" class=\"headerlink\" title=\"VMM 与 Guest 的切换\"></a>VMM 与 Guest 的切换</h4><p><img src=\"/2018/12/10/kvm-cpu/vmm_guest_switch.png\" alt=\"\"></p>\n<p>Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。</p>\n<h4 id=\"VMM-的生命周期\"><a href=\"#VMM-的生命周期\" class=\"headerlink\" title=\"VMM 的生命周期\"></a>VMM 的生命周期</h4><p>如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。<br>第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。</p>\n<h4 id=\"VMCS-（Virtual-Machine-control-structure\"><a href=\"#VMCS-（Virtual-Machine-control-structure\" class=\"headerlink\" title=\"VMCS （Virtual-Machine control structure)\"></a>VMCS （Virtual-Machine control structure)</h4><p>顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。</p>\n<h4 id=\"Guest-exit-Reason\"><a href=\"#Guest-exit-Reason\" class=\"headerlink\" title=\"Guest exit Reason\"></a>Guest exit Reason</h4><p>下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123;</span><br><span class=\"line\">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, </span><br><span class=\"line\">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, </span><br><span class=\"line\">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,</span><br><span class=\"line\">     // 访问了IO设备</span><br><span class=\"line\">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试</span><br><span class=\"line\">    [EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">    [EXIT_REASON_DR_ACCESS]               = handle_dr, </span><br><span class=\"line\">    [EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">    // 访问了MSR寄存器</span><br><span class=\"line\">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">    // Guest执行了HLT指令，Demo开胃菜就是这个指令</span><br><span class=\"line\">    [EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">    [EXIT_REASON_INVD]                    = handle_invd,</span><br><span class=\"line\">    [EXIT_REASON_INVLPG]                  = handle_invlpg,</span><br><span class=\"line\">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）</span><br><span class=\"line\">    [EXIT_REASON_VMCALL]                  = handle_vmcall, </span><br><span class=\"line\">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,</span><br><span class=\"line\">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">    [EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">    [EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">    [EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">    [EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\"></span><br><span class=\"line\">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">    // 访问了高级PCI设备</span><br><span class=\"line\">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">    // 进程切换</span><br><span class=\"line\">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">    // ept 是Intel的一个硬件内存虚拟化技术</span><br><span class=\"line\">    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,</span><br><span class=\"line\">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">    // 执行了暂停指令</span><br><span class=\"line\">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。<br>CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CPU-虚拟化简介\"><a href=\"#CPU-虚拟化简介\" class=\"headerlink\" title=\"CPU 虚拟化简介\"></a>CPU 虚拟化简介</h2><p>上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。</p>\n<p>用一张图来解释更为贴切。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-follow.png\" alt=\"\"></p>\n<p>VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。</p>\n<h2 id=\"Intel-V-技术\"><a href=\"#Intel-V-技术\" class=\"headerlink\" title=\"Intel-V 技术\"></a>Intel-V 技术</h2><p>Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。</p>\n<h3 id=\"Intel-V虚拟化技术结构\"><a href=\"#Intel-V虚拟化技术结构\" class=\"headerlink\" title=\"Intel-V虚拟化技术结构\"></a>Intel-V虚拟化技术结构</h3><p>Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。<br>比如说一个IO操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int nread = read(fd, buffer, 1024);</span><br></pre></td></tr></table></figure>\n<p>当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movel　　$3,%eax</span><br><span class=\"line\">movel　　fd,%ebx</span><br><span class=\"line\">movel　　buffer,%ecx</span><br><span class=\"line\">movel　　1024,%edx　　　　　　</span><br><span class=\"line\">int　　  $0x80</span><br></pre></td></tr></table></figure>\n<p>Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。</p>\n<p><img src=\"/2018/12/10/kvm-cpu/vcpu-ring.png\" alt=\"\"></p>\n<p>Intel的虚拟架构基本上分两个部分:</p>\n<ul>\n<li>虚拟机监视器</li>\n<li>客户机（Guest VM)</li>\n</ul>\n<h4 id=\"虚拟机监视器（Virtual-machine-monitors-VMM\"><a href=\"#虚拟机监视器（Virtual-machine-monitors-VMM\" class=\"headerlink\" title=\"虚拟机监视器（Virtual-machine monitors - VMM)\"></a>虚拟机监视器（Virtual-machine monitors - VMM)</h4><p>虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。</p>\n<h4 id=\"Guest\"><a href=\"#Guest\" class=\"headerlink\" title=\"Guest\"></a>Guest</h4><p>这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。<br>Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。</p>\n<h4 id=\"VMM-与-Guest-的切换\"><a href=\"#VMM-与-Guest-的切换\" class=\"headerlink\" title=\"VMM 与 Guest 的切换\"></a>VMM 与 Guest 的切换</h4><p><img src=\"/2018/12/10/kvm-cpu/vmm_guest_switch.png\" alt=\"\"></p>\n<p>Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。</p>\n<h4 id=\"VMM-的生命周期\"><a href=\"#VMM-的生命周期\" class=\"headerlink\" title=\"VMM 的生命周期\"></a>VMM 的生命周期</h4><p>如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。<br>第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。</p>\n<h4 id=\"VMCS-（Virtual-Machine-control-structure\"><a href=\"#VMCS-（Virtual-Machine-control-structure\" class=\"headerlink\" title=\"VMCS （Virtual-Machine control structure)\"></a>VMCS （Virtual-Machine control structure)</h4><p>顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。</p>\n<h4 id=\"Guest-exit-Reason\"><a href=\"#Guest-exit-Reason\" class=\"headerlink\" title=\"Guest exit Reason\"></a>Guest exit Reason</h4><p>下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123;</span><br><span class=\"line\">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, </span><br><span class=\"line\">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, </span><br><span class=\"line\">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,</span><br><span class=\"line\">     // 访问了IO设备</span><br><span class=\"line\">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试</span><br><span class=\"line\">    [EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">    [EXIT_REASON_DR_ACCESS]               = handle_dr, </span><br><span class=\"line\">    [EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">    // 访问了MSR寄存器</span><br><span class=\"line\">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">    // Guest执行了HLT指令，Demo开胃菜就是这个指令</span><br><span class=\"line\">    [EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">    [EXIT_REASON_INVD]                    = handle_invd,</span><br><span class=\"line\">    [EXIT_REASON_INVLPG]                  = handle_invlpg,</span><br><span class=\"line\">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）</span><br><span class=\"line\">    [EXIT_REASON_VMCALL]                  = handle_vmcall, </span><br><span class=\"line\">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,</span><br><span class=\"line\">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">    [EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">    [EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">    [EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">    [EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\"></span><br><span class=\"line\">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">    // 访问了高级PCI设备</span><br><span class=\"line\">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">    // 进程切换</span><br><span class=\"line\">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">    // ept 是Intel的一个硬件内存虚拟化技术</span><br><span class=\"line\">    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,</span><br><span class=\"line\">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">    // 执行了暂停指令</span><br><span class=\"line\">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,</span><br><span class=\"line\">    [EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。<br>CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。</p>\n"},{"title":"KVM 虚拟化原理1 -- 概述","date":"2018-12-10T14:32:20.000Z","donate":true,"_content":"## KVM虚拟化简介 ##\n\nKVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。\nKVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。\n\nQemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。\n\n正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。\n\n\n![](01_brief.png)\n\nKVM有如下特点：\n\n* guest作为一个普通进程运行于宿主机\n* guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度\n\n## KVM整体架构##\n\n![](02_kvm_framework.png)\n\n### 虚拟CPU\n\n虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。\n\nKVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。\n\n### 虚拟IO设备\n\nguest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。\n\n### 虚拟内存\n\nguest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。\n","source":"_posts/kvm-overview.md","raw":"---\ntitle: KVM 虚拟化原理1 -- 概述\ndate: 2018-12-10 22:32:20\ncategories: KVM\ntags: KVM\ndonate: true\n\n---\n## KVM虚拟化简介 ##\n\nKVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。\nKVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。\n\nQemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。\n\n正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。\n\n\n![](01_brief.png)\n\nKVM有如下特点：\n\n* guest作为一个普通进程运行于宿主机\n* guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度\n\n## KVM整体架构##\n\n![](02_kvm_framework.png)\n\n### 虚拟CPU\n\n虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。\n\nKVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。\n\n### 虚拟IO设备\n\nguest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。\n\n### 虚拟内存\n\nguest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。\n","slug":"kvm-overview","published":1,"updated":"2018-12-10T15:58:02.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpj2qxl50008y0o4k9kcizvb","content":"<h2 id=\"KVM虚拟化简介\"><a href=\"#KVM虚拟化简介\" class=\"headerlink\" title=\"KVM虚拟化简介\"></a>KVM虚拟化简介</h2><p>KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。<br>KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。</p>\n<p>Qemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p>\n<p>正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。</p>\n<p><img src=\"/2018/12/10/kvm-overview/01_brief.png\" alt=\"\"></p>\n<p>KVM有如下特点：</p>\n<ul>\n<li>guest作为一个普通进程运行于宿主机</li>\n<li>guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度</li>\n</ul>\n<h2 id=\"KVM整体架构\"><a href=\"#KVM整体架构\" class=\"headerlink\" title=\"KVM整体架构\"></a>KVM整体架构</h2><p><img src=\"/2018/12/10/kvm-overview/02_kvm_framework.png\" alt=\"\"></p>\n<h3 id=\"虚拟CPU\"><a href=\"#虚拟CPU\" class=\"headerlink\" title=\"虚拟CPU\"></a>虚拟CPU</h3><p>虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。</p>\n<p>KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。</p>\n<h3 id=\"虚拟IO设备\"><a href=\"#虚拟IO设备\" class=\"headerlink\" title=\"虚拟IO设备\"></a>虚拟IO设备</h3><p>guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"KVM虚拟化简介\"><a href=\"#KVM虚拟化简介\" class=\"headerlink\" title=\"KVM虚拟化简介\"></a>KVM虚拟化简介</h2><p>KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。<br>KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。</p>\n<p>Qemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p>\n<p>正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。</p>\n<p><img src=\"/2018/12/10/kvm-overview/01_brief.png\" alt=\"\"></p>\n<p>KVM有如下特点：</p>\n<ul>\n<li>guest作为一个普通进程运行于宿主机</li>\n<li>guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度</li>\n</ul>\n<h2 id=\"KVM整体架构\"><a href=\"#KVM整体架构\" class=\"headerlink\" title=\"KVM整体架构\"></a>KVM整体架构</h2><p><img src=\"/2018/12/10/kvm-overview/02_kvm_framework.png\" alt=\"\"></p>\n<h3 id=\"虚拟CPU\"><a href=\"#虚拟CPU\" class=\"headerlink\" title=\"虚拟CPU\"></a>虚拟CPU</h3><p>虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。</p>\n<p>KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。</p>\n<h3 id=\"虚拟IO设备\"><a href=\"#虚拟IO设备\" class=\"headerlink\" title=\"虚拟IO设备\"></a>虚拟IO设备</h3><p>guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。</p>\n"},{"title":"KVM 虚拟化原理4--内存","donate":true,"date":"2018-12-10T15:28:02.000Z","_content":"\n## 内存虚拟化简介\n\n前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。\n\n## 传统的地址转换\n\n在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。  \n通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。  \n首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。\n\n```hljs\n逻辑地址 ==> 线性地址 ==> 物理地址\n```\n\n逻辑地址和线性地址之间通过简单的偏移来完成。  \n![](logical_address.png)\n\n一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。\n\n为什么要这么做？据说是Intel为了保证兼容性。\n\n逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。\n\n传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。  \n页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。\n\n![](page.png)\n\n## KVM中的内存结构\n\n由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n    Guest线性地址 \n          |\n   Guest物理地址(GPA)\n          |             Guest\n   ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n      HV线性地址\n          |\n    HV物理地址(HPA)\n```\n\nWhat's the fu*k ？这么多...  \n别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n   Guest物理地址(GPA)\n          |             Guest\n  ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n    HV物理地址(HPA)\n```\n\n前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。\n\n## 软件虚拟化方式实现\n\n第一层转换，由GVA->GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在[第二章KVM启动过程](http://www.cnblogs.com/Bozh/p/5753379.html)的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。\n\n![](gpa_hpa.png)\n\n```hljs\nstruct kvm_userspace_memory_region region = {\n    .slot = 0,\n    .guest_phys_addr = 0x1000,\n    .memory_size = 0x1000,\n    .userspace_addr = (uint64_t)mem,\n};\n```\n\n可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射`userspace_addr`，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。\n\n![](gpa_hpa2.png)\n\n软件模拟的虚拟化方式由qemu-kvm来负责维护GPA->HVA的转换，然后再经过一次HVA->HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。\n\n## 影子页表的虚拟化方式\n\n影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。  \n在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，[CPU虚拟化章节](http://www.cnblogs.com/Bozh/p/5757274.html) EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。\n\n![](gpa_hpa3_shadow.png)\n\n影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA->HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA->PA)，然后影子页表记录GVA->GPA->HVA->HPA。这样产生GVA->GPA的直接关系，保存到影子页表中。\n\n![](gpa_hpa4.png)\n\n影子页表的引入，减少了GVA->HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。\n\n## EPT硬件加速的虚拟化方式\n\n![](gpa_hpa5_ept.png)\nEPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA->HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA->HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。  \n在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。\n\n## 总结\n\nKVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。  \nKVM经过软件模拟->影子页表->EPT的技术的进化，效率也越来越高。\n","source":"_posts/kvm-memory.md","raw":"---\ntitle: KVM 虚拟化原理4--内存\ndonate: true\ndate: 2018-12-10 23:28:02\ncategories: KVM\ntags: KVM\n---\n\n## 内存虚拟化简介\n\n前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。\n\n## 传统的地址转换\n\n在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。  \n通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。  \n首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。\n\n```hljs\n逻辑地址 ==> 线性地址 ==> 物理地址\n```\n\n逻辑地址和线性地址之间通过简单的偏移来完成。  \n![](logical_address.png)\n\n一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。\n\n为什么要这么做？据说是Intel为了保证兼容性。\n\n逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。\n\n传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。  \n页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。\n\n![](page.png)\n\n## KVM中的内存结构\n\n由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n    Guest线性地址 \n          |\n   Guest物理地址(GPA)\n          |             Guest\n   ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n      HV线性地址\n          |\n    HV物理地址(HPA)\n```\n\nWhat's the fu*k ？这么多...  \n别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。\n\n```hljs\nGuest虚拟内存地址(GVA)\n          |\n   Guest物理地址(GPA)\n          |             Guest\n  ------------------\n          |             HV\n    HV虚拟地址(HVA)\n          |\n    HV物理地址(HPA)\n```\n\n前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。\n\n## 软件虚拟化方式实现\n\n第一层转换，由GVA->GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在[第二章KVM启动过程](http://www.cnblogs.com/Bozh/p/5753379.html)的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。\n\n![](gpa_hpa.png)\n\n```hljs\nstruct kvm_userspace_memory_region region = {\n    .slot = 0,\n    .guest_phys_addr = 0x1000,\n    .memory_size = 0x1000,\n    .userspace_addr = (uint64_t)mem,\n};\n```\n\n可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射`userspace_addr`，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。\n\n![](gpa_hpa2.png)\n\n软件模拟的虚拟化方式由qemu-kvm来负责维护GPA->HVA的转换，然后再经过一次HVA->HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。\n\n## 影子页表的虚拟化方式\n\n影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。  \n在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，[CPU虚拟化章节](http://www.cnblogs.com/Bozh/p/5757274.html) EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。\n\n![](gpa_hpa3_shadow.png)\n\n影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA->HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA->PA)，然后影子页表记录GVA->GPA->HVA->HPA。这样产生GVA->GPA的直接关系，保存到影子页表中。\n\n![](gpa_hpa4.png)\n\n影子页表的引入，减少了GVA->HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。\n\n## EPT硬件加速的虚拟化方式\n\n![](gpa_hpa5_ept.png)\nEPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA->HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA->HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。  \n在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。\n\n## 总结\n\nKVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。  \nKVM经过软件模拟->影子页表->EPT的技术的进化，效率也越来越高。\n","slug":"kvm-memory","published":1,"updated":"2018-12-11T02:30:07.672Z","_id":"cjpj2qxl60009y0o49ykpqr1t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"内存虚拟化简介\"><a href=\"#内存虚拟化简介\" class=\"headerlink\" title=\"内存虚拟化简介\"></a>内存虚拟化简介</h2><p>前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。</p>\n<h2 id=\"传统的地址转换\"><a href=\"#传统的地址转换\" class=\"headerlink\" title=\"传统的地址转换\"></a>传统的地址转换</h2><p>在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。<br>通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。<br>首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逻辑地址 ==&gt; 线性地址 ==&gt; 物理地址</span><br></pre></td></tr></table></figure>\n<p>逻辑地址和线性地址之间通过简单的偏移来完成。<br><img src=\"/2018/12/10/kvm-memory/logical_address.png\" alt=\"\"></p>\n<p>一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。</p>\n<p>为什么要这么做？据说是Intel为了保证兼容性。</p>\n<p>逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。</p>\n<p>传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。<br>页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。</p>\n<p><img src=\"/2018/12/10/kvm-memory/page.png\" alt=\"\"></p>\n<h2 id=\"KVM中的内存结构\"><a href=\"#KVM中的内存结构\" class=\"headerlink\" title=\"KVM中的内存结构\"></a>KVM中的内存结构</h2><p>由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    Guest线性地址 </span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">   ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">      HV线性地址</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>What’s the fu*k ？这么多…<br>别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">  ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。</p>\n<h2 id=\"软件虚拟化方式实现\"><a href=\"#软件虚拟化方式实现\" class=\"headerlink\" title=\"软件虚拟化方式实现\"></a>软件虚拟化方式实现</h2><p>第一层转换，由GVA-&gt;GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在<a href=\"http://www.cnblogs.com/Bozh/p/5753379.html\" target=\"_blank\" rel=\"noopener\">第二章KVM启动过程</a>的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">    .slot = 0,</span><br><span class=\"line\">    .guest_phys_addr = 0x1000,</span><br><span class=\"line\">    .memory_size = 0x1000,</span><br><span class=\"line\">    .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射<code>userspace_addr</code>，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa2.png\" alt=\"\"></p>\n<p>软件模拟的虚拟化方式由qemu-kvm来负责维护GPA-&gt;HVA的转换，然后再经过一次HVA-&gt;HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。</p>\n<h2 id=\"影子页表的虚拟化方式\"><a href=\"#影子页表的虚拟化方式\" class=\"headerlink\" title=\"影子页表的虚拟化方式\"></a>影子页表的虚拟化方式</h2><p>影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。<br>在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，<a href=\"http://www.cnblogs.com/Bozh/p/5757274.html\" target=\"_blank\" rel=\"noopener\">CPU虚拟化章节</a> EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa3_shadow.png\" alt=\"\"></p>\n<p>影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA-&gt;HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA-&gt;PA)，然后影子页表记录GVA-&gt;GPA-&gt;HVA-&gt;HPA。这样产生GVA-&gt;GPA的直接关系，保存到影子页表中。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa4.png\" alt=\"\"></p>\n<p>影子页表的引入，减少了GVA-&gt;HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。</p>\n<h2 id=\"EPT硬件加速的虚拟化方式\"><a href=\"#EPT硬件加速的虚拟化方式\" class=\"headerlink\" title=\"EPT硬件加速的虚拟化方式\"></a>EPT硬件加速的虚拟化方式</h2><p><img src=\"/2018/12/10/kvm-memory/gpa_hpa5_ept.png\" alt=\"\"><br>EPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA-&gt;HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA-&gt;HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。<br>在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。<br>KVM经过软件模拟-&gt;影子页表-&gt;EPT的技术的进化，效率也越来越高。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存虚拟化简介\"><a href=\"#内存虚拟化简介\" class=\"headerlink\" title=\"内存虚拟化简介\"></a>内存虚拟化简介</h2><p>前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。</p>\n<h2 id=\"传统的地址转换\"><a href=\"#传统的地址转换\" class=\"headerlink\" title=\"传统的地址转换\"></a>传统的地址转换</h2><p>在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。<br>通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。<br>首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逻辑地址 ==&gt; 线性地址 ==&gt; 物理地址</span><br></pre></td></tr></table></figure>\n<p>逻辑地址和线性地址之间通过简单的偏移来完成。<br><img src=\"/2018/12/10/kvm-memory/logical_address.png\" alt=\"\"></p>\n<p>一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。</p>\n<p>为什么要这么做？据说是Intel为了保证兼容性。</p>\n<p>逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。</p>\n<p>传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。<br>页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。</p>\n<p><img src=\"/2018/12/10/kvm-memory/page.png\" alt=\"\"></p>\n<h2 id=\"KVM中的内存结构\"><a href=\"#KVM中的内存结构\" class=\"headerlink\" title=\"KVM中的内存结构\"></a>KVM中的内存结构</h2><p>由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    Guest线性地址 </span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">   ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">      HV线性地址</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>What’s the fu*k ？这么多…<br>别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Guest虚拟内存地址(GVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">   Guest物理地址(GPA)</span><br><span class=\"line\">          |             Guest</span><br><span class=\"line\">  ------------------</span><br><span class=\"line\">          |             HV</span><br><span class=\"line\">    HV虚拟地址(HVA)</span><br><span class=\"line\">          |</span><br><span class=\"line\">    HV物理地址(HPA)</span><br></pre></td></tr></table></figure>\n<p>前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。</p>\n<h2 id=\"软件虚拟化方式实现\"><a href=\"#软件虚拟化方式实现\" class=\"headerlink\" title=\"软件虚拟化方式实现\"></a>软件虚拟化方式实现</h2><p>第一层转换，由GVA-&gt;GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在<a href=\"http://www.cnblogs.com/Bozh/p/5753379.html\" target=\"_blank\" rel=\"noopener\">第二章KVM启动过程</a>的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct kvm_userspace_memory_region region = &#123;</span><br><span class=\"line\">    .slot = 0,</span><br><span class=\"line\">    .guest_phys_addr = 0x1000,</span><br><span class=\"line\">    .memory_size = 0x1000,</span><br><span class=\"line\">    .userspace_addr = (uint64_t)mem,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射<code>userspace_addr</code>，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa2.png\" alt=\"\"></p>\n<p>软件模拟的虚拟化方式由qemu-kvm来负责维护GPA-&gt;HVA的转换，然后再经过一次HVA-&gt;HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。</p>\n<h2 id=\"影子页表的虚拟化方式\"><a href=\"#影子页表的虚拟化方式\" class=\"headerlink\" title=\"影子页表的虚拟化方式\"></a>影子页表的虚拟化方式</h2><p>影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。<br>在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，<a href=\"http://www.cnblogs.com/Bozh/p/5757274.html\" target=\"_blank\" rel=\"noopener\">CPU虚拟化章节</a> EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa3_shadow.png\" alt=\"\"></p>\n<p>影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA-&gt;HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA-&gt;PA)，然后影子页表记录GVA-&gt;GPA-&gt;HVA-&gt;HPA。这样产生GVA-&gt;GPA的直接关系，保存到影子页表中。</p>\n<p><img src=\"/2018/12/10/kvm-memory/gpa_hpa4.png\" alt=\"\"></p>\n<p>影子页表的引入，减少了GVA-&gt;HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。</p>\n<h2 id=\"EPT硬件加速的虚拟化方式\"><a href=\"#EPT硬件加速的虚拟化方式\" class=\"headerlink\" title=\"EPT硬件加速的虚拟化方式\"></a>EPT硬件加速的虚拟化方式</h2><p><img src=\"/2018/12/10/kvm-memory/gpa_hpa5_ept.png\" alt=\"\"><br>EPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA-&gt;HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA-&gt;HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。<br>在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>KVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。<br>KVM经过软件模拟-&gt;影子页表-&gt;EPT的技术的进化，效率也越来越高。</p>\n"},{"title":"QMP 简介","date":"2018-12-10T13:42:39.000Z","donate":true,"_content":"\n## 什么是QMP协议##\nQMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。\n\n## QMP协议有哪些特征##\n1）轻量、基于文本、指令格式易于解析，因为它是json格式的；\n2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；\n3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ \"execute\": \"query-status\" }，这样就可以查询虚拟机的状态。\n\n## QMP协议有哪些模式##\n 有两种模式：Capabilities Negotiation模式和Command模式。\n\n## 那么该如何建立qmp连接呢 ##\n这里简要介绍通过tcp和unix socket使用qmp。\n\n### 通过TCP使用QMP ###\n使用-qmp添加qmp相关参数：\n\n``` bash\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp tcp:localhost:1234,server,nowait\n```\n新开一个终端使用telnet 链接localhost：1234\n\n``` bash\ntelnet localhost 1234\n```\n之后就可以使用qmp的命令和虚拟机交互了\n\n```\n[root@localhost ~]# telnet localhost 1234\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\n### 通过unix socket使用QMP ###\n使用unix socket创建qmp：\n\n```\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait\n```\n\n使用nc连接该socket:\n\n```\nnc -U /tmp/qmp-test\n```\n\n之后就一样了。\n\n```\n[root@localhost qmp]# nc -U /tmp/qmp-test\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\nQMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。\n\n### 自动批量发送QMP命令\n\n可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。\n\n```\n# QEMU Monitor Protocol Python class\n#\n# Copyright (C) 2009 Red Hat Inc.\n#\n# This work is licensed under the terms of the GNU GPL, version 2.  See\n# the COPYING file in the top-level directory.\n\nimport socket, json, time, commands\nfrom optparse import OptionParser\n\nclass QMPError(Exception):\n    pass\n\nclass QMPConnectError(QMPError):\n    pass\n\nclass QEMUMonitorProtocol:\n    def connect(self):\n        print self.filename\n        self.sock.connect(self.filename)\n        data = self.__json_read()\n        if data == None:\n            raise QMPConnectError\n        if not data.has_key('QMP'):\n            raise QMPConnectError\n        return data['QMP']['capabilities']\n\n    def close(self):\n        self.sock.close()\n\n    def send_raw(self, line):\n        self.sock.send(str(line))\n        return self.__json_read()\n\n    def send(self, cmdline, timeout=30, convert=True):\n        end_time = time.time() + timeout\n        if convert:\n            cmd = self.__build_cmd(cmdline)\n        else:\n            cmd = cmdline\n\t    print(\"*cmdline = %s\" % cmd)\n        print cmd\n        self.__json_send(cmd)\n        while time.time() < end_time:\n            resp = self.__json_read()\n            if resp == None:\n                return (False, None)\n            elif resp.has_key('error'):\n                return (False, resp['error'])\n            elif resp.has_key('return'):\n                return (True, resp['return'])\n\n    def read(self, timeout=30):\n        o = \"\"\n        end_time = time.time() + timeout\n        while time.time() < end_time:\n            try:\n                o += self.sock.recv(1024)\n                if len(o) > 0:\n                    break\n            except:\n                time.sleep(0.01)\n        if len(o) > 0:\n            return json.loads(o)\n        else:\n            return None\n\n    def __build_cmd(self, cmdline):\n        cmdargs = cmdline.split()\n        qmpcmd = { 'execute': cmdargs[0], 'arguments': {} }\n        for arg in cmdargs[1:]:\n            opt = arg.split('=')\n            try:\n                value = int(opt[1])\n            except ValueError:\n                value = opt[1]\n            qmpcmd['arguments'][opt[0]] = value\n\tprint(\"*cmdline = %s\" % cmdline)\n        return qmpcmd\n\n    def __json_send(self, cmd):\n        # XXX: We have to send any additional char, otherwise\n        # the Server won't read our input\n        self.sock.send(json.dumps(cmd) + ' ')\n\n    def __json_read(self):\n        try:\n            return json.loads(self.sock.recv(1024))\n        except ValueError:\n            return\n\n    def __init__(self, filename, protocol=\"tcp\"):\n        if protocol == \"tcp\":\n            self.filename = (\"localhost\", int(filename))\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        elif protocol == \"unix\":\n            self.filename = filename\n            print self.filename\n            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        #self.sock.setblocking(0)\n        self.sock.settimeout(5)\n\nif __name__ == \"__main__\":\n    parser = OptionParser()\n    parser.add_option('-n', '--num', dest='num', default='10', help='Times want to try')\n    parser.add_option('-f', '--file', dest='port', default='4444', help='QMP port/filename')\n    parser.add_option('-p', '--protocol', dest='protocol',default='tcp', help='QMP protocol')\n    def usage():\n        parser.print_help()\n        sys.exit(1)\n\n    options, args = parser.parse_args()\n\n    print options\n    if len(args) > 0:\n        usage()\n\n    num = int(options.num)\n    qmp_filename = options.port\n    qmp_protocol = options.protocol\n    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)\n    qmp_socket.connect()\n    qmp_socket.send(\"qmp_capabilities\")\n    qmp_socket.close()\n\n##########################################################\n#Usage\n#Options:\n#  -h, --help            show this help message and exit\n#  -n NUM, --num=NUM     Times want to try\n#  -f PORT, --file=PORT  QMP port/filename\n#  -p PROTOCOL, --protocol=PROTOCOL\n#                        QMP protocol\n# e.g: # python xxxxx.py -n $NUM -f $PORT\n##########################################################\n```\n## 参考文档 ##\n关于QMP更详细的文档，可以参考其官方文档：\nhttps://wiki.qemu.org/Documentation/QMP\n\n\n","source":"_posts/qmp-introduction.md","raw":"---\ntitle: QMP 简介\ndate: 2018-12-10 21:42:39\ncategories: QEMU\ntags: [QEMU, QMP]\ndonate: true\n---\n\n## 什么是QMP协议##\nQMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。\n\n## QMP协议有哪些特征##\n1）轻量、基于文本、指令格式易于解析，因为它是json格式的；\n2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；\n3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ \"execute\": \"query-status\" }，这样就可以查询虚拟机的状态。\n\n## QMP协议有哪些模式##\n 有两种模式：Capabilities Negotiation模式和Command模式。\n\n## 那么该如何建立qmp连接呢 ##\n这里简要介绍通过tcp和unix socket使用qmp。\n\n### 通过TCP使用QMP ###\n使用-qmp添加qmp相关参数：\n\n``` bash\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp tcp:localhost:1234,server,nowait\n```\n新开一个终端使用telnet 链接localhost：1234\n\n``` bash\ntelnet localhost 1234\n```\n之后就可以使用qmp的命令和虚拟机交互了\n\n```\n[root@localhost ~]# telnet localhost 1234\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\n### 通过unix socket使用QMP ###\n使用unix socket创建qmp：\n\n```\n./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait\n```\n\n使用nc连接该socket:\n\n```\nnc -U /tmp/qmp-test\n```\n\n之后就一样了。\n\n```\n[root@localhost qmp]# nc -U /tmp/qmp-test\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 6, \"major\": 2}, \"package\": \"\"}, \"capabilities\": []}}\n{ \"execute\": \"qmp_capabilities\" }\n{\"return\": {}}\n{ \"execute\": \"query-status\" }\n{\"return\": {\"status\": \"running\", \"singlestep\": false, \"running\": true}}\n```\n\nQMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。\n\n### 自动批量发送QMP命令\n\n可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。\n\n```\n# QEMU Monitor Protocol Python class\n#\n# Copyright (C) 2009 Red Hat Inc.\n#\n# This work is licensed under the terms of the GNU GPL, version 2.  See\n# the COPYING file in the top-level directory.\n\nimport socket, json, time, commands\nfrom optparse import OptionParser\n\nclass QMPError(Exception):\n    pass\n\nclass QMPConnectError(QMPError):\n    pass\n\nclass QEMUMonitorProtocol:\n    def connect(self):\n        print self.filename\n        self.sock.connect(self.filename)\n        data = self.__json_read()\n        if data == None:\n            raise QMPConnectError\n        if not data.has_key('QMP'):\n            raise QMPConnectError\n        return data['QMP']['capabilities']\n\n    def close(self):\n        self.sock.close()\n\n    def send_raw(self, line):\n        self.sock.send(str(line))\n        return self.__json_read()\n\n    def send(self, cmdline, timeout=30, convert=True):\n        end_time = time.time() + timeout\n        if convert:\n            cmd = self.__build_cmd(cmdline)\n        else:\n            cmd = cmdline\n\t    print(\"*cmdline = %s\" % cmd)\n        print cmd\n        self.__json_send(cmd)\n        while time.time() < end_time:\n            resp = self.__json_read()\n            if resp == None:\n                return (False, None)\n            elif resp.has_key('error'):\n                return (False, resp['error'])\n            elif resp.has_key('return'):\n                return (True, resp['return'])\n\n    def read(self, timeout=30):\n        o = \"\"\n        end_time = time.time() + timeout\n        while time.time() < end_time:\n            try:\n                o += self.sock.recv(1024)\n                if len(o) > 0:\n                    break\n            except:\n                time.sleep(0.01)\n        if len(o) > 0:\n            return json.loads(o)\n        else:\n            return None\n\n    def __build_cmd(self, cmdline):\n        cmdargs = cmdline.split()\n        qmpcmd = { 'execute': cmdargs[0], 'arguments': {} }\n        for arg in cmdargs[1:]:\n            opt = arg.split('=')\n            try:\n                value = int(opt[1])\n            except ValueError:\n                value = opt[1]\n            qmpcmd['arguments'][opt[0]] = value\n\tprint(\"*cmdline = %s\" % cmdline)\n        return qmpcmd\n\n    def __json_send(self, cmd):\n        # XXX: We have to send any additional char, otherwise\n        # the Server won't read our input\n        self.sock.send(json.dumps(cmd) + ' ')\n\n    def __json_read(self):\n        try:\n            return json.loads(self.sock.recv(1024))\n        except ValueError:\n            return\n\n    def __init__(self, filename, protocol=\"tcp\"):\n        if protocol == \"tcp\":\n            self.filename = (\"localhost\", int(filename))\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        elif protocol == \"unix\":\n            self.filename = filename\n            print self.filename\n            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        #self.sock.setblocking(0)\n        self.sock.settimeout(5)\n\nif __name__ == \"__main__\":\n    parser = OptionParser()\n    parser.add_option('-n', '--num', dest='num', default='10', help='Times want to try')\n    parser.add_option('-f', '--file', dest='port', default='4444', help='QMP port/filename')\n    parser.add_option('-p', '--protocol', dest='protocol',default='tcp', help='QMP protocol')\n    def usage():\n        parser.print_help()\n        sys.exit(1)\n\n    options, args = parser.parse_args()\n\n    print options\n    if len(args) > 0:\n        usage()\n\n    num = int(options.num)\n    qmp_filename = options.port\n    qmp_protocol = options.protocol\n    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)\n    qmp_socket.connect()\n    qmp_socket.send(\"qmp_capabilities\")\n    qmp_socket.close()\n\n##########################################################\n#Usage\n#Options:\n#  -h, --help            show this help message and exit\n#  -n NUM, --num=NUM     Times want to try\n#  -f PORT, --file=PORT  QMP port/filename\n#  -p PROTOCOL, --protocol=PROTOCOL\n#                        QMP protocol\n# e.g: # python xxxxx.py -n $NUM -f $PORT\n##########################################################\n```\n## 参考文档 ##\n关于QMP更详细的文档，可以参考其官方文档：\nhttps://wiki.qemu.org/Documentation/QMP\n\n\n","slug":"qmp-introduction","published":1,"updated":"2018-12-10T14:15:44.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpj2qxl7000by0o4ixvghs3b","content":"<h2 id=\"什么是QMP协议\"><a href=\"#什么是QMP协议\" class=\"headerlink\" title=\"什么是QMP协议\"></a>什么是QMP协议</h2><p>QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h2 id=\"QMP协议有哪些特征\"><a href=\"#QMP协议有哪些特征\" class=\"headerlink\" title=\"QMP协议有哪些特征\"></a>QMP协议有哪些特征</h2><p>1）轻量、基于文本、指令格式易于解析，因为它是json格式的；<br>2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；<br>3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。</p>\n<h2 id=\"QMP协议有哪些模式\"><a href=\"#QMP协议有哪些模式\" class=\"headerlink\" title=\"QMP协议有哪些模式\"></a>QMP协议有哪些模式</h2><p> 有两种模式：Capabilities Negotiation模式和Command模式。</p>\n<h2 id=\"那么该如何建立qmp连接呢\"><a href=\"#那么该如何建立qmp连接呢\" class=\"headerlink\" title=\"那么该如何建立qmp连接呢\"></a>那么该如何建立qmp连接呢</h2><p>这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h3 id=\"通过TCP使用QMP\"><a href=\"#通过TCP使用QMP\" class=\"headerlink\" title=\"通过TCP使用QMP\"></a>通过TCP使用QMP</h3><p>使用-qmp添加qmp相关参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -<span class=\"built_in\">enable</span>-kvm -qmp tcp:localhost:1234,server,nowait</span><br></pre></td></tr></table></figure>\n<p>新开一个终端使用telnet 链接localhost：1234</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 1234</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用qmp的命令和虚拟机交互了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# telnet localhost 1234</span><br><span class=\"line\">Trying ::1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is &apos;^]&apos;.</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过unix-socket使用QMP\"><a href=\"#通过unix-socket使用QMP\" class=\"headerlink\" title=\"通过unix socket使用QMP\"></a>通过unix socket使用QMP</h3><p>使用unix socket创建qmp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait</span><br></pre></td></tr></table></figure>\n<p>使用nc连接该socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -U /tmp/qmp-test</span><br></pre></td></tr></table></figure>\n<p>之后就一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost qmp]# nc -U /tmp/qmp-test</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。</p>\n<h3 id=\"自动批量发送QMP命令\"><a href=\"#自动批量发送QMP命令\" class=\"headerlink\" title=\"自动批量发送QMP命令\"></a>自动批量发送QMP命令</h3><p>可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># QEMU Monitor Protocol Python class</span><br><span class=\"line\">#</span><br><span class=\"line\"># Copyright (C) 2009 Red Hat Inc.</span><br><span class=\"line\">#</span><br><span class=\"line\"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class=\"line\"># the COPYING file in the top-level directory.</span><br><span class=\"line\"></span><br><span class=\"line\">import socket, json, time, commands</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPError(Exception):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPConnectError(QMPError):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QEMUMonitorProtocol:</span><br><span class=\"line\">    def connect(self):</span><br><span class=\"line\">        print self.filename</span><br><span class=\"line\">        self.sock.connect(self.filename)</span><br><span class=\"line\">        data = self.__json_read()</span><br><span class=\"line\">        if data == None:</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        if not data.has_key(&apos;QMP&apos;):</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        return data[&apos;QMP&apos;][&apos;capabilities&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">    def close(self):</span><br><span class=\"line\">        self.sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send_raw(self, line):</span><br><span class=\"line\">        self.sock.send(str(line))</span><br><span class=\"line\">        return self.__json_read()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send(self, cmdline, timeout=30, convert=True):</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        if convert:</span><br><span class=\"line\">            cmd = self.__build_cmd(cmdline)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            cmd = cmdline</span><br><span class=\"line\">\t    print(&quot;*cmdline = %s&quot; % cmd)</span><br><span class=\"line\">        print cmd</span><br><span class=\"line\">        self.__json_send(cmd)</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            resp = self.__json_read()</span><br><span class=\"line\">            if resp == None:</span><br><span class=\"line\">                return (False, None)</span><br><span class=\"line\">            elif resp.has_key(&apos;error&apos;):</span><br><span class=\"line\">                return (False, resp[&apos;error&apos;])</span><br><span class=\"line\">            elif resp.has_key(&apos;return&apos;):</span><br><span class=\"line\">                return (True, resp[&apos;return&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">    def read(self, timeout=30):</span><br><span class=\"line\">        o = &quot;&quot;</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                o += self.sock.recv(1024)</span><br><span class=\"line\">                if len(o) &gt; 0:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                time.sleep(0.01)</span><br><span class=\"line\">        if len(o) &gt; 0:</span><br><span class=\"line\">            return json.loads(o)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return None</span><br><span class=\"line\"></span><br><span class=\"line\">    def __build_cmd(self, cmdline):</span><br><span class=\"line\">        cmdargs = cmdline.split()</span><br><span class=\"line\">        qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125;</span><br><span class=\"line\">        for arg in cmdargs[1:]:</span><br><span class=\"line\">            opt = arg.split(&apos;=&apos;)</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                value = int(opt[1])</span><br><span class=\"line\">            except ValueError:</span><br><span class=\"line\">                value = opt[1]</span><br><span class=\"line\">            qmpcmd[&apos;arguments&apos;][opt[0]] = value</span><br><span class=\"line\">\tprint(&quot;*cmdline = %s&quot; % cmdline)</span><br><span class=\"line\">        return qmpcmd</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_send(self, cmd):</span><br><span class=\"line\">        # XXX: We have to send any additional char, otherwise</span><br><span class=\"line\">        # the Server won&apos;t read our input</span><br><span class=\"line\">        self.sock.send(json.dumps(cmd) + &apos; &apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_read(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            return json.loads(self.sock.recv(1024))</span><br><span class=\"line\">        except ValueError:</span><br><span class=\"line\">            return</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, filename, protocol=&quot;tcp&quot;):</span><br><span class=\"line\">        if protocol == &quot;tcp&quot;:</span><br><span class=\"line\">            self.filename = (&quot;localhost&quot;, int(filename))</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">        elif protocol == &quot;unix&quot;:</span><br><span class=\"line\">            self.filename = filename</span><br><span class=\"line\">            print self.filename</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class=\"line\">        #self.sock.setblocking(0)</span><br><span class=\"line\">        self.sock.settimeout(5)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    parser = OptionParser()</span><br><span class=\"line\">    parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;)</span><br><span class=\"line\">    def usage():</span><br><span class=\"line\">        parser.print_help()</span><br><span class=\"line\">        sys.exit(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    options, args = parser.parse_args()</span><br><span class=\"line\"></span><br><span class=\"line\">    print options</span><br><span class=\"line\">    if len(args) &gt; 0:</span><br><span class=\"line\">        usage()</span><br><span class=\"line\"></span><br><span class=\"line\">    num = int(options.num)</span><br><span class=\"line\">    qmp_filename = options.port</span><br><span class=\"line\">    qmp_protocol = options.protocol</span><br><span class=\"line\">    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)</span><br><span class=\"line\">    qmp_socket.connect()</span><br><span class=\"line\">    qmp_socket.send(&quot;qmp_capabilities&quot;)</span><br><span class=\"line\">    qmp_socket.close()</span><br><span class=\"line\"></span><br><span class=\"line\">##########################################################</span><br><span class=\"line\">#Usage</span><br><span class=\"line\">#Options:</span><br><span class=\"line\">#  -h, --help            show this help message and exit</span><br><span class=\"line\">#  -n NUM, --num=NUM     Times want to try</span><br><span class=\"line\">#  -f PORT, --file=PORT  QMP port/filename</span><br><span class=\"line\">#  -p PROTOCOL, --protocol=PROTOCOL</span><br><span class=\"line\">#                        QMP protocol</span><br><span class=\"line\"># e.g: # python xxxxx.py -n $NUM -f $PORT</span><br><span class=\"line\">##########################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>关于QMP更详细的文档，可以参考其官方文档：<br><a href=\"https://wiki.qemu.org/Documentation/QMP\" target=\"_blank\" rel=\"noopener\">https://wiki.qemu.org/Documentation/QMP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是QMP协议\"><a href=\"#什么是QMP协议\" class=\"headerlink\" title=\"什么是QMP协议\"></a>什么是QMP协议</h2><p>QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h2 id=\"QMP协议有哪些特征\"><a href=\"#QMP协议有哪些特征\" class=\"headerlink\" title=\"QMP协议有哪些特征\"></a>QMP协议有哪些特征</h2><p>1）轻量、基于文本、指令格式易于解析，因为它是json格式的；<br>2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；<br>3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。</p>\n<h2 id=\"QMP协议有哪些模式\"><a href=\"#QMP协议有哪些模式\" class=\"headerlink\" title=\"QMP协议有哪些模式\"></a>QMP协议有哪些模式</h2><p> 有两种模式：Capabilities Negotiation模式和Command模式。</p>\n<h2 id=\"那么该如何建立qmp连接呢\"><a href=\"#那么该如何建立qmp连接呢\" class=\"headerlink\" title=\"那么该如何建立qmp连接呢\"></a>那么该如何建立qmp连接呢</h2><p>这里简要介绍通过tcp和unix socket使用qmp。</p>\n<h3 id=\"通过TCP使用QMP\"><a href=\"#通过TCP使用QMP\" class=\"headerlink\" title=\"通过TCP使用QMP\"></a>通过TCP使用QMP</h3><p>使用-qmp添加qmp相关参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -<span class=\"built_in\">enable</span>-kvm -qmp tcp:localhost:1234,server,nowait</span><br></pre></td></tr></table></figure>\n<p>新开一个终端使用telnet 链接localhost：1234</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 1234</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用qmp的命令和虚拟机交互了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# telnet localhost 1234</span><br><span class=\"line\">Trying ::1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is &apos;^]&apos;.</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过unix-socket使用QMP\"><a href=\"#通过unix-socket使用QMP\" class=\"headerlink\" title=\"通过unix socket使用QMP\"></a>通过unix socket使用QMP</h3><p>使用unix socket创建qmp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait</span><br></pre></td></tr></table></figure>\n<p>使用nc连接该socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -U /tmp/qmp-test</span><br></pre></td></tr></table></figure>\n<p>之后就一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost qmp]# nc -U /tmp/qmp-test</span><br><span class=\"line\">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class=\"line\">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class=\"line\">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。</p>\n<h3 id=\"自动批量发送QMP命令\"><a href=\"#自动批量发送QMP命令\" class=\"headerlink\" title=\"自动批量发送QMP命令\"></a>自动批量发送QMP命令</h3><p>可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># QEMU Monitor Protocol Python class</span><br><span class=\"line\">#</span><br><span class=\"line\"># Copyright (C) 2009 Red Hat Inc.</span><br><span class=\"line\">#</span><br><span class=\"line\"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class=\"line\"># the COPYING file in the top-level directory.</span><br><span class=\"line\"></span><br><span class=\"line\">import socket, json, time, commands</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPError(Exception):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QMPConnectError(QMPError):</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">class QEMUMonitorProtocol:</span><br><span class=\"line\">    def connect(self):</span><br><span class=\"line\">        print self.filename</span><br><span class=\"line\">        self.sock.connect(self.filename)</span><br><span class=\"line\">        data = self.__json_read()</span><br><span class=\"line\">        if data == None:</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        if not data.has_key(&apos;QMP&apos;):</span><br><span class=\"line\">            raise QMPConnectError</span><br><span class=\"line\">        return data[&apos;QMP&apos;][&apos;capabilities&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">    def close(self):</span><br><span class=\"line\">        self.sock.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send_raw(self, line):</span><br><span class=\"line\">        self.sock.send(str(line))</span><br><span class=\"line\">        return self.__json_read()</span><br><span class=\"line\"></span><br><span class=\"line\">    def send(self, cmdline, timeout=30, convert=True):</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        if convert:</span><br><span class=\"line\">            cmd = self.__build_cmd(cmdline)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            cmd = cmdline</span><br><span class=\"line\">\t    print(&quot;*cmdline = %s&quot; % cmd)</span><br><span class=\"line\">        print cmd</span><br><span class=\"line\">        self.__json_send(cmd)</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            resp = self.__json_read()</span><br><span class=\"line\">            if resp == None:</span><br><span class=\"line\">                return (False, None)</span><br><span class=\"line\">            elif resp.has_key(&apos;error&apos;):</span><br><span class=\"line\">                return (False, resp[&apos;error&apos;])</span><br><span class=\"line\">            elif resp.has_key(&apos;return&apos;):</span><br><span class=\"line\">                return (True, resp[&apos;return&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">    def read(self, timeout=30):</span><br><span class=\"line\">        o = &quot;&quot;</span><br><span class=\"line\">        end_time = time.time() + timeout</span><br><span class=\"line\">        while time.time() &lt; end_time:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                o += self.sock.recv(1024)</span><br><span class=\"line\">                if len(o) &gt; 0:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                time.sleep(0.01)</span><br><span class=\"line\">        if len(o) &gt; 0:</span><br><span class=\"line\">            return json.loads(o)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return None</span><br><span class=\"line\"></span><br><span class=\"line\">    def __build_cmd(self, cmdline):</span><br><span class=\"line\">        cmdargs = cmdline.split()</span><br><span class=\"line\">        qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125;</span><br><span class=\"line\">        for arg in cmdargs[1:]:</span><br><span class=\"line\">            opt = arg.split(&apos;=&apos;)</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                value = int(opt[1])</span><br><span class=\"line\">            except ValueError:</span><br><span class=\"line\">                value = opt[1]</span><br><span class=\"line\">            qmpcmd[&apos;arguments&apos;][opt[0]] = value</span><br><span class=\"line\">\tprint(&quot;*cmdline = %s&quot; % cmdline)</span><br><span class=\"line\">        return qmpcmd</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_send(self, cmd):</span><br><span class=\"line\">        # XXX: We have to send any additional char, otherwise</span><br><span class=\"line\">        # the Server won&apos;t read our input</span><br><span class=\"line\">        self.sock.send(json.dumps(cmd) + &apos; &apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __json_read(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            return json.loads(self.sock.recv(1024))</span><br><span class=\"line\">        except ValueError:</span><br><span class=\"line\">            return</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, filename, protocol=&quot;tcp&quot;):</span><br><span class=\"line\">        if protocol == &quot;tcp&quot;:</span><br><span class=\"line\">            self.filename = (&quot;localhost&quot;, int(filename))</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">        elif protocol == &quot;unix&quot;:</span><br><span class=\"line\">            self.filename = filename</span><br><span class=\"line\">            print self.filename</span><br><span class=\"line\">            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class=\"line\">        #self.sock.setblocking(0)</span><br><span class=\"line\">        self.sock.settimeout(5)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    parser = OptionParser()</span><br><span class=\"line\">    parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;)</span><br><span class=\"line\">    parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;)</span><br><span class=\"line\">    def usage():</span><br><span class=\"line\">        parser.print_help()</span><br><span class=\"line\">        sys.exit(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    options, args = parser.parse_args()</span><br><span class=\"line\"></span><br><span class=\"line\">    print options</span><br><span class=\"line\">    if len(args) &gt; 0:</span><br><span class=\"line\">        usage()</span><br><span class=\"line\"></span><br><span class=\"line\">    num = int(options.num)</span><br><span class=\"line\">    qmp_filename = options.port</span><br><span class=\"line\">    qmp_protocol = options.protocol</span><br><span class=\"line\">    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)</span><br><span class=\"line\">    qmp_socket.connect()</span><br><span class=\"line\">    qmp_socket.send(&quot;qmp_capabilities&quot;)</span><br><span class=\"line\">    qmp_socket.close()</span><br><span class=\"line\"></span><br><span class=\"line\">##########################################################</span><br><span class=\"line\">#Usage</span><br><span class=\"line\">#Options:</span><br><span class=\"line\">#  -h, --help            show this help message and exit</span><br><span class=\"line\">#  -n NUM, --num=NUM     Times want to try</span><br><span class=\"line\">#  -f PORT, --file=PORT  QMP port/filename</span><br><span class=\"line\">#  -p PROTOCOL, --protocol=PROTOCOL</span><br><span class=\"line\">#                        QMP protocol</span><br><span class=\"line\"># e.g: # python xxxxx.py -n $NUM -f $PORT</span><br><span class=\"line\">##########################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>关于QMP更详细的文档，可以参考其官方文档：<br><a href=\"https://wiki.qemu.org/Documentation/QMP\" target=\"_blank\" rel=\"noopener\">https://wiki.qemu.org/Documentation/QMP</a></p>\n"},{"title":"KVM源代码分析1:基本工作原理","donate":true,"date":"2014-12-11T01:28:48.000Z","_content":"\n原文出自：http://oenhan.com/kvm-src-1\n文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发\n\n#### 1.KVM模型结构\n\n为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。\n\n![](hypervisor-1.png)\n\n当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子[内存分配](http://www.oenhan.com/kernel-program-exec)，[进程调度](http://www.oenhan.com/task-group-sched)等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。\n\nguest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，[内存管理](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。\n\n![](kvm_arch_map-1.png)\n\n如上图所示，guest自身有自己的用户模式和[内核模式](http://www.oenhan.com/iowait-wa-vmstat \"iowait的形成原因和内核分析\")；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行[创建进程](http://www.oenhan.com/cpu-load-balance \"Linux内核CPU负载均衡机制\")或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。\n\n#### 2.KVM工作原理\n\n![](kvm_process-1.png)\n\n上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。\n\n#### 3.CPU虚拟化\n\nX86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。\n\nVMM调度guest执行时，qemu 通过 ioctl [系统调用](http://www.oenhan.com/kernel-program-exec)进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。\n\n当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。\n\n#### 4.Mem虚拟化\n\nOS对于物理内存主要有两点认识：1.物理地址从0开始；2.[内存地址](http://www.oenhan.com/kernel-program-exec)是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。\n\n在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。\n\n这样MEM虚拟化就是GVA->GPA->HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。\n\n总体描述到此，后面代码里面见真相。\n","source":"_posts/kvm-src-1.md","raw":"---\ntitle: KVM源代码分析1:基本工作原理\ndonate: true\ndate: 2014-12-11 09:28:48\ncategories: KVM\ntags: KVM\n---\n\n原文出自：http://oenhan.com/kvm-src-1\n文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发\n\n#### 1.KVM模型结构\n\n为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。\n\n![](hypervisor-1.png)\n\n当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子[内存分配](http://www.oenhan.com/kernel-program-exec)，[进程调度](http://www.oenhan.com/task-group-sched)等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。\n\nguest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，[内存管理](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。\n\n![](kvm_arch_map-1.png)\n\n如上图所示，guest自身有自己的用户模式和[内核模式](http://www.oenhan.com/iowait-wa-vmstat \"iowait的形成原因和内核分析\")；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行[创建进程](http://www.oenhan.com/cpu-load-balance \"Linux内核CPU负载均衡机制\")或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。\n\n#### 2.KVM工作原理\n\n![](kvm_process-1.png)\n\n上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。\n\n#### 3.CPU虚拟化\n\nX86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。\n\nVMM调度guest执行时，qemu 通过 ioctl [系统调用](http://www.oenhan.com/kernel-program-exec)进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。\n\n当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。\n\n#### 4.Mem虚拟化\n\nOS对于物理内存主要有两点认识：1.物理地址从0开始；2.[内存地址](http://www.oenhan.com/kernel-program-exec)是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。\n\n在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。\n\n这样MEM虚拟化就是GVA->GPA->HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。\n\n总体描述到此，后面代码里面见真相。\n","slug":"kvm-src-1","published":1,"updated":"2018-12-11T02:28:56.744Z","_id":"cjpj2qxl9000dy0o4a5wekojb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原文出自：<a href=\"http://oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">http://oenhan.com/kvm-src-1</a><br>文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发</p>\n<h4 id=\"1-KVM模型结构\"><a href=\"#1-KVM模型结构\" class=\"headerlink\" title=\"1.KVM模型结构\"></a>1.KVM模型结构</h4><p>为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。</p>\n<p><img src=\"/2014/12/11/kvm-src-1/hypervisor-1.png\" alt=\"\"></p>\n<p>当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">内存分配</a>，<a href=\"http://www.oenhan.com/task-group-sched\" target=\"_blank\" rel=\"noopener\">进程调度</a>等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。</p>\n<p>guest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存管理</a>，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。</p>\n<p><img src=\"/2014/12/11/kvm-src-1/kvm_arch_map-1.png\" alt=\"\"></p>\n<p>如上图所示，guest自身有自己的用户模式和<a href=\"http://www.oenhan.com/iowait-wa-vmstat\" title=\"iowait的形成原因和内核分析\" target=\"_blank\" rel=\"noopener\">内核模式</a>；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行<a href=\"http://www.oenhan.com/cpu-load-balance\" title=\"Linux内核CPU负载均衡机制\" target=\"_blank\" rel=\"noopener\">创建进程</a>或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。</p>\n<h4 id=\"2-KVM工作原理\"><a href=\"#2-KVM工作原理\" class=\"headerlink\" title=\"2.KVM工作原理\"></a>2.KVM工作原理</h4><p><img src=\"/2014/12/11/kvm-src-1/kvm_process-1.png\" alt=\"\"></p>\n<p>上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。</p>\n<h4 id=\"3-CPU虚拟化\"><a href=\"#3-CPU虚拟化\" class=\"headerlink\" title=\"3.CPU虚拟化\"></a>3.CPU虚拟化</h4><p>X86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。</p>\n<p>VMM调度guest执行时，qemu 通过 ioctl <a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">系统调用</a>进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。</p>\n<p>当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。</p>\n<h4 id=\"4-Mem虚拟化\"><a href=\"#4-Mem虚拟化\" class=\"headerlink\" title=\"4.Mem虚拟化\"></a>4.Mem虚拟化</h4><p>OS对于物理内存主要有两点认识：1.物理地址从0开始；2.<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">内存地址</a>是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。</p>\n<p>在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。</p>\n<p>这样MEM虚拟化就是GVA-&gt;GPA-&gt;HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。</p>\n<p>总体描述到此，后面代码里面见真相。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文出自：<a href=\"http://oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">http://oenhan.com/kvm-src-1</a><br>文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发</p>\n<h4 id=\"1-KVM模型结构\"><a href=\"#1-KVM模型结构\" class=\"headerlink\" title=\"1.KVM模型结构\"></a>1.KVM模型结构</h4><p>为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。</p>\n<p><img src=\"/2014/12/11/kvm-src-1/hypervisor-1.png\" alt=\"\"></p>\n<p>当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">内存分配</a>，<a href=\"http://www.oenhan.com/task-group-sched\" target=\"_blank\" rel=\"noopener\">进程调度</a>等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。</p>\n<p>guest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存管理</a>，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。</p>\n<p><img src=\"/2014/12/11/kvm-src-1/kvm_arch_map-1.png\" alt=\"\"></p>\n<p>如上图所示，guest自身有自己的用户模式和<a href=\"http://www.oenhan.com/iowait-wa-vmstat\" title=\"iowait的形成原因和内核分析\" target=\"_blank\" rel=\"noopener\">内核模式</a>；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行<a href=\"http://www.oenhan.com/cpu-load-balance\" title=\"Linux内核CPU负载均衡机制\" target=\"_blank\" rel=\"noopener\">创建进程</a>或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。</p>\n<h4 id=\"2-KVM工作原理\"><a href=\"#2-KVM工作原理\" class=\"headerlink\" title=\"2.KVM工作原理\"></a>2.KVM工作原理</h4><p><img src=\"/2014/12/11/kvm-src-1/kvm_process-1.png\" alt=\"\"></p>\n<p>上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。</p>\n<h4 id=\"3-CPU虚拟化\"><a href=\"#3-CPU虚拟化\" class=\"headerlink\" title=\"3.CPU虚拟化\"></a>3.CPU虚拟化</h4><p>X86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。</p>\n<p>VMM调度guest执行时，qemu 通过 ioctl <a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">系统调用</a>进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。</p>\n<p>当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。</p>\n<h4 id=\"4-Mem虚拟化\"><a href=\"#4-Mem虚拟化\" class=\"headerlink\" title=\"4.Mem虚拟化\"></a>4.Mem虚拟化</h4><p>OS对于物理内存主要有两点认识：1.物理地址从0开始；2.<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">内存地址</a>是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。</p>\n<p>在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。</p>\n<p>这样MEM虚拟化就是GVA-&gt;GPA-&gt;HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。</p>\n<p>总体描述到此，后面代码里面见真相。</p>\n"},{"title":"KVM源代码分析2:虚拟机的创建与运行","donate":true,"date":"2014-12-11T01:38:35.000Z","_content":"\n原文链接：http://oenhan.com/kvm-src-2-vm-run\n\n前段时间挖了一个坑，[KVM源代码分析1:基本工作原理](http://www.oenhan.com/kvm-src-1)，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和[内核态驱动](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从[虚拟机](http://www.oenhan.com/sort-optimal-solution \"比较排序的最优解\")的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。\n\n代码：\n\nQEMU：git://git.qemu.org/qemu.git v2.4.0\n\nKVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2\n\nQEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。\n\n使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。\n\n而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。\n\n所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。\n\n所有看QEMU和KVM的配合流程如下：\n\n![](http://oenhan.com/wp-content/uploads/2014/12/qemu_create_kvm_vm-1.png)\n\n接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出[处理函数](http://www.oenhan.com/5w2h \"5W2H:技术活动逻辑方法\")，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedef enum {\n    MODULE_INIT_BLOCK,\n    MODULE_INIT_MACHINE,\n    MODULE_INIT_QAPI,\n    MODULE_INIT_QOM,\n    MODULE_INIT_MAX\n} module_init_type;\n</pre>\n\n最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种[模拟设备](http://www.oenhan.com/ext3-jbd-journal \"journal block device代码分析\")，具体可以参考http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。 module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图  \n![](http://oenhan.com/wp-content/uploads/2014/04/qemu_module_init-1.png)\n\n它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e->init()完成功能的，而e->init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n\\#define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n\\#define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\\##suffix(MachineState *machine)\n    {\n        void (*compat)(MachineState *m) = (compatfn);\n        if (compat) {\n            compat(machine);\n        }\n        pc_init1(machine);\n    }\n    DEFINE_PC_MACHINE(suffix, name, pc_init_\\##suffix, optionfn)\n\n\\#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)\n    static void pc_machine_\\##suffix##_class_init(ObjectClass *oc, void *data)\n    {\n        MachineClass *mc = MACHINE_CLASS(oc);\n        optsfn(mc);\n        mc->name = namestr;\n        mc->init = initfn;\n    }\n    static const TypeInfo pc_machine_type_\\##suffix = {\n        .name       = namestr TYPE_MACHINE_SUFFIX,\n        .parent     = TYPE_PC_MACHINE,\n        .class_init = pc_machine_\\##suffix##_class_init,\n    };\n    static void pc_machine_init_\\##suffix(void)\n    {\n        type_register(&pc_machine_type_\\##suffix);\n    }\n    machine_init(pc_machine_init_\\##suffix)\n</pre>\n\nDEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc->init，其他爱看不看吧。  \n而module_init的宏是\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_dso_module_init(function, type);\n}\n\\#else\n/* This should not be used directly.  Use block_init etc. instead.  */\n\\#define module_init(function, type)\nstatic void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_module_init(function, type);\n}\n</pre>\n\n它前面的修饰是__attribute__((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-> kvm_accel_type -> kvm_accel_class_init -> kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。\n如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机[句柄](http://www.oenhan.com/kernel-deadlock-check \"Linux内核死锁检测机制\")。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对[内存管理](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。\n\n这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc->init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。\n\n下面涉及对OPT入参的解析过程略过不提。 qemu准备[模拟的机器](http://www.oenhan.com/cgroups-src-1 \"Cgroups源码分析1:基本概念与框架\")的类型从下面语句获得:\n\n<pre class=\"lang:c decode:1 hljs nginx\">\ncurrent_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n</pre>\n\nmachine_class则是通过入参传入的\n\n<pre class=\"lang:c decode:1 hljs bash\">\ncase QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n</pre>\n\nman qemu\n\n<pre class=\"lang:shell decode:1 hljs sql\">\n       -machine [type=]name[,prop=value[,...]]\n           Select the emulated machine by name.\n           Use \"-machine help\" to list available machines\n</pre>\n\n下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class->init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。\n\n现在进入pc_init1函数：\n\n在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。  \npc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\n    {\n        .name = \"SandyBridge\",\n        .level = 0xd,\n        .vendor = CPUID_VENDOR_INTEL,\n        .family = 6,\n        .model = 42,\n        .stepping = 1,\n        .features[FEAT_1_EDX] =\n            CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |\n            CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |\n            CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |\n            CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |\n            CPUID_DE | CPUID_FP87,\n        .features[FEAT_1_ECX] =\n            CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |\n            CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |\n            CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |\n            CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |\n            CPUID_EXT_SSE3,\n        .features[FEAT_8000_0001_EDX] =\n            CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |\n            CPUID_EXT2_SYSCALL,\n        .features[FEAT_8000_0001_ECX] =\n            CPUID_EXT3_LAHF_LM,\n        .features[FEAT_XSAVE] =\n            CPUID_XSAVE_XSAVEOPT,\n        .features[FEAT_6_EAX] =\n            CPUID_6_EAX_ARAT,\n        .xlevel = 0x80000008,\n        .model_id = \"Intel Xeon E312xx (Sandy Bridge)\",\n    },\n</pre>\n\n你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。  \n然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，  \n主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：\n\n<pre class=\"lang:c decode:1 hljs php\">\n//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn\n    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n    //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n</pre>\n\n线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\n//初始化VCPU\n    r = kvm_init_vcpu(env);\n//初始化KVM中断\n    qemu_kvm_init_cpu_signals(env);\n\n//标志VCPU创建完成，和上面判断是对应的\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n    while (1) {\n        if (cpu_can_run(env)) {\n          //CPU进入执行状态\n            r = kvm_cpu_exec(env);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(env);\n            }\n        }\n        qemu_kvm_wait_io_event(env);\n    }\n</pre>\n\nCPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env->kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。  \nqemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看[内存的初始化](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")。  \n内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。  \n![](http://oenhan.com/wp-content/uploads/2014/04/qemu_memory_module-1.bmp)\n\nqemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。  \n而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页[对齐分配](http://www.oenhan.com/ubuntu-debuginfo-package \"ubuntu下载debuginfo deb进行调试\")内存。后续的都是对RAMBlock的插入等处理。  \n从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。  \nvmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr->name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。  \n后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr->owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。  \nmemory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。  \n下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：\n\n<pre class=\"lang:c decode:1 hljs php\">\nwhile (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) { //这个判断代码添加的无用，可以直接删除,\n                //address_space_update_topology里面的两个pass也可以删除一个\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frold->dirty_log_mask && !frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);\n                } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n            }\n\n            ++inew;\n        }\n    }\n</pre>\n\n重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem)传递给kernel。  \n我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。  \n内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：\n\n<pre class=\"lang:c decode:1 hljs bash\">\nwhile (1) {\n        if (cpu_can_run(cpu)) {\n            r = kvm_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n        qemu_kvm_wait_io_event(cpu);\n    }\n</pre>\n\n判断条件就是cpu_can_run函数，即cpu->stop && cpu->stopped && current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid vm_start(void){\n    if (!runstate_is_running()) {\n        cpu_enable_ticks();\n        runstate_set(RUN_STATE_RUNNING);\n        vm_state_notify(1, RUN_STATE_RUNNING);\n        resume_all_vcpus();\n        monitor_protocol_event(QEVENT_RESUME, NULL);\n    }\n}\n</pre>\n\n如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。\n","source":"_posts/kvm-src-2-vm-run.md","raw":"---\ntitle: KVM源代码分析2:虚拟机的创建与运行\ndonate: true\ndate: 2014-12-11 09:38:35\ncategories: KVM\ntags: KVM\n---\n\n原文链接：http://oenhan.com/kvm-src-2-vm-run\n\n前段时间挖了一个坑，[KVM源代码分析1:基本工作原理](http://www.oenhan.com/kvm-src-1)，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和[内核态驱动](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从[虚拟机](http://www.oenhan.com/sort-optimal-solution \"比较排序的最优解\")的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。\n\n代码：\n\nQEMU：git://git.qemu.org/qemu.git v2.4.0\n\nKVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2\n\nQEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。\n\n使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。\n\n而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。\n\n所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。\n\n所有看QEMU和KVM的配合流程如下：\n\n![](http://oenhan.com/wp-content/uploads/2014/12/qemu_create_kvm_vm-1.png)\n\n接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出[处理函数](http://www.oenhan.com/5w2h \"5W2H:技术活动逻辑方法\")，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedef enum {\n    MODULE_INIT_BLOCK,\n    MODULE_INIT_MACHINE,\n    MODULE_INIT_QAPI,\n    MODULE_INIT_QOM,\n    MODULE_INIT_MAX\n} module_init_type;\n</pre>\n\n最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种[模拟设备](http://www.oenhan.com/ext3-jbd-journal \"journal block device代码分析\")，具体可以参考http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。 module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图  \n![](http://oenhan.com/wp-content/uploads/2014/04/qemu_module_init-1.png)\n\n它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e->init()完成功能的，而e->init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n\\#define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n\\#define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\\##suffix(MachineState *machine)\n    {\n        void (*compat)(MachineState *m) = (compatfn);\n        if (compat) {\n            compat(machine);\n        }\n        pc_init1(machine);\n    }\n    DEFINE_PC_MACHINE(suffix, name, pc_init_\\##suffix, optionfn)\n\n\\#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)\n    static void pc_machine_\\##suffix##_class_init(ObjectClass *oc, void *data)\n    {\n        MachineClass *mc = MACHINE_CLASS(oc);\n        optsfn(mc);\n        mc->name = namestr;\n        mc->init = initfn;\n    }\n    static const TypeInfo pc_machine_type_\\##suffix = {\n        .name       = namestr TYPE_MACHINE_SUFFIX,\n        .parent     = TYPE_PC_MACHINE,\n        .class_init = pc_machine_\\##suffix##_class_init,\n    };\n    static void pc_machine_init_\\##suffix(void)\n    {\n        type_register(&pc_machine_type_\\##suffix);\n    }\n    machine_init(pc_machine_init_\\##suffix)\n</pre>\n\nDEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc->init，其他爱看不看吧。  \n而module_init的宏是\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_dso_module_init(function, type);\n}\n\\#else\n/* This should not be used directly.  Use block_init etc. instead.  */\n\\#define module_init(function, type)\nstatic void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_module_init(function, type);\n}\n</pre>\n\n它前面的修饰是__attribute__((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-> kvm_accel_type -> kvm_accel_class_init -> kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。\n如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机[句柄](http://www.oenhan.com/kernel-deadlock-check \"Linux内核死锁检测机制\")。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对[内存管理](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。\n\n这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc->init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。\n\n下面涉及对OPT入参的解析过程略过不提。 qemu准备[模拟的机器](http://www.oenhan.com/cgroups-src-1 \"Cgroups源码分析1:基本概念与框架\")的类型从下面语句获得:\n\n<pre class=\"lang:c decode:1 hljs nginx\">\ncurrent_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n</pre>\n\nmachine_class则是通过入参传入的\n\n<pre class=\"lang:c decode:1 hljs bash\">\ncase QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n</pre>\n\nman qemu\n\n<pre class=\"lang:shell decode:1 hljs sql\">\n       -machine [type=]name[,prop=value[,...]]\n           Select the emulated machine by name.\n           Use \"-machine help\" to list available machines\n</pre>\n\n下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class->init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。\n\n现在进入pc_init1函数：\n\n在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。  \npc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\n    {\n        .name = \"SandyBridge\",\n        .level = 0xd,\n        .vendor = CPUID_VENDOR_INTEL,\n        .family = 6,\n        .model = 42,\n        .stepping = 1,\n        .features[FEAT_1_EDX] =\n            CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |\n            CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |\n            CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |\n            CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |\n            CPUID_DE | CPUID_FP87,\n        .features[FEAT_1_ECX] =\n            CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |\n            CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |\n            CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |\n            CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |\n            CPUID_EXT_SSE3,\n        .features[FEAT_8000_0001_EDX] =\n            CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |\n            CPUID_EXT2_SYSCALL,\n        .features[FEAT_8000_0001_ECX] =\n            CPUID_EXT3_LAHF_LM,\n        .features[FEAT_XSAVE] =\n            CPUID_XSAVE_XSAVEOPT,\n        .features[FEAT_6_EAX] =\n            CPUID_6_EAX_ARAT,\n        .xlevel = 0x80000008,\n        .model_id = \"Intel Xeon E312xx (Sandy Bridge)\",\n    },\n</pre>\n\n你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。  \n然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，  \n主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：\n\n<pre class=\"lang:c decode:1 hljs php\">\n//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn\n    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n    //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n</pre>\n\n线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作\n\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\n//初始化VCPU\n    r = kvm_init_vcpu(env);\n//初始化KVM中断\n    qemu_kvm_init_cpu_signals(env);\n\n//标志VCPU创建完成，和上面判断是对应的\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n    while (1) {\n        if (cpu_can_run(env)) {\n          //CPU进入执行状态\n            r = kvm_cpu_exec(env);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(env);\n            }\n        }\n        qemu_kvm_wait_io_event(env);\n    }\n</pre>\n\nCPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env->kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。  \nqemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看[内存的初始化](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")。  \n内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。  \n![](http://oenhan.com/wp-content/uploads/2014/04/qemu_memory_module-1.bmp)\n\nqemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。  \n而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页[对齐分配](http://www.oenhan.com/ubuntu-debuginfo-package \"ubuntu下载debuginfo deb进行调试\")内存。后续的都是对RAMBlock的插入等处理。  \n从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。  \nvmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr->name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。  \n后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr->owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。  \nmemory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。  \n下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：\n\n<pre class=\"lang:c decode:1 hljs php\">\nwhile (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) { //这个判断代码添加的无用，可以直接删除,\n                //address_space_update_topology里面的两个pass也可以删除一个\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frold->dirty_log_mask && !frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);\n                } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n            }\n\n            ++inew;\n        }\n    }\n</pre>\n\n重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem)传递给kernel。  \n我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。  \n内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：\n\n<pre class=\"lang:c decode:1 hljs bash\">\nwhile (1) {\n        if (cpu_can_run(cpu)) {\n            r = kvm_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n        qemu_kvm_wait_io_event(cpu);\n    }\n</pre>\n\n判断条件就是cpu_can_run函数，即cpu->stop && cpu->stopped && current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid vm_start(void){\n    if (!runstate_is_running()) {\n        cpu_enable_ticks();\n        runstate_set(RUN_STATE_RUNNING);\n        vm_state_notify(1, RUN_STATE_RUNNING);\n        resume_all_vcpus();\n        monitor_protocol_event(QEVENT_RESUME, NULL);\n    }\n}\n</pre>\n\n如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。\n","slug":"kvm-src-2-vm-run","published":1,"updated":"2018-12-11T02:28:26.076Z","_id":"cjpj2ui2v0000ydo4ap3hu06u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原文链接：<a href=\"http://oenhan.com/kvm-src-2-vm-run\" target=\"_blank\" rel=\"noopener\">http://oenhan.com/kvm-src-2-vm-run</a></p>\n<p>前段时间挖了一个坑，<a href=\"http://www.oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">KVM源代码分析1:基本工作原理</a>，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内核态驱动</a>kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从<a href=\"http://www.oenhan.com/sort-optimal-solution\" title=\"比较排序的最优解\" target=\"_blank\" rel=\"noopener\">虚拟机</a>的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。</p>\n<p>代码：</p>\n<p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p>\n<p>KVM：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p>\n<p>QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。</p>\n<p>使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。</p>\n<p>而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。</p>\n<p>所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。</p>\n<p>所有看QEMU和KVM的配合流程如下：</p>\n<p><img src=\"http://oenhan.com/wp-content/uploads/2014/12/qemu_create_kvm_vm-1.png\" alt=\"\"></p>\n<p>接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出<a href=\"http://www.oenhan.com/5w2h\" title=\"5W2H:技术活动逻辑方法\" target=\"_blank\" rel=\"noopener\">处理函数</a>，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedef enum {\n    MODULE_INIT_BLOCK,\n    MODULE_INIT_MACHINE,\n    MODULE_INIT_QAPI,\n    MODULE_INIT_QOM,\n    MODULE_INIT_MAX\n} module_init_type;\n</pre>\n\n<p>最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种<a href=\"http://www.oenhan.com/ext3-jbd-journal\" title=\"journal block device代码分析\" target=\"_blank\" rel=\"noopener\">模拟设备</a>，具体可以参考<a href=\"http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。\" target=\"_blank\" rel=\"noopener\">http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。</a> module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图<br><img src=\"http://oenhan.com/wp-content/uploads/2014/04/qemu_module_init-1.png\" alt=\"\"></p>\n<p>它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e-&gt;init()完成功能的，而e-&gt;init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n\\#define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n\\#define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n<p>那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\\##suffix(MachineState *machine)\n    {\n        void (*compat)(MachineState *m) = (compatfn);\n        if (compat) {\n            compat(machine);\n        }\n        pc_init1(machine);\n    }\n    DEFINE_PC_MACHINE(suffix, name, pc_init_\\##suffix, optionfn)\n\n\\#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)\n    static void pc_machine_\\##suffix##_class_init(ObjectClass *oc, void *data)\n    {\n        MachineClass *mc = MACHINE_CLASS(oc);\n        optsfn(mc);\n        mc->name = namestr;\n        mc->init = initfn;\n    }\n    static const TypeInfo pc_machine_type_\\##suffix = {\n        .name       = namestr TYPE_MACHINE_SUFFIX,\n        .parent     = TYPE_PC_MACHINE,\n        .class_init = pc_machine_\\##suffix##_class_init,\n    };\n    static void pc_machine_init_\\##suffix(void)\n    {\n        type_register(&pc_machine_type_\\##suffix);\n    }\n    machine_init(pc_machine_init_\\##suffix)\n</pre>\n\n<p>DEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc-&gt;init，其他爱看不看吧。<br>而module_init的宏是</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_dso_module_init(function, type);\n}\n\\#else\n/* This should not be used directly.  Use block_init etc. instead.  */\n\\#define module_init(function, type)\nstatic void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_module_init(function, type);\n}\n</pre>\n\n<p>它前面的修饰是<strong>attribute</strong>((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-&gt; kvm_accel_type -&gt; kvm_accel_class_init -&gt; kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。<br>如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机<a href=\"http://www.oenhan.com/kernel-deadlock-check\" title=\"Linux内核死锁检测机制\" target=\"_blank\" rel=\"noopener\">句柄</a>。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存管理</a>的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。</p>\n<p>这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc-&gt;init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。</p>\n<p>下面涉及对OPT入参的解析过程略过不提。 qemu准备<a href=\"http://www.oenhan.com/cgroups-src-1\" title=\"Cgroups源码分析1:基本概念与框架\" target=\"_blank\" rel=\"noopener\">模拟的机器</a>的类型从下面语句获得:</p>\n<pre class=\"lang:c decode:1 hljs nginx\">\ncurrent_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n</pre>\n\n<p>machine_class则是通过入参传入的</p>\n<pre class=\"lang:c decode:1 hljs bash\">\ncase QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n</pre>\n\n<p>man qemu</p>\n<pre class=\"lang:shell decode:1 hljs sql\">\n       -machine [type=]name[,prop=value[,...]]\n           Select the emulated machine by name.\n           Use \"-machine help\" to list available machines\n</pre>\n\n<p>下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class-&gt;init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。</p>\n<p>现在进入pc_init1函数：</p>\n<p>在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。<br>pc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\n    {\n        .name = \"SandyBridge\",\n        .level = 0xd,\n        .vendor = CPUID_VENDOR_INTEL,\n        .family = 6,\n        .model = 42,\n        .stepping = 1,\n        .features[FEAT_1_EDX] =\n            CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |\n            CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |\n            CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |\n            CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |\n            CPUID_DE | CPUID_FP87,\n        .features[FEAT_1_ECX] =\n            CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |\n            CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |\n            CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |\n            CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |\n            CPUID_EXT_SSE3,\n        .features[FEAT_8000_0001_EDX] =\n            CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |\n            CPUID_EXT2_SYSCALL,\n        .features[FEAT_8000_0001_ECX] =\n            CPUID_EXT3_LAHF_LM,\n        .features[FEAT_XSAVE] =\n            CPUID_XSAVE_XSAVEOPT,\n        .features[FEAT_6_EAX] =\n            CPUID_6_EAX_ARAT,\n        .xlevel = 0x80000008,\n        .model_id = \"Intel Xeon E312xx (Sandy Bridge)\",\n    },\n</pre>\n\n<p>你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。<br>然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，<br>主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：</p>\n<pre class=\"lang:c decode:1 hljs php\">\n//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn\n    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n    //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n</pre>\n\n<p>线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n<p>从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\n//初始化VCPU\n    r = kvm_init_vcpu(env);\n//初始化KVM中断\n    qemu_kvm_init_cpu_signals(env);\n\n//标志VCPU创建完成，和上面判断是对应的\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n    while (1) {\n        if (cpu_can_run(env)) {\n          //CPU进入执行状态\n            r = kvm_cpu_exec(env);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(env);\n            }\n        }\n        qemu_kvm_wait_io_event(env);\n    }\n</pre>\n\n<p>CPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env-&gt;kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。<br>qemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存的初始化</a>。<br>内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。<br><img src=\"http://oenhan.com/wp-content/uploads/2014/04/qemu_memory_module-1.bmp\" alt=\"\"></p>\n<p>qemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。<br>而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页<a href=\"http://www.oenhan.com/ubuntu-debuginfo-package\" title=\"ubuntu下载debuginfo deb进行调试\" target=\"_blank\" rel=\"noopener\">对齐分配</a>内存。后续的都是对RAMBlock的插入等处理。<br>从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。<br>vmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr-&gt;name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。<br>后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr-&gt;owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。<br>memory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。<br>下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：</p>\n<pre class=\"lang:c decode:1 hljs php\">\nwhile (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) { //这个判断代码添加的无用，可以直接删除,\n                //address_space_update_topology里面的两个pass也可以删除一个\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frold->dirty_log_mask && !frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);\n                } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n            }\n\n            ++inew;\n        }\n    }\n</pre>\n\n<p>重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem)传递给kernel。<br>我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。<br>内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nwhile (1) {\n        if (cpu_can_run(cpu)) {\n            r = kvm_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n        qemu_kvm_wait_io_event(cpu);\n    }\n</pre>\n\n<p>判断条件就是cpu_can_run函数，即cpu-&gt;stop &amp;&amp; cpu-&gt;stopped &amp;&amp; current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid vm_start(void){\n    if (!runstate_is_running()) {\n        cpu_enable_ticks();\n        runstate_set(RUN_STATE_RUNNING);\n        vm_state_notify(1, RUN_STATE_RUNNING);\n        resume_all_vcpus();\n        monitor_protocol_event(QEVENT_RESUME, NULL);\n    }\n}\n</pre>\n\n<p>如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"http://oenhan.com/kvm-src-2-vm-run\" target=\"_blank\" rel=\"noopener\">http://oenhan.com/kvm-src-2-vm-run</a></p>\n<p>前段时间挖了一个坑，<a href=\"http://www.oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">KVM源代码分析1:基本工作原理</a>，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内核态驱动</a>kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从<a href=\"http://www.oenhan.com/sort-optimal-solution\" title=\"比较排序的最优解\" target=\"_blank\" rel=\"noopener\">虚拟机</a>的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。</p>\n<p>代码：</p>\n<p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p>\n<p>KVM：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p>\n<p>QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。</p>\n<p>使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。</p>\n<p>而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。</p>\n<p>所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。</p>\n<p>所有看QEMU和KVM的配合流程如下：</p>\n<p><img src=\"http://oenhan.com/wp-content/uploads/2014/12/qemu_create_kvm_vm-1.png\" alt=\"\"></p>\n<p>接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出<a href=\"http://www.oenhan.com/5w2h\" title=\"5W2H:技术活动逻辑方法\" target=\"_blank\" rel=\"noopener\">处理函数</a>，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedef enum {\n    MODULE_INIT_BLOCK,\n    MODULE_INIT_MACHINE,\n    MODULE_INIT_QAPI,\n    MODULE_INIT_QOM,\n    MODULE_INIT_MAX\n} module_init_type;\n</pre>\n\n<p>最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种<a href=\"http://www.oenhan.com/ext3-jbd-journal\" title=\"journal block device代码分析\" target=\"_blank\" rel=\"noopener\">模拟设备</a>，具体可以参考<a href=\"http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。\" target=\"_blank\" rel=\"noopener\">http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。</a> module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图<br><img src=\"http://oenhan.com/wp-content/uploads/2014/04/qemu_module_init-1.png\" alt=\"\"></p>\n<p>它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e-&gt;init()完成功能的，而e-&gt;init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n\\#define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n\\#define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n<p>那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\\##suffix(MachineState *machine)\n    {\n        void (*compat)(MachineState *m) = (compatfn);\n        if (compat) {\n            compat(machine);\n        }\n        pc_init1(machine);\n    }\n    DEFINE_PC_MACHINE(suffix, name, pc_init_\\##suffix, optionfn)\n\n\\#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)\n    static void pc_machine_\\##suffix##_class_init(ObjectClass *oc, void *data)\n    {\n        MachineClass *mc = MACHINE_CLASS(oc);\n        optsfn(mc);\n        mc->name = namestr;\n        mc->init = initfn;\n    }\n    static const TypeInfo pc_machine_type_\\##suffix = {\n        .name       = namestr TYPE_MACHINE_SUFFIX,\n        .parent     = TYPE_PC_MACHINE,\n        .class_init = pc_machine_\\##suffix##_class_init,\n    };\n    static void pc_machine_init_\\##suffix(void)\n    {\n        type_register(&pc_machine_type_\\##suffix);\n    }\n    machine_init(pc_machine_init_\\##suffix)\n</pre>\n\n<p>DEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc-&gt;init，其他爱看不看吧。<br>而module_init的宏是</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_dso_module_init(function, type);\n}\n\\#else\n/* This should not be used directly.  Use block_init etc. instead.  */\n\\#define module_init(function, type)\nstatic void __attribute__((constructor)) do_qemu_init_ \\## function(void)\n{\n    register_module_init(function, type);\n}\n</pre>\n\n<p>它前面的修饰是<strong>attribute</strong>((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-&gt; kvm_accel_type -&gt; kvm_accel_class_init -&gt; kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。<br>如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机<a href=\"http://www.oenhan.com/kernel-deadlock-check\" title=\"Linux内核死锁检测机制\" target=\"_blank\" rel=\"noopener\">句柄</a>。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存管理</a>的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。</p>\n<p>这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc-&gt;init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。</p>\n<p>下面涉及对OPT入参的解析过程略过不提。 qemu准备<a href=\"http://www.oenhan.com/cgroups-src-1\" title=\"Cgroups源码分析1:基本概念与框架\" target=\"_blank\" rel=\"noopener\">模拟的机器</a>的类型从下面语句获得:</p>\n<pre class=\"lang:c decode:1 hljs nginx\">\ncurrent_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n</pre>\n\n<p>machine_class则是通过入参传入的</p>\n<pre class=\"lang:c decode:1 hljs bash\">\ncase QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n</pre>\n\n<p>man qemu</p>\n<pre class=\"lang:shell decode:1 hljs sql\">\n       -machine [type=]name[,prop=value[,...]]\n           Select the emulated machine by name.\n           Use \"-machine help\" to list available machines\n</pre>\n\n<p>下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class-&gt;init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。</p>\n<p>现在进入pc_init1函数：</p>\n<p>在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。<br>pc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\n    {\n        .name = \"SandyBridge\",\n        .level = 0xd,\n        .vendor = CPUID_VENDOR_INTEL,\n        .family = 6,\n        .model = 42,\n        .stepping = 1,\n        .features[FEAT_1_EDX] =\n            CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |\n            CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |\n            CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |\n            CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |\n            CPUID_DE | CPUID_FP87,\n        .features[FEAT_1_ECX] =\n            CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |\n            CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |\n            CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |\n            CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |\n            CPUID_EXT_SSE3,\n        .features[FEAT_8000_0001_EDX] =\n            CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |\n            CPUID_EXT2_SYSCALL,\n        .features[FEAT_8000_0001_ECX] =\n            CPUID_EXT3_LAHF_LM,\n        .features[FEAT_XSAVE] =\n            CPUID_XSAVE_XSAVEOPT,\n        .features[FEAT_6_EAX] =\n            CPUID_6_EAX_ARAT,\n        .xlevel = 0x80000008,\n        .model_id = \"Intel Xeon E312xx (Sandy Bridge)\",\n    },\n</pre>\n\n<p>你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。<br>然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，<br>主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：</p>\n<pre class=\"lang:c decode:1 hljs php\">\n//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn\n    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,\n                       cpu, QEMU_THREAD_JOINABLE);\n    //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的\n    while (!cpu->created) {\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n    }\n</pre>\n\n<p>线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\n\\#define type_init(function) module_init(function, MODULE_INIT_QOM)\n</pre>\n\n<p>从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\n//初始化VCPU\n    r = kvm_init_vcpu(env);\n//初始化KVM中断\n    qemu_kvm_init_cpu_signals(env);\n\n//标志VCPU创建完成，和上面判断是对应的\n    cpu->created = true;\n    qemu_cond_signal(&qemu_cpu_cond);\n    while (1) {\n        if (cpu_can_run(env)) {\n          //CPU进入执行状态\n            r = kvm_cpu_exec(env);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(env);\n            }\n        }\n        qemu_kvm_wait_io_event(env);\n    }\n</pre>\n\n<p>CPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env-&gt;kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。<br>qemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">内存的初始化</a>。<br>内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。<br><img src=\"http://oenhan.com/wp-content/uploads/2014/04/qemu_memory_module-1.bmp\" alt=\"\"></p>\n<p>qemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。<br>而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页<a href=\"http://www.oenhan.com/ubuntu-debuginfo-package\" title=\"ubuntu下载debuginfo deb进行调试\" target=\"_blank\" rel=\"noopener\">对齐分配</a>内存。后续的都是对RAMBlock的插入等处理。<br>从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。<br>vmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr-&gt;name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。<br>后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr-&gt;owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。<br>memory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。<br>下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：</p>\n<pre class=\"lang:c decode:1 hljs php\">\nwhile (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) { //这个判断代码添加的无用，可以直接删除,\n                //address_space_update_topology里面的两个pass也可以删除一个\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frold->dirty_log_mask && !frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);\n                } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n            }\n\n            ++inew;\n        }\n    }\n</pre>\n\n<p>重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem)传递给kernel。<br>我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。<br>内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nwhile (1) {\n        if (cpu_can_run(cpu)) {\n            r = kvm_cpu_exec(cpu);\n            if (r == EXCP_DEBUG) {\n                cpu_handle_guest_debug(cpu);\n            }\n        }\n        qemu_kvm_wait_io_event(cpu);\n    }\n</pre>\n\n<p>判断条件就是cpu_can_run函数，即cpu-&gt;stop &amp;&amp; cpu-&gt;stopped &amp;&amp; current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid vm_start(void){\n    if (!runstate_is_running()) {\n        cpu_enable_ticks();\n        runstate_set(RUN_STATE_RUNNING);\n        vm_state_notify(1, RUN_STATE_RUNNING);\n        resume_all_vcpus();\n        monitor_protocol_event(QEVENT_RESUME, NULL);\n    }\n}\n</pre>\n\n<p>如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。</p>\n"},{"title":"KVM源代码分析3:CPU虚拟化","donate":true,"date":"2014-12-11T02:34:48.000Z","_content":"在[虚拟机的创建与运行](http://www.oenhan.com/kvm-src-2-vm-run \"KVM源代码分析2:虚拟机的创建与运行\")章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。\n\nQEMU：git://git.qemu.org/qemu.git v2.4.0\n\nKVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2\n\n#### 1.VT-x 技术\n\nIntel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。\n\n处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考[CPU的运行环、特权级与保护](http://blog.csdn.net/drshenlei/article/details/4265101)）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。\n\n为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问[中断寄存器](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。\n\n在[KVM源代码分析1:基本工作原理](http://www.oenhan.com/kvm-src-1)章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。\n\n如下图  \n![](kvm_vmx_intel-1.jpg)\n\n在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。\n\n#### 2.VMCS寄存器\n\nVMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的[寄存器](http://www.oenhan.com/gdb-principle \"gdb工作原理和内核实现\")（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。\n\nVMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域：\n\n<colgroup>\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\"> </colgroup>\ncol 1                  | col 2                                                    | col 3                                                            \n---------------------- | -------------------------------------------------------- | -----------------------------------------------------------------\n VM-execution controls |  Determines what operations cause VM exits               |  CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etc\nGuest-state area       |  Saved on VM exits，Reloaded on VM entry                  |  EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc            \n Host-state area       |  Loaded on VM exits                                      |  CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc      \n VM-exit controls      |  Determines which state to save, load, how to transition |  Example: MSR save-load list                                     \n VM-entry controls     |  Determines which state to load, how to transition       |  Including injecting events (interrupts, exceptions) on entry    \n\n关于具体控制域的细节，还是翻Intel手册吧。\n\n#### 3.VM-Entry/VM-Exit\n\nVM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。\n\nVM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，[发生中断](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")，模拟特权资源等。\n\n运行在非根模式下的敏感指令一般分为3个方面：\n\n1.行为没有变化的，也就是说该指令能够正确执行。\n\n2.行为有变化的，直接产生VM-Exit。\n\n3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。\n\n主要说一下\"受到VM-Execution控制域控制\"的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在[虚拟化](http://www.oenhan.com/kvm-src-1 \"KVM源代码分析1:基本工作原理\")场景下是不适用的，典型的就是TSC offset了。\n\nVM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。\n\n#### 4.KVM_CREATE_VM\n\n创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm {\n\tstruct mm_struct *mm; /* userspace tied to this vm */\n\tstruct kvm_memslots *memslots;  /*qemu模拟的内存条模型*/\n\tstruct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */\n\tatomic_t online_vcpus;\n\tint last_boosted_vcpu;\n\tstruct list_head vm_list;  //HOST上VM管理链表，\n\tstruct kvm_io_bus *buses[KVM_NR_BUSES];\n\tstruct kvm_vm_stat stat;\n\tstruct kvm_arch arch; //这个是host的arch的一些参数\n\tatomic_t users_count;\n\n\tlong tlbs_dirty;\n\tstruct list_head devices;\n};\n</pre>\n\nkvm_arch_init_vm基本没有特别动作，初始化了KVM->arch，以及更新了kvmclock函数，这个另外再说。  \n而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理[位图](http://www.oenhan.com/reiserfs_check_can_fit_pages_for_8tb \"reiserfs分区空闲8TB写文件提示磁盘空间不足\")，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。\n\n#### 5.KVM_CREATE_VCPU\n\nkvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu {\n\tstruct kvm *kvm;  //归属的KVM\\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier;\n\\#endif\n\tint cpu;\n\tint vcpu_id;\n\tint srcu_idx;\n\tint mode;\n\tunsigned long requests;\n\tunsigned long guest_debug;\n\n\tstruct mutex mutex;\n\tstruct kvm_run *run;  //运行时的状态\n\n\tint fpu_active;\n\tint guest_fpu_loaded, guest_xcr0_loaded;\n\twait_queue_head_t wq; //队列\n\tstruct pid *pid;\n\tint sigset_active;\n\tsigset_t sigset;\n\tstruct kvm_vcpu_stat stat; //一些数据\n\n\\#ifdef CONFIG_HAS_IOMEM\n\tint mmio_needed;\n\tint mmio_read_completed;\n\tint mmio_is_write;\n\tint mmio_cur_fragment;\n\tint mmio_nr_fragments;\n\tstruct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS];\n\\#endif\n\n\\#ifdef CONFIG_KVM_ASYNC_PF\n\tstruct {\n\t\tu32 queued;\n\t\tstruct list_head queue;\n\t\tstruct list_head done;\n\t\tspinlock_t lock;\n\t} async_pf;\n\\#endif\n\n\\#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n\t/*\n\t \\* Cpu relax intercept or pause loop exit optimization\n\t \\* in_spin_loop: set when a vcpu does a pause loop exit\n\t \\*  or cpu relax intercepted.\n\t \\* dy_eligible: indicates whether vcpu is eligible for directed yield.\n\t \\*/\n\tstruct {\n\t\tbool in_spin_loop;\n\t\tbool dy_eligible;\n\t} spin_loop;\n\\#endif\n\tbool preempted;\n\tstruct kvm_vcpu_arch arch;  //当前VCPU虚拟的架构，默认介绍X86\n};\n</pre>\n\n借着看kvm_arch_vcpu_create，它借助kvm_x86_ops->vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu->run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu_arch {\n\t/*\n\t \\* rip and regs accesses must go through\n\t \\* kvm_{register,rip}_{read,write} functions.\n\t \\*/unsignedlong regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n//类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0;\n\tunsignedlong cr0_guest_owned_bits;\n\tunsignedlong cr2;\n\tunsignedlong cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr8;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tbool tpr_access_reporting;\n\tu64 ia32_xss;\n\n\t/*\n\t \\* Paging state of the vcpu\n\t \\*\n\t \\* If the vcpu runs in guest mode with two level paging this still saves\n\t \\* the paging mode of the l1 guest. This context is always used to\n\t \\* handle faults.\n\t \\*/\n\tstruct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数\n\n\t/*\n\t \\* Paging state of an L2 guest (used for nested npt)\n\t \\*\n\t \\* This context will save all necessary information to walk page tables\n\t \\* of the an L2 guest. This context is only initialized for page table\n\t \\* walking and not for faulting since we never handle l2 page faults on\n\t \\* the host.\n\t \\*/\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t \\* Pointer to the mmu context currently used for\n\t \\* gva_to_gpa translations.\n\t \\*/\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\tstruct fpu guest_fpu;\n\tu64 xcr0;\n\tu64 guest_supported_xcr0;\n\tu32 guest_xstate_size;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool has_error_code;\n\t\tbool reinject;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool pending;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\n\tint maxphyaddr;\n\n\t/* emulate context */\n//下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套\n\tstruct x86_emulate_ctxt emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_hva_cache pv_time;\n\tbool pv_time_enabled;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tu64 accum_steal;\n\t\tstruct gfn_to_hva_cache stime;\n\t\tstruct kvm_steal_time steal;\n\t} st;\n\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\n\tstruct mtrr_state_type mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_vapic;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_val;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\t/*\n\t \\* Indicate whether the access faults on its page table in guest\n\t \\* which is set when fix page fault and used to detect unhandeable\n\t \\* instruction.\n\t \\*/\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n};\n</pre>\n\n整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。  \nkvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu->arch.emulate_ctxt.ops = &emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。\n\n<pre class=\"lang:c decode:1 hljs bash\">\nstatic struct x86_emulate_ops emulate_ops = {\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n</pre>\n\nx86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。  \n回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx->loaded_vmcs->vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从[伙伴系统](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf->order = get_order(vmcs_config.size)，而vmcs_conf->size = vmx_msr_high & 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。  \n下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。  \nvmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。  \nvmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops->vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。  \nkvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。  \n如此整个vcpu就创建完成了。\n\n6.KVM_RUN\n\nKVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。\n\n下一篇：\n\n[KVM源代码分析4:内存虚拟化](http://www.oenhan.com/kvm-src-4-mem)\n\n----------完----------\n\n--------------------下面未编辑的留存-------------------------------------  \n给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个[页大小内存](http://www.oenhan.com/linux-kernel-khugepaged \"hugepage内存管理机制\")，用来保存vm和vmm信息。\n\n<pre class=\"lang:c decode:1 hljs php\">\n\tvmx->vmcs = alloc_vmcs();\n\tif (!vmx->vmcs)\n\t\tgoto free_msrs;\n\n\tvmcs_init(vmx->vmcs);\n</pre>\n\n执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。\n\nvmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。\n\nvcpu的创建到此结束，下面说一下vcpu的运行。\n\nVCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。\n\nKVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu->requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops->prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。\n\n<pre class=\"lang:c decode:1 hljs php\">\nkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\t/* We should set ->mode before check ->requests,\n\t \\* see the comment in make_all_cpus_request.\n\t \\*/\n\tsmp_mb();\n\n\tlocal_irq_disable();\n</pre>\n\n然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu->mode和vcpu->requests等，如果有问题，则恢复host状态。\n\nkvm_guest_enter做了两件事：account_system_vtime计算虚拟机[系统时间](http://www.oenhan.com/glibc_pthread_cond_timedwait_disable \"Glibc更新导致pthread_cond_timedwait失效\")；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。\n\n准备工作搞定，kvm_x86_ops->run(vcpu)，开始运行guest，由vmx_vcpu_run实现。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (vmx->emulation_required && emulate_invalid_guest_state)\n\t\treturn;\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n</pre>\n\n判断模拟器，RSP，RIP寄存器值。\n\n主要功能在这段内联汇编上\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nasm(\n                /* Store host registers */\n\t\t\"push %%\"R\"dx; push %%\"R\"bp;\"\n\t\t\"push %%\"R\"cx nt\" /* placeholder for guest rcx */\n\t\t\"push %%\"R\"cx nt\"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上\n\t\t\"cmp %%\"R\"sp, %c[host_rsp](%0) nt\"\"je 1f nt\"\"mov %%\"R\"sp, %c[host_rsp](%0) nt\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"nt\"//__kvm_handle_fault_on_reboot write host rsp\"1: nt\"/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\"R\"ax nt\"\n\t\t\"mov %%cr2, %%\"R\"dx nt\"\n                //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上\n\t\t\"cmp %%\"R\"ax, %%\"R\"dx nt\"\n\t\t\"je 2f nt\"\n\t\t\"mov %%\"R\"ax, %%cr2 nt\"\n\t\t\"2: nt\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) nt\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\"R\"ax nt\"\n\t\t\"mov %c[rbx](%0), %%\"R\"bx nt\"\n\t\t\"mov %c[rdx](%0), %%\"R\"dx nt\"\n\t\t\"mov %c[rsi](%0), %%\"R\"si nt\"\n\t\t\"mov %c[rdi](%0), %%\"R\"di nt\"\n\t\t\"mov %c[rbp](%0), %%\"R\"bp nt\"\n\\#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  nt\"\n\t\t\"mov %c[r9](%0),  %%r9  nt\"\n\t\t\"mov %c[r10](%0), %%r10 nt\"\n\t\t\"mov %c[r11](%0), %%r11 nt\"\n\t\t\"mov %c[r12](%0), %%r12 nt\"\n\t\t\"mov %c[r13](%0), %%r13 nt\"\n\t\t\"mov %c[r14](%0), %%r14 nt\"\n\t\t\"mov %c[r15](%0), %%r15 nt\"\n\\#endif\n\t\t\"mov %c[rcx](%0), %%\"R\"cx nt\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n                //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式\n                //RESUME和LAUNCH，通过__ex  __kvm_handle_fault_on_reboot执行\n\t\t\"jne .Llaunched nt\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"nt\"\n\t\t\"jmp .Lkvm_vmx_return nt\"\n\t\t\".Llaunched: \" __ex(ASM_VMX_VMRESUME) \"nt\"\n                 //退出vmx，保存guest信息，加载host信息\n\t\t\".Lkvm_vmx_return: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\"R\"sp) nt\"\n\t\t\"pop %0 nt\"\n\t\t\"mov %%\"R\"ax, %c[rax](%0) nt\"\n\t\t\"mov %%\"R\"bx, %c[rbx](%0) nt\"\n\t\t\"pop\"Q\" %c[rcx](%0) nt\"\n\t\t\"mov %%\"R\"dx, %c[rdx](%0) nt\"\n\t\t\"mov %%\"R\"si, %c[rsi](%0) nt\"\n\t\t\"mov %%\"R\"di, %c[rdi](%0) nt\"\n\t\t\"mov %%\"R\"bp, %c[rbp](%0) nt\"\n\\#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) nt\"\n\t\t\"mov %%r9,  %c[r9](%0) nt\"\n\t\t\"mov %%r10, %c[r10](%0) nt\"\n\t\t\"mov %%r11, %c[r11](%0) nt\"\n\t\t\"mov %%r12, %c[r12](%0) nt\"\n\t\t\"mov %%r13, %c[r13](%0) nt\"\n\t\t\"mov %%r14, %c[r14](%0) nt\"\n\t\t\"mov %%r15, %c[r15](%0) nt\"\n\\#endif\n\t\t\"mov %%cr2, %%\"R\"ax   nt\"\n\t\t\"mov %%\"R\"ax, %c[cr2](%0) nt\"\n\n\t\t\"pop  %%\"R\"bp; pop  %%\"R\"dx nt\"\n\t\t\"setbe %c[fail](%0) nt\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\n//下面加了前面寄存器的指针值，对应具体结构的值\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n\\#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n\\#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n\t\t, R\"ax\", R\"bx\", R\"di\", R\"si\"\n\\#ifdef CONFIG_X86_64\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n\\#endif\n</pre>\n\n以上代码相对容易理解的，根据注释大致清楚了具体作用。\n\n然后就是恢复系统NMI等中断:\n\n<pre class=\"lang:c decode:1 hljs bash\">\nvmx_complete_atomic_exit(vmx);\nvmx_recover_nmi_blocking(vmx);\nvmx_complete_interrupts(vmx);\n</pre>\n\n回到vcpu_enter_guest，通过hw_breakpoint_restore恢复[硬件断点](http://www.oenhan.com/jprobe-hw-breakpoint \"内核调试方法:Jprobe与硬件断点\")。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tkvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc);\n\n//设置vcpu模式，恢复host相关内容\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\tlocal_irq_enable();\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t \\* We must have an instruction between local_irq_enable() and\n\t \\* kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t \\* the interrupt shadow.  The stat.exits increment will do nicely.\n\t \\* But we need to prevent reordering, hence this barrier():\n\t \\*/\n\tbarrier();\n//刷新系统时间\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t \\* Profile KVM exit RIPs:\n\t \\*/\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tkvm_lapic_sync_from_vapic(vcpu);\n//处理vmx退出\n\tr = kvm_x86_ops->handle_exit(vcpu);\n</pre>\n\nhandle_exit退出函数由vmx_handle_exit实现，主要设置vcpu->run->exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下：\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\nstaticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmx_insn,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmx_insn,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMREAD]                  = handle_vmx_insn,\n\t[EXIT_REASON_VMRESUME]                = handle_vmx_insn,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMOFF]                   = handle_vmx_insn,\n\t[EXIT_REASON_VMON]                    = handle_vmx_insn,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_invalid_op,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n};\n</pre>\n\n有handle_task_switch进行[任务切换](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。\n\n再次退回到__vcpu_run函数，在while (r > 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n</pre>\n\n再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。\n\nKVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。\n\nKVM源代码分析未完待续\n","source":"_posts/kvm-src-3-cpu.md","raw":"---\ntitle: KVM源代码分析3:CPU虚拟化\ndonate: true\ndate: 2014-12-11 10:34:48\ncategories: KVM\ntags: KVM\n---\n在[虚拟机的创建与运行](http://www.oenhan.com/kvm-src-2-vm-run \"KVM源代码分析2:虚拟机的创建与运行\")章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。\n\nQEMU：git://git.qemu.org/qemu.git v2.4.0\n\nKVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2\n\n#### 1.VT-x 技术\n\nIntel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。\n\n处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考[CPU的运行环、特权级与保护](http://blog.csdn.net/drshenlei/article/details/4265101)）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。\n\n为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问[中断寄存器](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。\n\n在[KVM源代码分析1:基本工作原理](http://www.oenhan.com/kvm-src-1)章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。\n\n如下图  \n![](kvm_vmx_intel-1.jpg)\n\n在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。\n\n#### 2.VMCS寄存器\n\nVMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的[寄存器](http://www.oenhan.com/gdb-principle \"gdb工作原理和内核实现\")（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。\n\nVMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域：\n\n<colgroup>\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\">\n<col width=\"51*\"> </colgroup>\ncol 1                  | col 2                                                    | col 3                                                            \n---------------------- | -------------------------------------------------------- | -----------------------------------------------------------------\n VM-execution controls |  Determines what operations cause VM exits               |  CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etc\nGuest-state area       |  Saved on VM exits，Reloaded on VM entry                  |  EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc            \n Host-state area       |  Loaded on VM exits                                      |  CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc      \n VM-exit controls      |  Determines which state to save, load, how to transition |  Example: MSR save-load list                                     \n VM-entry controls     |  Determines which state to load, how to transition       |  Including injecting events (interrupts, exceptions) on entry    \n\n关于具体控制域的细节，还是翻Intel手册吧。\n\n#### 3.VM-Entry/VM-Exit\n\nVM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。\n\nVM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，[发生中断](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")，模拟特权资源等。\n\n运行在非根模式下的敏感指令一般分为3个方面：\n\n1.行为没有变化的，也就是说该指令能够正确执行。\n\n2.行为有变化的，直接产生VM-Exit。\n\n3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。\n\n主要说一下\"受到VM-Execution控制域控制\"的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在[虚拟化](http://www.oenhan.com/kvm-src-1 \"KVM源代码分析1:基本工作原理\")场景下是不适用的，典型的就是TSC offset了。\n\nVM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。\n\n#### 4.KVM_CREATE_VM\n\n创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm {\n\tstruct mm_struct *mm; /* userspace tied to this vm */\n\tstruct kvm_memslots *memslots;  /*qemu模拟的内存条模型*/\n\tstruct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */\n\tatomic_t online_vcpus;\n\tint last_boosted_vcpu;\n\tstruct list_head vm_list;  //HOST上VM管理链表，\n\tstruct kvm_io_bus *buses[KVM_NR_BUSES];\n\tstruct kvm_vm_stat stat;\n\tstruct kvm_arch arch; //这个是host的arch的一些参数\n\tatomic_t users_count;\n\n\tlong tlbs_dirty;\n\tstruct list_head devices;\n};\n</pre>\n\nkvm_arch_init_vm基本没有特别动作，初始化了KVM->arch，以及更新了kvmclock函数，这个另外再说。  \n而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理[位图](http://www.oenhan.com/reiserfs_check_can_fit_pages_for_8tb \"reiserfs分区空闲8TB写文件提示磁盘空间不足\")，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。\n\n#### 5.KVM_CREATE_VCPU\n\nkvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu {\n\tstruct kvm *kvm;  //归属的KVM\\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier;\n\\#endif\n\tint cpu;\n\tint vcpu_id;\n\tint srcu_idx;\n\tint mode;\n\tunsigned long requests;\n\tunsigned long guest_debug;\n\n\tstruct mutex mutex;\n\tstruct kvm_run *run;  //运行时的状态\n\n\tint fpu_active;\n\tint guest_fpu_loaded, guest_xcr0_loaded;\n\twait_queue_head_t wq; //队列\n\tstruct pid *pid;\n\tint sigset_active;\n\tsigset_t sigset;\n\tstruct kvm_vcpu_stat stat; //一些数据\n\n\\#ifdef CONFIG_HAS_IOMEM\n\tint mmio_needed;\n\tint mmio_read_completed;\n\tint mmio_is_write;\n\tint mmio_cur_fragment;\n\tint mmio_nr_fragments;\n\tstruct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS];\n\\#endif\n\n\\#ifdef CONFIG_KVM_ASYNC_PF\n\tstruct {\n\t\tu32 queued;\n\t\tstruct list_head queue;\n\t\tstruct list_head done;\n\t\tspinlock_t lock;\n\t} async_pf;\n\\#endif\n\n\\#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n\t/*\n\t \\* Cpu relax intercept or pause loop exit optimization\n\t \\* in_spin_loop: set when a vcpu does a pause loop exit\n\t \\*  or cpu relax intercepted.\n\t \\* dy_eligible: indicates whether vcpu is eligible for directed yield.\n\t \\*/\n\tstruct {\n\t\tbool in_spin_loop;\n\t\tbool dy_eligible;\n\t} spin_loop;\n\\#endif\n\tbool preempted;\n\tstruct kvm_vcpu_arch arch;  //当前VCPU虚拟的架构，默认介绍X86\n};\n</pre>\n\n借着看kvm_arch_vcpu_create，它借助kvm_x86_ops->vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu->run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu_arch {\n\t/*\n\t \\* rip and regs accesses must go through\n\t \\* kvm_{register,rip}_{read,write} functions.\n\t \\*/unsignedlong regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n//类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0;\n\tunsignedlong cr0_guest_owned_bits;\n\tunsignedlong cr2;\n\tunsignedlong cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr8;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tbool tpr_access_reporting;\n\tu64 ia32_xss;\n\n\t/*\n\t \\* Paging state of the vcpu\n\t \\*\n\t \\* If the vcpu runs in guest mode with two level paging this still saves\n\t \\* the paging mode of the l1 guest. This context is always used to\n\t \\* handle faults.\n\t \\*/\n\tstruct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数\n\n\t/*\n\t \\* Paging state of an L2 guest (used for nested npt)\n\t \\*\n\t \\* This context will save all necessary information to walk page tables\n\t \\* of the an L2 guest. This context is only initialized for page table\n\t \\* walking and not for faulting since we never handle l2 page faults on\n\t \\* the host.\n\t \\*/\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t \\* Pointer to the mmu context currently used for\n\t \\* gva_to_gpa translations.\n\t \\*/\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\tstruct fpu guest_fpu;\n\tu64 xcr0;\n\tu64 guest_supported_xcr0;\n\tu32 guest_xstate_size;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool has_error_code;\n\t\tbool reinject;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool pending;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\n\tint maxphyaddr;\n\n\t/* emulate context */\n//下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套\n\tstruct x86_emulate_ctxt emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_hva_cache pv_time;\n\tbool pv_time_enabled;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tu64 accum_steal;\n\t\tstruct gfn_to_hva_cache stime;\n\t\tstruct kvm_steal_time steal;\n\t} st;\n\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\n\tstruct mtrr_state_type mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\t/* fields used by HYPER-V emulation */\n\tu64 hv_vapic;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_val;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\t/*\n\t \\* Indicate whether the access faults on its page table in guest\n\t \\* which is set when fix page fault and used to detect unhandeable\n\t \\* instruction.\n\t \\*/\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n};\n</pre>\n\n整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。  \nkvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu->arch.emulate_ctxt.ops = &emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。\n\n<pre class=\"lang:c decode:1 hljs bash\">\nstatic struct x86_emulate_ops emulate_ops = {\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n</pre>\n\nx86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。  \n回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx->loaded_vmcs->vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从[伙伴系统](http://www.oenhan.com/size-512-slab-kmalloc \"从size-512内存泄露看slab分配\")申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf->order = get_order(vmcs_config.size)，而vmcs_conf->size = vmx_msr_high & 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。  \n下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。  \nvmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。  \nvmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops->vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。  \nkvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。  \n如此整个vcpu就创建完成了。\n\n6.KVM_RUN\n\nKVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。\n\n下一篇：\n\n[KVM源代码分析4:内存虚拟化](http://www.oenhan.com/kvm-src-4-mem)\n\n----------完----------\n\n--------------------下面未编辑的留存-------------------------------------  \n给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个[页大小内存](http://www.oenhan.com/linux-kernel-khugepaged \"hugepage内存管理机制\")，用来保存vm和vmm信息。\n\n<pre class=\"lang:c decode:1 hljs php\">\n\tvmx->vmcs = alloc_vmcs();\n\tif (!vmx->vmcs)\n\t\tgoto free_msrs;\n\n\tvmcs_init(vmx->vmcs);\n</pre>\n\n执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。\n\nvmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。\n\nvcpu的创建到此结束，下面说一下vcpu的运行。\n\nVCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。\n\nKVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu->requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops->prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。\n\n<pre class=\"lang:c decode:1 hljs php\">\nkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\t/* We should set ->mode before check ->requests,\n\t \\* see the comment in make_all_cpus_request.\n\t \\*/\n\tsmp_mb();\n\n\tlocal_irq_disable();\n</pre>\n\n然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu->mode和vcpu->requests等，如果有问题，则恢复host状态。\n\nkvm_guest_enter做了两件事：account_system_vtime计算虚拟机[系统时间](http://www.oenhan.com/glibc_pthread_cond_timedwait_disable \"Glibc更新导致pthread_cond_timedwait失效\")；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。\n\n准备工作搞定，kvm_x86_ops->run(vcpu)，开始运行guest，由vmx_vcpu_run实现。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (vmx->emulation_required && emulate_invalid_guest_state)\n\t\treturn;\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n</pre>\n\n判断模拟器，RSP，RIP寄存器值。\n\n主要功能在这段内联汇编上\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nasm(\n                /* Store host registers */\n\t\t\"push %%\"R\"dx; push %%\"R\"bp;\"\n\t\t\"push %%\"R\"cx nt\" /* placeholder for guest rcx */\n\t\t\"push %%\"R\"cx nt\"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上\n\t\t\"cmp %%\"R\"sp, %c[host_rsp](%0) nt\"\"je 1f nt\"\"mov %%\"R\"sp, %c[host_rsp](%0) nt\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"nt\"//__kvm_handle_fault_on_reboot write host rsp\"1: nt\"/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\"R\"ax nt\"\n\t\t\"mov %%cr2, %%\"R\"dx nt\"\n                //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上\n\t\t\"cmp %%\"R\"ax, %%\"R\"dx nt\"\n\t\t\"je 2f nt\"\n\t\t\"mov %%\"R\"ax, %%cr2 nt\"\n\t\t\"2: nt\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) nt\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\"R\"ax nt\"\n\t\t\"mov %c[rbx](%0), %%\"R\"bx nt\"\n\t\t\"mov %c[rdx](%0), %%\"R\"dx nt\"\n\t\t\"mov %c[rsi](%0), %%\"R\"si nt\"\n\t\t\"mov %c[rdi](%0), %%\"R\"di nt\"\n\t\t\"mov %c[rbp](%0), %%\"R\"bp nt\"\n\\#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  nt\"\n\t\t\"mov %c[r9](%0),  %%r9  nt\"\n\t\t\"mov %c[r10](%0), %%r10 nt\"\n\t\t\"mov %c[r11](%0), %%r11 nt\"\n\t\t\"mov %c[r12](%0), %%r12 nt\"\n\t\t\"mov %c[r13](%0), %%r13 nt\"\n\t\t\"mov %c[r14](%0), %%r14 nt\"\n\t\t\"mov %c[r15](%0), %%r15 nt\"\n\\#endif\n\t\t\"mov %c[rcx](%0), %%\"R\"cx nt\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n                //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式\n                //RESUME和LAUNCH，通过__ex  __kvm_handle_fault_on_reboot执行\n\t\t\"jne .Llaunched nt\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"nt\"\n\t\t\"jmp .Lkvm_vmx_return nt\"\n\t\t\".Llaunched: \" __ex(ASM_VMX_VMRESUME) \"nt\"\n                 //退出vmx，保存guest信息，加载host信息\n\t\t\".Lkvm_vmx_return: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\"R\"sp) nt\"\n\t\t\"pop %0 nt\"\n\t\t\"mov %%\"R\"ax, %c[rax](%0) nt\"\n\t\t\"mov %%\"R\"bx, %c[rbx](%0) nt\"\n\t\t\"pop\"Q\" %c[rcx](%0) nt\"\n\t\t\"mov %%\"R\"dx, %c[rdx](%0) nt\"\n\t\t\"mov %%\"R\"si, %c[rsi](%0) nt\"\n\t\t\"mov %%\"R\"di, %c[rdi](%0) nt\"\n\t\t\"mov %%\"R\"bp, %c[rbp](%0) nt\"\n\\#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) nt\"\n\t\t\"mov %%r9,  %c[r9](%0) nt\"\n\t\t\"mov %%r10, %c[r10](%0) nt\"\n\t\t\"mov %%r11, %c[r11](%0) nt\"\n\t\t\"mov %%r12, %c[r12](%0) nt\"\n\t\t\"mov %%r13, %c[r13](%0) nt\"\n\t\t\"mov %%r14, %c[r14](%0) nt\"\n\t\t\"mov %%r15, %c[r15](%0) nt\"\n\\#endif\n\t\t\"mov %%cr2, %%\"R\"ax   nt\"\n\t\t\"mov %%\"R\"ax, %c[cr2](%0) nt\"\n\n\t\t\"pop  %%\"R\"bp; pop  %%\"R\"dx nt\"\n\t\t\"setbe %c[fail](%0) nt\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\n//下面加了前面寄存器的指针值，对应具体结构的值\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n\\#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n\\#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n\t\t, R\"ax\", R\"bx\", R\"di\", R\"si\"\n\\#ifdef CONFIG_X86_64\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n\\#endif\n</pre>\n\n以上代码相对容易理解的，根据注释大致清楚了具体作用。\n\n然后就是恢复系统NMI等中断:\n\n<pre class=\"lang:c decode:1 hljs bash\">\nvmx_complete_atomic_exit(vmx);\nvmx_recover_nmi_blocking(vmx);\nvmx_complete_interrupts(vmx);\n</pre>\n\n回到vcpu_enter_guest，通过hw_breakpoint_restore恢复[硬件断点](http://www.oenhan.com/jprobe-hw-breakpoint \"内核调试方法:Jprobe与硬件断点\")。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tkvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc);\n\n//设置vcpu模式，恢复host相关内容\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\tlocal_irq_enable();\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t \\* We must have an instruction between local_irq_enable() and\n\t \\* kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t \\* the interrupt shadow.  The stat.exits increment will do nicely.\n\t \\* But we need to prevent reordering, hence this barrier():\n\t \\*/\n\tbarrier();\n//刷新系统时间\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t \\* Profile KVM exit RIPs:\n\t \\*/\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tkvm_lapic_sync_from_vapic(vcpu);\n//处理vmx退出\n\tr = kvm_x86_ops->handle_exit(vcpu);\n</pre>\n\nhandle_exit退出函数由vmx_handle_exit实现，主要设置vcpu->run->exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下：\n\n<pre class=\"lang:c decode:1 hljs objectivec\">\nstaticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = handle_cpuid,\n\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = handle_halt,\n\t[EXIT_REASON_INVD]\t\t      = handle_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_VMCALL]                  = handle_vmcall,\n\t[EXIT_REASON_VMCLEAR]\t              = handle_vmx_insn,\n\t[EXIT_REASON_VMLAUNCH]                = handle_vmx_insn,\n\t[EXIT_REASON_VMPTRLD]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMPTRST]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMREAD]                  = handle_vmx_insn,\n\t[EXIT_REASON_VMRESUME]                = handle_vmx_insn,\n\t[EXIT_REASON_VMWRITE]                 = handle_vmx_insn,\n\t[EXIT_REASON_VMOFF]                   = handle_vmx_insn,\n\t[EXIT_REASON_VMON]                    = handle_vmx_insn,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_invalid_op,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n};\n</pre>\n\n有handle_task_switch进行[任务切换](http://www.oenhan.com/rwsem-realtime-task-hung \"读写信号量与实时进程阻塞挂死问题\")，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。\n\n再次退回到__vcpu_run函数，在while (r > 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。\n\n<pre class=\"lang:c decode:1 hljs php\">\nif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n</pre>\n\n再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。\n\nKVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。\n\nKVM源代码分析未完待续\n","slug":"kvm-src-3-cpu","published":1,"updated":"2018-12-11T03:02:52.188Z","_id":"cjpj4usjw000979o4vikassxr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在<a href=\"http://www.oenhan.com/kvm-src-2-vm-run\" title=\"KVM源代码分析2:虚拟机的创建与运行\" target=\"_blank\" rel=\"noopener\">虚拟机的创建与运行</a>章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。</p>\n<p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p>\n<p>KVM：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p>\n<h4 id=\"1-VT-x-技术\"><a href=\"#1-VT-x-技术\" class=\"headerlink\" title=\"1.VT-x 技术\"></a>1.VT-x 技术</h4><p>Intel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。</p>\n<p>处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考<a href=\"http://blog.csdn.net/drshenlei/article/details/4265101\" target=\"_blank\" rel=\"noopener\">CPU的运行环、特权级与保护</a>）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。</p>\n<p>为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">中断寄存器</a>）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。</p>\n<p>在<a href=\"http://www.oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">KVM源代码分析1:基本工作原理</a>章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。</p>\n<p>如下图<br><img src=\"/2014/12/11/kvm-src-3-cpu/kvm_vmx_intel-1.jpg\" alt=\"\"></p>\n<p>在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。</p>\n<h4 id=\"2-VMCS寄存器\"><a href=\"#2-VMCS寄存器\" class=\"headerlink\" title=\"2.VMCS寄存器\"></a>2.VMCS寄存器</h4><p>VMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的<a href=\"http://www.oenhan.com/gdb-principle\" title=\"gdb工作原理和内核实现\" target=\"_blank\" rel=\"noopener\">寄存器</a>（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。</p>\n<p>VMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域：</p>\n<p><colgroup></colgroup></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"> <br>col 1                  | col 2                                                    | col 3<br>———————- | ——————————————————– | —————————————————————–<br> VM-execution controls |  Determines what operations cause VM exits               |  CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etc<br>Guest-state area       |  Saved on VM exits，Reloaded on VM entry                  |  EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc<br> Host-state area       |  Loaded on VM exits                                      |  CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc<br> VM-exit controls      |  Determines which state to save, load, how to transition |  Example: MSR save-load list<br> VM-entry controls     |  Determines which state to load, how to transition       |  Including injecting events (interrupts, exceptions) on entry    </p>\n<p>关于具体控制域的细节，还是翻Intel手册吧。</p>\n<h4 id=\"3-VM-Entry-VM-Exit\"><a href=\"#3-VM-Entry-VM-Exit\" class=\"headerlink\" title=\"3.VM-Entry/VM-Exit\"></a>3.VM-Entry/VM-Exit</h4><p>VM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。</p>\n<p>VM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">发生中断</a>，模拟特权资源等。</p>\n<p>运行在非根模式下的敏感指令一般分为3个方面：</p>\n<p>1.行为没有变化的，也就是说该指令能够正确执行。</p>\n<p>2.行为有变化的，直接产生VM-Exit。</p>\n<p>3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。</p>\n<p>主要说一下”受到VM-Execution控制域控制”的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在<a href=\"http://www.oenhan.com/kvm-src-1\" title=\"KVM源代码分析1:基本工作原理\" target=\"_blank\" rel=\"noopener\">虚拟化</a>场景下是不适用的，典型的就是TSC offset了。</p>\n<p>VM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。</p>\n<h4 id=\"4-KVM-CREATE-VM\"><a href=\"#4-KVM-CREATE-VM\" class=\"headerlink\" title=\"4.KVM_CREATE_VM\"></a>4.KVM_CREATE_VM</h4><p>创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm {\n    struct mm_struct *mm; /* userspace tied to this vm */\n    struct kvm_memslots *memslots;  /*qemu模拟的内存条模型*/\n    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */\n    atomic_t online_vcpus;\n    int last_boosted_vcpu;\n    struct list_head vm_list;  //HOST上VM管理链表，\n    struct kvm_io_bus *buses[KVM_NR_BUSES];\n    struct kvm_vm_stat stat;\n    struct kvm_arch arch; //这个是host的arch的一些参数\n    atomic_t users_count;\n\n    long tlbs_dirty;\n    struct list_head devices;\n};\n</pre>\n\n<p>kvm_arch_init_vm基本没有特别动作，初始化了KVM-&gt;arch，以及更新了kvmclock函数，这个另外再说。<br>而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理<a href=\"http://www.oenhan.com/reiserfs_check_can_fit_pages_for_8tb\" title=\"reiserfs分区空闲8TB写文件提示磁盘空间不足\" target=\"_blank\" rel=\"noopener\">位图</a>，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。</p>\n<h4 id=\"5-KVM-CREATE-VCPU\"><a href=\"#5-KVM-CREATE-VCPU\" class=\"headerlink\" title=\"5.KVM_CREATE_VCPU\"></a>5.KVM_CREATE_VCPU</h4><p>kvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu {\n    struct kvm *kvm;  //归属的KVM\\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier;\n\\#endif\n    int cpu;\n    int vcpu_id;\n    int srcu_idx;\n    int mode;\n    unsigned long requests;\n    unsigned long guest_debug;\n\n    struct mutex mutex;\n    struct kvm_run *run;  //运行时的状态\n\n    int fpu_active;\n    int guest_fpu_loaded, guest_xcr0_loaded;\n    wait_queue_head_t wq; //队列\n    struct pid *pid;\n    int sigset_active;\n    sigset_t sigset;\n    struct kvm_vcpu_stat stat; //一些数据\n\n\\#ifdef CONFIG_HAS_IOMEM\n    int mmio_needed;\n    int mmio_read_completed;\n    int mmio_is_write;\n    int mmio_cur_fragment;\n    int mmio_nr_fragments;\n    struct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS];\n\\#endif\n\n\\#ifdef CONFIG_KVM_ASYNC_PF\n    struct {\n        u32 queued;\n        struct list_head queue;\n        struct list_head done;\n        spinlock_t lock;\n    } async_pf;\n\\#endif\n\n\\#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n    /*\n     \\* Cpu relax intercept or pause loop exit optimization\n     \\* in_spin_loop: set when a vcpu does a pause loop exit\n     \\*  or cpu relax intercepted.\n     \\* dy_eligible: indicates whether vcpu is eligible for directed yield.\n     \\*/\n    struct {\n        bool in_spin_loop;\n        bool dy_eligible;\n    } spin_loop;\n\\#endif\n    bool preempted;\n    struct kvm_vcpu_arch arch;  //当前VCPU虚拟的架构，默认介绍X86\n};\n</pre>\n\n<p>借着看kvm_arch_vcpu_create，它借助kvm_x86_ops-&gt;vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu-&gt;run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu_arch {\n    /*\n     \\* rip and regs accesses must go through\n     \\* kvm_{register,rip}_{read,write} functions.\n     \\*/unsignedlong regs[NR_VCPU_REGS];\n    u32 regs_avail;\n    u32 regs_dirty;\n//类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0;\n    unsignedlong cr0_guest_owned_bits;\n    unsignedlong cr2;\n    unsignedlong cr3;\n    unsigned long cr4;\n    unsigned long cr4_guest_owned_bits;\n    unsigned long cr8;\n    u32 hflags;\n    u64 efer;\n    u64 apic_base;\n    struct kvm_lapic *apic;    /* kernel irqchip context */\n    unsigned long apic_attention;\n    int32_t apic_arb_prio;\n    int mp_state;\n    u64 ia32_misc_enable_msr;\n    bool tpr_access_reporting;\n    u64 ia32_xss;\n\n    /*\n     \\* Paging state of the vcpu\n     \\*\n     \\* If the vcpu runs in guest mode with two level paging this still saves\n     \\* the paging mode of the l1 guest. This context is always used to\n     \\* handle faults.\n     \\*/\n    struct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数\n\n    /*\n     \\* Paging state of an L2 guest (used for nested npt)\n     \\*\n     \\* This context will save all necessary information to walk page tables\n     \\* of the an L2 guest. This context is only initialized for page table\n     \\* walking and not for faulting since we never handle l2 page faults on\n     \\* the host.\n     \\*/\n    struct kvm_mmu nested_mmu;\n\n    /*\n     \\* Pointer to the mmu context currently used for\n     \\* gva_to_gpa translations.\n     \\*/\n    struct kvm_mmu *walk_mmu;\n\n    struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n    struct kvm_mmu_memory_cache mmu_page_cache;\n    struct kvm_mmu_memory_cache mmu_page_header_cache;\n\n    struct fpu guest_fpu;\n    u64 xcr0;\n    u64 guest_supported_xcr0;\n    u32 guest_xstate_size;\n\n    struct kvm_pio_request pio;\n    void *pio_data;\n\n    u8 event_exit_inst_len;\n\n    struct kvm_queued_exception {\n        bool pending;\n        bool has_error_code;\n        bool reinject;\n        u8 nr;\n        u32 error_code;\n    } exception;\n\n    struct kvm_queued_interrupt {\n        bool pending;\n        bool soft;\n        u8 nr;\n    } interrupt;\n\n    int halt_request; /* real mode on Intel only */\n\n    int cpuid_nent;\n    struct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\n    int maxphyaddr;\n\n    /* emulate context */\n//下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套\n    struct x86_emulate_ctxt emulate_ctxt;\n    bool emulate_regs_need_sync_to_vcpu;\n    bool emulate_regs_need_sync_from_vcpu;\n    int (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n    gpa_t time;\n    struct pvclock_vcpu_time_info hv_clock;\n    unsigned int hw_tsc_khz;\n    struct gfn_to_hva_cache pv_time;\n    bool pv_time_enabled;\n    /* set guest stopped flag in pvclock flags field */\n    bool pvclock_set_guest_stopped_request;\n\n    struct {\n        u64 msr_val;\n        u64 last_steal;\n        u64 accum_steal;\n        struct gfn_to_hva_cache stime;\n        struct kvm_steal_time steal;\n    } st;\n\n    u64 last_guest_tsc;\n    u64 last_host_tsc;\n    u64 tsc_offset_adjustment;\n    u64 this_tsc_nsec;\n    u64 this_tsc_write;\n    u64 this_tsc_generation;\n    bool tsc_catchup;\n    bool tsc_always_catchup;\n    s8 virtual_tsc_shift;\n    u32 virtual_tsc_mult;\n    u32 virtual_tsc_khz;\n    s64 ia32_tsc_adjust_msr;\n\n    atomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n    unsigned nmi_pending; /* NMI queued after currently running handler */\n    bool nmi_injected;    /* Trying to inject an NMI this entry */\n\n    struct mtrr_state_type mtrr_state;\n    u64 pat;\n\n    unsigned switch_db_regs;\n    unsigned long db[KVM_NR_DB_REGS];\n    unsigned long dr6;\n    unsigned long dr7;\n    unsigned long eff_db[KVM_NR_DB_REGS];\n    unsigned long guest_debug_dr7;\n\n    u64 mcg_cap;\n    u64 mcg_status;\n    u64 mcg_ctl;\n    u64 *mce_banks;\n\n    /* Cache MMIO info */\n    u64 mmio_gva;\n    unsigned access;\n    gfn_t mmio_gfn;\n    u64 mmio_gen;\n\n    struct kvm_pmu pmu;\n\n    /* used for guest single stepping over the given code position */\n    unsigned long singlestep_rip;\n\n    /* fields used by HYPER-V emulation */\n    u64 hv_vapic;\n\n    cpumask_var_t wbinvd_dirty_mask;\n\n    unsigned long last_retry_eip;\n    unsigned long last_retry_addr;\n\n    struct {\n        bool halted;\n        gfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n        struct gfn_to_hva_cache data;\n        u64 msr_val;\n        u32 id;\n        bool send_user_only;\n    } apf;\n\n    /* OSVW MSRs (AMD only) */\n    struct {\n        u64 length;\n        u64 status;\n    } osvw;\n\n    struct {\n        u64 msr_val;\n        struct gfn_to_hva_cache data;\n    } pv_eoi;\n\n    /*\n     \\* Indicate whether the access faults on its page table in guest\n     \\* which is set when fix page fault and used to detect unhandeable\n     \\* instruction.\n     \\*/\n    bool write_fault_to_shadow_pgtable;\n\n    /* set at EPT violation at this point */\n    unsigned long exit_qualification;\n\n    /* pv related host specific info */\n    struct {\n        bool pv_unhalted;\n    } pv;\n};\n</pre>\n\n<p>整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。<br>kvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu-&gt;arch.emulate_ctxt.ops = &amp;emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nstatic struct x86_emulate_ops emulate_ops = {\n    .read_std            = kvm_read_guest_virt_system,\n    .write_std           = kvm_write_guest_virt_system,\n    .fetch               = kvm_fetch_guest_virt,\n    .read_emulated       = emulator_read_emulated,\n    .write_emulated      = emulator_write_emulated,\n    .cmpxchg_emulated    = emulator_cmpxchg_emulated,\n    .invlpg              = emulator_invlpg,\n    .pio_in_emulated     = emulator_pio_in_emulated,\n    .pio_out_emulated    = emulator_pio_out_emulated,\n    .get_segment         = emulator_get_segment,\n    .set_segment         = emulator_set_segment,\n    .get_cached_segment_base = emulator_get_cached_segment_base,\n    .get_gdt             = emulator_get_gdt,\n    .get_idt         = emulator_get_idt,\n    .set_gdt             = emulator_set_gdt,\n    .set_idt         = emulator_set_idt,\n    .get_cr              = emulator_get_cr,\n    .set_cr              = emulator_set_cr,\n    .cpl                 = emulator_get_cpl,\n    .get_dr              = emulator_get_dr,\n    .set_dr              = emulator_set_dr,\n    .set_msr             = emulator_set_msr,\n    .get_msr             = emulator_get_msr,\n    .halt                = emulator_halt,\n    .wbinvd              = emulator_wbinvd,\n    .fix_hypercall       = emulator_fix_hypercall,\n    .get_fpu             = emulator_get_fpu,\n    .put_fpu             = emulator_put_fpu,\n    .intercept           = emulator_intercept,\n    .get_cpuid           = emulator_get_cpuid,\n};\n</pre>\n\n<p>x86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。<br>回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx-&gt;loaded_vmcs-&gt;vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">伙伴系统</a>申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf-&gt;order = get_order(vmcs_config.size)，而vmcs_conf-&gt;size = vmx_msr_high &amp; 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。<br>下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。<br>vmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。<br>vmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops-&gt;vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。<br>kvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。<br>如此整个vcpu就创建完成了。</p>\n<p>6.KVM_RUN</p>\n<p>KVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。</p>\n<p>下一篇：</p>\n<p><a href=\"http://www.oenhan.com/kvm-src-4-mem\" target=\"_blank\" rel=\"noopener\">KVM源代码分析4:内存虚拟化</a></p>\n<p>———-完———-</p>\n<p>——————–下面未编辑的留存————————————-<br>给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个<a href=\"http://www.oenhan.com/linux-kernel-khugepaged\" title=\"hugepage内存管理机制\" target=\"_blank\" rel=\"noopener\">页大小内存</a>，用来保存vm和vmm信息。</p>\n<pre class=\"lang:c decode:1 hljs php\">\n    vmx->vmcs = alloc_vmcs();\n    if (!vmx->vmcs)\n        goto free_msrs;\n\n    vmcs_init(vmx->vmcs);\n</pre>\n\n<p>执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。</p>\n<p>vmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。</p>\n<p>vcpu的创建到此结束，下面说一下vcpu的运行。</p>\n<p>VCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。</p>\n<p>KVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu-&gt;requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops-&gt;prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nkvm_x86_ops->prepare_guest_switch(vcpu);\n    if (vcpu->fpu_active)\n        kvm_load_guest_fpu(vcpu);\n    kvm_load_guest_xcr0(vcpu);\n\n    vcpu->mode = IN_GUEST_MODE;\n\n    /* We should set ->mode before check ->requests,\n     \\* see the comment in make_all_cpus_request.\n     \\*/\n    smp_mb();\n\n    local_irq_disable();\n</pre>\n\n<p>然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu-&gt;mode和vcpu-&gt;requests等，如果有问题，则恢复host状态。</p>\n<p>kvm_guest_enter做了两件事：account_system_vtime计算虚拟机<a href=\"http://www.oenhan.com/glibc_pthread_cond_timedwait_disable\" title=\"Glibc更新导致pthread_cond_timedwait失效\" target=\"_blank\" rel=\"noopener\">系统时间</a>；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。</p>\n<p>准备工作搞定，kvm_x86_ops-&gt;run(vcpu)，开始运行guest，由vmx_vcpu_run实现。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (vmx->emulation_required && emulate_invalid_guest_state)\n        return;\n\n    if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n        vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n    if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n        vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n</pre>\n\n<p>判断模拟器，RSP，RIP寄存器值。</p>\n<p>主要功能在这段内联汇编上</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nasm(\n                /* Store host registers */\n        \"push %%\"R\"dx; push %%\"R\"bp;\"\n        \"push %%\"R\"cx nt\" /* placeholder for guest rcx */\n        \"push %%\"R\"cx nt\"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上\n        \"cmp %%\"R\"sp, %c[host_rsp](%0) nt\"\"je 1f nt\"\"mov %%\"R\"sp, %c[host_rsp](%0) nt\"\n        __ex(ASM_VMX_VMWRITE_RSP_RDX) \"nt\"//__kvm_handle_fault_on_reboot write host rsp\"1: nt\"/* Reload cr2 if changed */\n        \"mov %c[cr2](%0), %%\"R\"ax nt\"\n        \"mov %%cr2, %%\"R\"dx nt\"\n                //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上\n        \"cmp %%\"R\"ax, %%\"R\"dx nt\"\n        \"je 2f nt\"\n        \"mov %%\"R\"ax, %%cr2 nt\"\n        \"2: nt\"\n        /* Check if vmlaunch of vmresume is needed */\n        \"cmpl $0, %c[launched](%0) nt\"\n        /* Load guest registers.  Don't clobber flags. */\n        \"mov %c[rax](%0), %%\"R\"ax nt\"\n        \"mov %c[rbx](%0), %%\"R\"bx nt\"\n        \"mov %c[rdx](%0), %%\"R\"dx nt\"\n        \"mov %c[rsi](%0), %%\"R\"si nt\"\n        \"mov %c[rdi](%0), %%\"R\"di nt\"\n        \"mov %c[rbp](%0), %%\"R\"bp nt\"\n\\#ifdef CONFIG_X86_64\n        \"mov %c[r8](%0),  %%r8  nt\"\n        \"mov %c[r9](%0),  %%r9  nt\"\n        \"mov %c[r10](%0), %%r10 nt\"\n        \"mov %c[r11](%0), %%r11 nt\"\n        \"mov %c[r12](%0), %%r12 nt\"\n        \"mov %c[r13](%0), %%r13 nt\"\n        \"mov %c[r14](%0), %%r14 nt\"\n        \"mov %c[r15](%0), %%r15 nt\"\n\\#endif\n        \"mov %c[rcx](%0), %%\"R\"cx nt\" /* kills %0 (ecx) */\n\n        /* Enter guest mode */\n                //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式\n                //RESUME和LAUNCH，通过__ex  __kvm_handle_fault_on_reboot执行\n        \"jne .Llaunched nt\"\n        __ex(ASM_VMX_VMLAUNCH) \"nt\"\n        \"jmp .Lkvm_vmx_return nt\"\n        \".Llaunched: \" __ex(ASM_VMX_VMRESUME) \"nt\"\n                 //退出vmx，保存guest信息，加载host信息\n        \".Lkvm_vmx_return: \"\n        /* Save guest registers, load host registers, keep flags */\n        \"mov %0, %c[wordsize](%%\"R\"sp) nt\"\n        \"pop %0 nt\"\n        \"mov %%\"R\"ax, %c[rax](%0) nt\"\n        \"mov %%\"R\"bx, %c[rbx](%0) nt\"\n        \"pop\"Q\" %c[rcx](%0) nt\"\n        \"mov %%\"R\"dx, %c[rdx](%0) nt\"\n        \"mov %%\"R\"si, %c[rsi](%0) nt\"\n        \"mov %%\"R\"di, %c[rdi](%0) nt\"\n        \"mov %%\"R\"bp, %c[rbp](%0) nt\"\n\\#ifdef CONFIG_X86_64\n        \"mov %%r8,  %c[r8](%0) nt\"\n        \"mov %%r9,  %c[r9](%0) nt\"\n        \"mov %%r10, %c[r10](%0) nt\"\n        \"mov %%r11, %c[r11](%0) nt\"\n        \"mov %%r12, %c[r12](%0) nt\"\n        \"mov %%r13, %c[r13](%0) nt\"\n        \"mov %%r14, %c[r14](%0) nt\"\n        \"mov %%r15, %c[r15](%0) nt\"\n\\#endif\n        \"mov %%cr2, %%\"R\"ax   nt\"\n        \"mov %%\"R\"ax, %c[cr2](%0) nt\"\n\n        \"pop  %%\"R\"bp; pop  %%\"R\"dx nt\"\n        \"setbe %c[fail](%0) nt\"\n          : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\n//下面加了前面寄存器的指针值，对应具体结构的值\n        [launched]\"i\"(offsetof(struct vcpu_vmx, launched)),\n        [fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n        [host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n        [rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n        [rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n        [rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n        [rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n        [rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n        [rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n        [rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n\\#ifdef CONFIG_X86_64\n        [r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n        [r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n        [r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n        [r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n        [r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n        [r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n        [r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n        [r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n\\#endif\n        [cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n        [wordsize]\"i\"(sizeof(ulong))\n          : \"cc\", \"memory\"\n        , R\"ax\", R\"bx\", R\"di\", R\"si\"\n\\#ifdef CONFIG_X86_64\n        , \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n\\#endif\n</pre>\n\n<p>以上代码相对容易理解的，根据注释大致清楚了具体作用。</p>\n<p>然后就是恢复系统NMI等中断:</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nvmx_complete_atomic_exit(vmx);\nvmx_recover_nmi_blocking(vmx);\nvmx_complete_interrupts(vmx);\n</pre>\n\n<p>回到vcpu_enter_guest，通过hw_breakpoint_restore恢复<a href=\"http://www.oenhan.com/jprobe-hw-breakpoint\" title=\"内核调试方法:Jprobe与硬件断点\" target=\"_blank\" rel=\"noopener\">硬件断点</a>。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (hw_breakpoint_active())\n        hw_breakpoint_restore();\n\n    kvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc);\n\n//设置vcpu模式，恢复host相关内容\n    vcpu->mode = OUTSIDE_GUEST_MODE;\n    smp_wmb();\n    local_irq_enable();\n\n    ++vcpu->stat.exits;\n\n    /*\n     \\* We must have an instruction between local_irq_enable() and\n     \\* kvm_guest_exit(), so the timer interrupt isn't delayed by\n     \\* the interrupt shadow.  The stat.exits increment will do nicely.\n     \\* But we need to prevent reordering, hence this barrier():\n     \\*/\n    barrier();\n//刷新系统时间\n    kvm_guest_exit();\n\n    preempt_enable();\n\n    vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n    /*\n     \\* Profile KVM exit RIPs:\n     \\*/\n    if (unlikely(prof_on == KVM_PROFILING)) {\n        unsigned long rip = kvm_rip_read(vcpu);\n        profile_hit(KVM_PROFILING, (void *)rip);\n    }\n\n    kvm_lapic_sync_from_vapic(vcpu);\n//处理vmx退出\n    r = kvm_x86_ops->handle_exit(vcpu);\n</pre>\n\n<p>handle_exit退出函数由vmx_handle_exit实现，主要设置vcpu-&gt;run-&gt;exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下：</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\nstaticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]          = handle_nmi_window,\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr,\n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]              = handle_invd,\n    [EXIT_REASON_INVLPG]              = handle_invlpg,\n    [EXIT_REASON_VMCALL]                  = handle_vmcall,\n    [EXIT_REASON_VMCLEAR]                  = handle_vmx_insn,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmx_insn,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmx_insn,\n    [EXIT_REASON_VMPTRST]                 = handle_vmx_insn,\n    [EXIT_REASON_VMREAD]                  = handle_vmx_insn,\n    [EXIT_REASON_VMRESUME]                = handle_vmx_insn,\n    [EXIT_REASON_VMWRITE]                 = handle_vmx_insn,\n    [EXIT_REASON_VMOFF]                   = handle_vmx_insn,\n    [EXIT_REASON_VMON]                    = handle_vmx_insn,\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    [EXIT_REASON_EPT_VIOLATION]          = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]          = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n};\n</pre>\n\n<p>有handle_task_switch进行<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">任务切换</a>，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。</p>\n<p>再次退回到__vcpu_run函数，在while (r &gt; 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (need_resched()) {\n            srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n            kvm_resched(vcpu);\n            vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n        }\n</pre>\n\n<p>再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。</p>\n<p>KVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。</p>\n<p>KVM源代码分析未完待续</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://www.oenhan.com/kvm-src-2-vm-run\" title=\"KVM源代码分析2:虚拟机的创建与运行\" target=\"_blank\" rel=\"noopener\">虚拟机的创建与运行</a>章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。</p>\n<p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p>\n<p>KVM：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p>\n<h4 id=\"1-VT-x-技术\"><a href=\"#1-VT-x-技术\" class=\"headerlink\" title=\"1.VT-x 技术\"></a>1.VT-x 技术</h4><p>Intel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。</p>\n<p>处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考<a href=\"http://blog.csdn.net/drshenlei/article/details/4265101\" target=\"_blank\" rel=\"noopener\">CPU的运行环、特权级与保护</a>）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。</p>\n<p>为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">中断寄存器</a>）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。</p>\n<p>在<a href=\"http://www.oenhan.com/kvm-src-1\" target=\"_blank\" rel=\"noopener\">KVM源代码分析1:基本工作原理</a>章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。</p>\n<p>如下图<br><img src=\"/2014/12/11/kvm-src-3-cpu/kvm_vmx_intel-1.jpg\" alt=\"\"></p>\n<p>在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。</p>\n<h4 id=\"2-VMCS寄存器\"><a href=\"#2-VMCS寄存器\" class=\"headerlink\" title=\"2.VMCS寄存器\"></a>2.VMCS寄存器</h4><p>VMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的<a href=\"http://www.oenhan.com/gdb-principle\" title=\"gdb工作原理和内核实现\" target=\"_blank\" rel=\"noopener\">寄存器</a>（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。</p>\n<p>VMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域：</p>\n<p><colgroup></colgroup></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"></p>\n<p><col width=\"51*\"> <br>col 1                  | col 2                                                    | col 3<br>———————- | ——————————————————– | —————————————————————–<br> VM-execution controls |  Determines what operations cause VM exits               |  CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etc<br>Guest-state area       |  Saved on VM exits，Reloaded on VM entry                  |  EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc<br> Host-state area       |  Loaded on VM exits                                      |  CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc<br> VM-exit controls      |  Determines which state to save, load, how to transition |  Example: MSR save-load list<br> VM-entry controls     |  Determines which state to load, how to transition       |  Including injecting events (interrupts, exceptions) on entry    </p>\n<p>关于具体控制域的细节，还是翻Intel手册吧。</p>\n<h4 id=\"3-VM-Entry-VM-Exit\"><a href=\"#3-VM-Entry-VM-Exit\" class=\"headerlink\" title=\"3.VM-Entry/VM-Exit\"></a>3.VM-Entry/VM-Exit</h4><p>VM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。</p>\n<p>VM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">发生中断</a>，模拟特权资源等。</p>\n<p>运行在非根模式下的敏感指令一般分为3个方面：</p>\n<p>1.行为没有变化的，也就是说该指令能够正确执行。</p>\n<p>2.行为有变化的，直接产生VM-Exit。</p>\n<p>3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。</p>\n<p>主要说一下”受到VM-Execution控制域控制”的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在<a href=\"http://www.oenhan.com/kvm-src-1\" title=\"KVM源代码分析1:基本工作原理\" target=\"_blank\" rel=\"noopener\">虚拟化</a>场景下是不适用的，典型的就是TSC offset了。</p>\n<p>VM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。</p>\n<h4 id=\"4-KVM-CREATE-VM\"><a href=\"#4-KVM-CREATE-VM\" class=\"headerlink\" title=\"4.KVM_CREATE_VM\"></a>4.KVM_CREATE_VM</h4><p>创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm {\n    struct mm_struct *mm; /* userspace tied to this vm */\n    struct kvm_memslots *memslots;  /*qemu模拟的内存条模型*/\n    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */\n    atomic_t online_vcpus;\n    int last_boosted_vcpu;\n    struct list_head vm_list;  //HOST上VM管理链表，\n    struct kvm_io_bus *buses[KVM_NR_BUSES];\n    struct kvm_vm_stat stat;\n    struct kvm_arch arch; //这个是host的arch的一些参数\n    atomic_t users_count;\n\n    long tlbs_dirty;\n    struct list_head devices;\n};\n</pre>\n\n<p>kvm_arch_init_vm基本没有特别动作，初始化了KVM-&gt;arch，以及更新了kvmclock函数，这个另外再说。<br>而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理<a href=\"http://www.oenhan.com/reiserfs_check_can_fit_pages_for_8tb\" title=\"reiserfs分区空闲8TB写文件提示磁盘空间不足\" target=\"_blank\" rel=\"noopener\">位图</a>，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。</p>\n<h4 id=\"5-KVM-CREATE-VCPU\"><a href=\"#5-KVM-CREATE-VCPU\" class=\"headerlink\" title=\"5.KVM_CREATE_VCPU\"></a>5.KVM_CREATE_VCPU</h4><p>kvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu {\n    struct kvm *kvm;  //归属的KVM\\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier;\n\\#endif\n    int cpu;\n    int vcpu_id;\n    int srcu_idx;\n    int mode;\n    unsigned long requests;\n    unsigned long guest_debug;\n\n    struct mutex mutex;\n    struct kvm_run *run;  //运行时的状态\n\n    int fpu_active;\n    int guest_fpu_loaded, guest_xcr0_loaded;\n    wait_queue_head_t wq; //队列\n    struct pid *pid;\n    int sigset_active;\n    sigset_t sigset;\n    struct kvm_vcpu_stat stat; //一些数据\n\n\\#ifdef CONFIG_HAS_IOMEM\n    int mmio_needed;\n    int mmio_read_completed;\n    int mmio_is_write;\n    int mmio_cur_fragment;\n    int mmio_nr_fragments;\n    struct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS];\n\\#endif\n\n\\#ifdef CONFIG_KVM_ASYNC_PF\n    struct {\n        u32 queued;\n        struct list_head queue;\n        struct list_head done;\n        spinlock_t lock;\n    } async_pf;\n\\#endif\n\n\\#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n    /*\n     \\* Cpu relax intercept or pause loop exit optimization\n     \\* in_spin_loop: set when a vcpu does a pause loop exit\n     \\*  or cpu relax intercepted.\n     \\* dy_eligible: indicates whether vcpu is eligible for directed yield.\n     \\*/\n    struct {\n        bool in_spin_loop;\n        bool dy_eligible;\n    } spin_loop;\n\\#endif\n    bool preempted;\n    struct kvm_vcpu_arch arch;  //当前VCPU虚拟的架构，默认介绍X86\n};\n</pre>\n\n<p>借着看kvm_arch_vcpu_create，它借助kvm_x86_ops-&gt;vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu-&gt;run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_vcpu_arch {\n    /*\n     \\* rip and regs accesses must go through\n     \\* kvm_{register,rip}_{read,write} functions.\n     \\*/unsignedlong regs[NR_VCPU_REGS];\n    u32 regs_avail;\n    u32 regs_dirty;\n//类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0;\n    unsignedlong cr0_guest_owned_bits;\n    unsignedlong cr2;\n    unsignedlong cr3;\n    unsigned long cr4;\n    unsigned long cr4_guest_owned_bits;\n    unsigned long cr8;\n    u32 hflags;\n    u64 efer;\n    u64 apic_base;\n    struct kvm_lapic *apic;    /* kernel irqchip context */\n    unsigned long apic_attention;\n    int32_t apic_arb_prio;\n    int mp_state;\n    u64 ia32_misc_enable_msr;\n    bool tpr_access_reporting;\n    u64 ia32_xss;\n\n    /*\n     \\* Paging state of the vcpu\n     \\*\n     \\* If the vcpu runs in guest mode with two level paging this still saves\n     \\* the paging mode of the l1 guest. This context is always used to\n     \\* handle faults.\n     \\*/\n    struct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数\n\n    /*\n     \\* Paging state of an L2 guest (used for nested npt)\n     \\*\n     \\* This context will save all necessary information to walk page tables\n     \\* of the an L2 guest. This context is only initialized for page table\n     \\* walking and not for faulting since we never handle l2 page faults on\n     \\* the host.\n     \\*/\n    struct kvm_mmu nested_mmu;\n\n    /*\n     \\* Pointer to the mmu context currently used for\n     \\* gva_to_gpa translations.\n     \\*/\n    struct kvm_mmu *walk_mmu;\n\n    struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n    struct kvm_mmu_memory_cache mmu_page_cache;\n    struct kvm_mmu_memory_cache mmu_page_header_cache;\n\n    struct fpu guest_fpu;\n    u64 xcr0;\n    u64 guest_supported_xcr0;\n    u32 guest_xstate_size;\n\n    struct kvm_pio_request pio;\n    void *pio_data;\n\n    u8 event_exit_inst_len;\n\n    struct kvm_queued_exception {\n        bool pending;\n        bool has_error_code;\n        bool reinject;\n        u8 nr;\n        u32 error_code;\n    } exception;\n\n    struct kvm_queued_interrupt {\n        bool pending;\n        bool soft;\n        u8 nr;\n    } interrupt;\n\n    int halt_request; /* real mode on Intel only */\n\n    int cpuid_nent;\n    struct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];\n\n    int maxphyaddr;\n\n    /* emulate context */\n//下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套\n    struct x86_emulate_ctxt emulate_ctxt;\n    bool emulate_regs_need_sync_to_vcpu;\n    bool emulate_regs_need_sync_from_vcpu;\n    int (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n    gpa_t time;\n    struct pvclock_vcpu_time_info hv_clock;\n    unsigned int hw_tsc_khz;\n    struct gfn_to_hva_cache pv_time;\n    bool pv_time_enabled;\n    /* set guest stopped flag in pvclock flags field */\n    bool pvclock_set_guest_stopped_request;\n\n    struct {\n        u64 msr_val;\n        u64 last_steal;\n        u64 accum_steal;\n        struct gfn_to_hva_cache stime;\n        struct kvm_steal_time steal;\n    } st;\n\n    u64 last_guest_tsc;\n    u64 last_host_tsc;\n    u64 tsc_offset_adjustment;\n    u64 this_tsc_nsec;\n    u64 this_tsc_write;\n    u64 this_tsc_generation;\n    bool tsc_catchup;\n    bool tsc_always_catchup;\n    s8 virtual_tsc_shift;\n    u32 virtual_tsc_mult;\n    u32 virtual_tsc_khz;\n    s64 ia32_tsc_adjust_msr;\n\n    atomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n    unsigned nmi_pending; /* NMI queued after currently running handler */\n    bool nmi_injected;    /* Trying to inject an NMI this entry */\n\n    struct mtrr_state_type mtrr_state;\n    u64 pat;\n\n    unsigned switch_db_regs;\n    unsigned long db[KVM_NR_DB_REGS];\n    unsigned long dr6;\n    unsigned long dr7;\n    unsigned long eff_db[KVM_NR_DB_REGS];\n    unsigned long guest_debug_dr7;\n\n    u64 mcg_cap;\n    u64 mcg_status;\n    u64 mcg_ctl;\n    u64 *mce_banks;\n\n    /* Cache MMIO info */\n    u64 mmio_gva;\n    unsigned access;\n    gfn_t mmio_gfn;\n    u64 mmio_gen;\n\n    struct kvm_pmu pmu;\n\n    /* used for guest single stepping over the given code position */\n    unsigned long singlestep_rip;\n\n    /* fields used by HYPER-V emulation */\n    u64 hv_vapic;\n\n    cpumask_var_t wbinvd_dirty_mask;\n\n    unsigned long last_retry_eip;\n    unsigned long last_retry_addr;\n\n    struct {\n        bool halted;\n        gfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];\n        struct gfn_to_hva_cache data;\n        u64 msr_val;\n        u32 id;\n        bool send_user_only;\n    } apf;\n\n    /* OSVW MSRs (AMD only) */\n    struct {\n        u64 length;\n        u64 status;\n    } osvw;\n\n    struct {\n        u64 msr_val;\n        struct gfn_to_hva_cache data;\n    } pv_eoi;\n\n    /*\n     \\* Indicate whether the access faults on its page table in guest\n     \\* which is set when fix page fault and used to detect unhandeable\n     \\* instruction.\n     \\*/\n    bool write_fault_to_shadow_pgtable;\n\n    /* set at EPT violation at this point */\n    unsigned long exit_qualification;\n\n    /* pv related host specific info */\n    struct {\n        bool pv_unhalted;\n    } pv;\n};\n</pre>\n\n<p>整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。<br>kvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu-&gt;arch.emulate_ctxt.ops = &amp;emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nstatic struct x86_emulate_ops emulate_ops = {\n    .read_std            = kvm_read_guest_virt_system,\n    .write_std           = kvm_write_guest_virt_system,\n    .fetch               = kvm_fetch_guest_virt,\n    .read_emulated       = emulator_read_emulated,\n    .write_emulated      = emulator_write_emulated,\n    .cmpxchg_emulated    = emulator_cmpxchg_emulated,\n    .invlpg              = emulator_invlpg,\n    .pio_in_emulated     = emulator_pio_in_emulated,\n    .pio_out_emulated    = emulator_pio_out_emulated,\n    .get_segment         = emulator_get_segment,\n    .set_segment         = emulator_set_segment,\n    .get_cached_segment_base = emulator_get_cached_segment_base,\n    .get_gdt             = emulator_get_gdt,\n    .get_idt         = emulator_get_idt,\n    .set_gdt             = emulator_set_gdt,\n    .set_idt         = emulator_set_idt,\n    .get_cr              = emulator_get_cr,\n    .set_cr              = emulator_set_cr,\n    .cpl                 = emulator_get_cpl,\n    .get_dr              = emulator_get_dr,\n    .set_dr              = emulator_set_dr,\n    .set_msr             = emulator_set_msr,\n    .get_msr             = emulator_get_msr,\n    .halt                = emulator_halt,\n    .wbinvd              = emulator_wbinvd,\n    .fix_hypercall       = emulator_fix_hypercall,\n    .get_fpu             = emulator_get_fpu,\n    .put_fpu             = emulator_put_fpu,\n    .intercept           = emulator_intercept,\n    .get_cpuid           = emulator_get_cpuid,\n};\n</pre>\n\n<p>x86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。<br>回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx-&gt;loaded_vmcs-&gt;vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从<a href=\"http://www.oenhan.com/size-512-slab-kmalloc\" title=\"从size-512内存泄露看slab分配\" target=\"_blank\" rel=\"noopener\">伙伴系统</a>申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf-&gt;order = get_order(vmcs_config.size)，而vmcs_conf-&gt;size = vmx_msr_high &amp; 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。<br>下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。<br>vmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。<br>vmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops-&gt;vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。<br>kvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。<br>如此整个vcpu就创建完成了。</p>\n<p>6.KVM_RUN</p>\n<p>KVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。</p>\n<p>下一篇：</p>\n<p><a href=\"http://www.oenhan.com/kvm-src-4-mem\" target=\"_blank\" rel=\"noopener\">KVM源代码分析4:内存虚拟化</a></p>\n<p>———-完———-</p>\n<p>——————–下面未编辑的留存————————————-<br>给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个<a href=\"http://www.oenhan.com/linux-kernel-khugepaged\" title=\"hugepage内存管理机制\" target=\"_blank\" rel=\"noopener\">页大小内存</a>，用来保存vm和vmm信息。</p>\n<pre class=\"lang:c decode:1 hljs php\">\n    vmx->vmcs = alloc_vmcs();\n    if (!vmx->vmcs)\n        goto free_msrs;\n\n    vmcs_init(vmx->vmcs);\n</pre>\n\n<p>执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。</p>\n<p>vmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。</p>\n<p>vcpu的创建到此结束，下面说一下vcpu的运行。</p>\n<p>VCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。</p>\n<p>KVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu-&gt;requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops-&gt;prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nkvm_x86_ops->prepare_guest_switch(vcpu);\n    if (vcpu->fpu_active)\n        kvm_load_guest_fpu(vcpu);\n    kvm_load_guest_xcr0(vcpu);\n\n    vcpu->mode = IN_GUEST_MODE;\n\n    /* We should set ->mode before check ->requests,\n     \\* see the comment in make_all_cpus_request.\n     \\*/\n    smp_mb();\n\n    local_irq_disable();\n</pre>\n\n<p>然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu-&gt;mode和vcpu-&gt;requests等，如果有问题，则恢复host状态。</p>\n<p>kvm_guest_enter做了两件事：account_system_vtime计算虚拟机<a href=\"http://www.oenhan.com/glibc_pthread_cond_timedwait_disable\" title=\"Glibc更新导致pthread_cond_timedwait失效\" target=\"_blank\" rel=\"noopener\">系统时间</a>；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。</p>\n<p>准备工作搞定，kvm_x86_ops-&gt;run(vcpu)，开始运行guest，由vmx_vcpu_run实现。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (vmx->emulation_required && emulate_invalid_guest_state)\n        return;\n\n    if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n        vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n    if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n        vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n</pre>\n\n<p>判断模拟器，RSP，RIP寄存器值。</p>\n<p>主要功能在这段内联汇编上</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nasm(\n                /* Store host registers */\n        \"push %%\"R\"dx; push %%\"R\"bp;\"\n        \"push %%\"R\"cx nt\" /* placeholder for guest rcx */\n        \"push %%\"R\"cx nt\"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上\n        \"cmp %%\"R\"sp, %c[host_rsp](%0) nt\"\"je 1f nt\"\"mov %%\"R\"sp, %c[host_rsp](%0) nt\"\n        __ex(ASM_VMX_VMWRITE_RSP_RDX) \"nt\"//__kvm_handle_fault_on_reboot write host rsp\"1: nt\"/* Reload cr2 if changed */\n        \"mov %c[cr2](%0), %%\"R\"ax nt\"\n        \"mov %%cr2, %%\"R\"dx nt\"\n                //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上\n        \"cmp %%\"R\"ax, %%\"R\"dx nt\"\n        \"je 2f nt\"\n        \"mov %%\"R\"ax, %%cr2 nt\"\n        \"2: nt\"\n        /* Check if vmlaunch of vmresume is needed */\n        \"cmpl $0, %c[launched](%0) nt\"\n        /* Load guest registers.  Don't clobber flags. */\n        \"mov %c[rax](%0), %%\"R\"ax nt\"\n        \"mov %c[rbx](%0), %%\"R\"bx nt\"\n        \"mov %c[rdx](%0), %%\"R\"dx nt\"\n        \"mov %c[rsi](%0), %%\"R\"si nt\"\n        \"mov %c[rdi](%0), %%\"R\"di nt\"\n        \"mov %c[rbp](%0), %%\"R\"bp nt\"\n\\#ifdef CONFIG_X86_64\n        \"mov %c[r8](%0),  %%r8  nt\"\n        \"mov %c[r9](%0),  %%r9  nt\"\n        \"mov %c[r10](%0), %%r10 nt\"\n        \"mov %c[r11](%0), %%r11 nt\"\n        \"mov %c[r12](%0), %%r12 nt\"\n        \"mov %c[r13](%0), %%r13 nt\"\n        \"mov %c[r14](%0), %%r14 nt\"\n        \"mov %c[r15](%0), %%r15 nt\"\n\\#endif\n        \"mov %c[rcx](%0), %%\"R\"cx nt\" /* kills %0 (ecx) */\n\n        /* Enter guest mode */\n                //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式\n                //RESUME和LAUNCH，通过__ex  __kvm_handle_fault_on_reboot执行\n        \"jne .Llaunched nt\"\n        __ex(ASM_VMX_VMLAUNCH) \"nt\"\n        \"jmp .Lkvm_vmx_return nt\"\n        \".Llaunched: \" __ex(ASM_VMX_VMRESUME) \"nt\"\n                 //退出vmx，保存guest信息，加载host信息\n        \".Lkvm_vmx_return: \"\n        /* Save guest registers, load host registers, keep flags */\n        \"mov %0, %c[wordsize](%%\"R\"sp) nt\"\n        \"pop %0 nt\"\n        \"mov %%\"R\"ax, %c[rax](%0) nt\"\n        \"mov %%\"R\"bx, %c[rbx](%0) nt\"\n        \"pop\"Q\" %c[rcx](%0) nt\"\n        \"mov %%\"R\"dx, %c[rdx](%0) nt\"\n        \"mov %%\"R\"si, %c[rsi](%0) nt\"\n        \"mov %%\"R\"di, %c[rdi](%0) nt\"\n        \"mov %%\"R\"bp, %c[rbp](%0) nt\"\n\\#ifdef CONFIG_X86_64\n        \"mov %%r8,  %c[r8](%0) nt\"\n        \"mov %%r9,  %c[r9](%0) nt\"\n        \"mov %%r10, %c[r10](%0) nt\"\n        \"mov %%r11, %c[r11](%0) nt\"\n        \"mov %%r12, %c[r12](%0) nt\"\n        \"mov %%r13, %c[r13](%0) nt\"\n        \"mov %%r14, %c[r14](%0) nt\"\n        \"mov %%r15, %c[r15](%0) nt\"\n\\#endif\n        \"mov %%cr2, %%\"R\"ax   nt\"\n        \"mov %%\"R\"ax, %c[cr2](%0) nt\"\n\n        \"pop  %%\"R\"bp; pop  %%\"R\"dx nt\"\n        \"setbe %c[fail](%0) nt\"\n          : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\n//下面加了前面寄存器的指针值，对应具体结构的值\n        [launched]\"i\"(offsetof(struct vcpu_vmx, launched)),\n        [fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n        [host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n        [rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n        [rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n        [rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n        [rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n        [rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n        [rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n        [rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n\\#ifdef CONFIG_X86_64\n        [r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n        [r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n        [r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n        [r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n        [r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n        [r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n        [r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n        [r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n\\#endif\n        [cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n        [wordsize]\"i\"(sizeof(ulong))\n          : \"cc\", \"memory\"\n        , R\"ax\", R\"bx\", R\"di\", R\"si\"\n\\#ifdef CONFIG_X86_64\n        , \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n\\#endif\n</pre>\n\n<p>以上代码相对容易理解的，根据注释大致清楚了具体作用。</p>\n<p>然后就是恢复系统NMI等中断:</p>\n<pre class=\"lang:c decode:1 hljs bash\">\nvmx_complete_atomic_exit(vmx);\nvmx_recover_nmi_blocking(vmx);\nvmx_complete_interrupts(vmx);\n</pre>\n\n<p>回到vcpu_enter_guest，通过hw_breakpoint_restore恢复<a href=\"http://www.oenhan.com/jprobe-hw-breakpoint\" title=\"内核调试方法:Jprobe与硬件断点\" target=\"_blank\" rel=\"noopener\">硬件断点</a>。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (hw_breakpoint_active())\n        hw_breakpoint_restore();\n\n    kvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc);\n\n//设置vcpu模式，恢复host相关内容\n    vcpu->mode = OUTSIDE_GUEST_MODE;\n    smp_wmb();\n    local_irq_enable();\n\n    ++vcpu->stat.exits;\n\n    /*\n     \\* We must have an instruction between local_irq_enable() and\n     \\* kvm_guest_exit(), so the timer interrupt isn't delayed by\n     \\* the interrupt shadow.  The stat.exits increment will do nicely.\n     \\* But we need to prevent reordering, hence this barrier():\n     \\*/\n    barrier();\n//刷新系统时间\n    kvm_guest_exit();\n\n    preempt_enable();\n\n    vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n    /*\n     \\* Profile KVM exit RIPs:\n     \\*/\n    if (unlikely(prof_on == KVM_PROFILING)) {\n        unsigned long rip = kvm_rip_read(vcpu);\n        profile_hit(KVM_PROFILING, (void *)rip);\n    }\n\n    kvm_lapic_sync_from_vapic(vcpu);\n//处理vmx退出\n    r = kvm_x86_ops->handle_exit(vcpu);\n</pre>\n\n<p>handle_exit退出函数由vmx_handle_exit实现，主要设置vcpu-&gt;run-&gt;exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下：</p>\n<pre class=\"lang:c decode:1 hljs objectivec\">\nstaticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception,\n    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n    [EXIT_REASON_NMI_WINDOW]          = handle_nmi_window,\n    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n    [EXIT_REASON_CR_ACCESS]               = handle_cr,\n    [EXIT_REASON_DR_ACCESS]               = handle_dr,\n    [EXIT_REASON_CPUID]                   = handle_cpuid,\n    [EXIT_REASON_MSR_READ]                = handle_rdmsr,\n    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,\n    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,\n    [EXIT_REASON_HLT]                     = handle_halt,\n    [EXIT_REASON_INVD]              = handle_invd,\n    [EXIT_REASON_INVLPG]              = handle_invlpg,\n    [EXIT_REASON_VMCALL]                  = handle_vmcall,\n    [EXIT_REASON_VMCLEAR]                  = handle_vmx_insn,\n    [EXIT_REASON_VMLAUNCH]                = handle_vmx_insn,\n    [EXIT_REASON_VMPTRLD]                 = handle_vmx_insn,\n    [EXIT_REASON_VMPTRST]                 = handle_vmx_insn,\n    [EXIT_REASON_VMREAD]                  = handle_vmx_insn,\n    [EXIT_REASON_VMRESUME]                = handle_vmx_insn,\n    [EXIT_REASON_VMWRITE]                 = handle_vmx_insn,\n    [EXIT_REASON_VMOFF]                   = handle_vmx_insn,\n    [EXIT_REASON_VMON]                    = handle_vmx_insn,\n    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n    [EXIT_REASON_WBINVD]                  = handle_wbinvd,\n    [EXIT_REASON_XSETBV]                  = handle_xsetbv,\n    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n    [EXIT_REASON_EPT_VIOLATION]          = handle_ept_violation,\n    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n    [EXIT_REASON_MWAIT_INSTRUCTION]          = handle_invalid_op,\n    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n};\n</pre>\n\n<p>有handle_task_switch进行<a href=\"http://www.oenhan.com/rwsem-realtime-task-hung\" title=\"读写信号量与实时进程阻塞挂死问题\" target=\"_blank\" rel=\"noopener\">任务切换</a>，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。</p>\n<p>再次退回到__vcpu_run函数，在while (r &gt; 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif (need_resched()) {\n            srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n            kvm_resched(vcpu);\n            vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n        }\n</pre>\n\n<p>再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。</p>\n<p>KVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。</p>\n<p>KVM源代码分析未完待续</p>\n"},{"title":"KVM源代码分析4:内存虚拟化","donate":true,"date":"2014-12-11T03:05:05.000Z","_content":"\n代码版本：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v3.16.37\n\n在虚拟机的创建与运行中pc_init_pci负责(\"KVM源代码分析2:虚拟机的创建与运行\")，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine->init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。\n\n插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedefstruct RAMBlock {\n//对应宿主的内存地址\n    uint8_t *host;\n//block在ramlist中的偏移\n    ram_addr_t offset;\n//block长度\n    ram_addr_t length;\n    uint32_t flags;\n//block名字\n    char idstr[256];\n    QLIST_ENTRY(RAMBlock) next;\n\\#if defined(__linux__) && !defined(TARGET_S390X)\n    int fd;\n\\#endif\n} RAMBlock;\n\ntypedef struct RAMList {\n//看代码理解就是list的head，但是不知道为啥叫dirty...\n    uint8_t *phys_dirty;\n    QLIST_HEAD(ram, RAMBlock) blocks;\n} RAMList;\n</pre>\n\n下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在\"KVM源代码分析2:虚拟机的创建与运行\"，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block->host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid \\*qemu_memalign(size_t alignment, size_t size){\n    void *ptr;\n//使用posix进行内存针对页大小对齐\n\\#if defined(_POSIX_C_SOURCE) && !defined(__sun__)\n    int ret;\n    ret = posix_memalign(&ptr, alignment, size);\n    if (ret != 0) {\n        fprintf(stderr, \"Failed to allocate %zu B: %sn\",\n                size, strerror(ret));\n        abort();\n    }\n\\#elif defined(CONFIG_BSD)\n    ptr = qemu_oom_check(valloc(size));\n\\#else\n//所谓检查oom就是看memalign对应malloc申请内存是否成功\n    ptr = qemu_oom_check(memalign(alignment, size));\n\\#endif\n    trace_qemu_memalign(alignment, size, ptr);\n    return ptr;\n}\n</pre>\n\n以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。  \n然后一层层的退回到pc_memory_init函数。\n\n此时pc.ram已经分配完成，ram_addr已经拿到了[分配的内存](http://www.oenhan.com/kernel-program-exec \"从一次内存泄露看程序在内核中的执行过程\")地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_userspace_memory_region {\n__u32 slot;\n__u32 flags;\n__u64 guest_phys_addr;\n__u64 memory_size; /* bytes */\n__u64 userspace_addr; /* start of the userspace allocated memory */\n};\n</pre>\n\nkvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到__kvm_set_memory_region函数，check_memory_region_flags检查mem->flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem->memory_size & (PAGE_SIZE - 1))要求以页为单位，(mem->guest_phys_addr & (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem->userspace_addr & (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void __user *)(unsigned long)mem->userspace_addr,mem->memory_size))则保证host的线性地址页对齐而且该地址域有写权限。  \nid_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm \"KVM源代码分析2:虚拟机的创建与运行\"中，kvm_init_memslots_id初始化对应关系，即slots->id_to_index[i] = slots->memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。  \n扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：\n\n<pre class=\"lang:c decode:1 hljs cs\">\n//映射内存有大小，不是删除内存条if (npages) {\n//内存槽号没有虚拟内存条，意味内存新创建if (!old.npages)\n\t\tchange = KVM_MR_CREATE;\n\telse { /* Modify an existing slot. */\n//修改已存在的内存修改标志或者平移映射地址\n//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）\n\t\tif ((mem->userspace_addr != old.userspace_addr) ||\n\t\t    (npages != old.npages) ||\n\t\t    ((new.flags ^ old.flags) & KVM_MEM_READONLY))\n\t\t\tgoto out;\n//guest地址不同，内存条平移\n\t\tif (base_gfn != old.base_gfn)\n\t\t\tchange = KVM_MR_MOVE;\n\t\telse if (new.flags != old.flags)\n//修改属性\n\t\t\tchange = KVM_MR_FLAGS_ONLY;\n\t\telse { /* Nothing to change. */\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n} else if (old.npages) {\n//申请插入的内存为0，而内存槽上有内存，意味删除\n\tchange = KVM_MR_DELETE;\n} else /* Modify a non-existent slot: disallowed. */\n\tgoto out;\n</pre>\n\n另外看kvm_mr_change就知道memslot的变动值了：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nenum kvm_mr_change {\n\tKVM_MR_CREATE,\n\tKVM_MR_DELETE,\n\tKVM_MR_MOVE,\n\tKVM_MR_FLAGS_ONLY,\n};\n</pre>\n\n在往下是一段检查\n\n<pre class=\"lang:c decode:1 hljs php\">\nif ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {\n\t/* Check for overlaps */\n\tr = -EEXIST;\n\tkvm_for_each_memslot(slot, kvm->memslots) {\n\t\tif ((slot->id >= KVM_USER_MEM_SLOTS) ||\n//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的\n\t\t    (slot->id == mem->slot))\n\t\t\tcontinue;\n//下面就是当前已有的slot与new在guest线性区间上有交集\n\t\tif (!((base_gfn + npages <= slot->base_gfn) ||\n\t\t      (base_gfn >= slot->base_gfn + slot->npages)))\n\t\t\tgoto out;\n//out错误码就是EEXIST\n\t}\n}\n</pre>\n\n如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot->base_gfn + npages - 1,slot->base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages>>0*9,然后为slot->arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages>>1*9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。  \n如果有脏页,并且脏页位图为空,则分配[脏页位图](http://www.oenhan.com/linux-cache-writeback), kvm_create_dirty_bitmap实际就是\"页数/8\".\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n\t\tif (kvm_create_dirty_bitmap(&new) < 0)\n\t\t\tgoto out_free;\n\t}\n</pre>\n\n当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm->memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots->generation的值。\n\n内存的添加说完了，看一下[EPT页表](http://www.oenhan.com/kernel-program-exec)的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu->arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。\n\n<pre class=\"hljs php\">\ncontext->page_fault = tdp_page_fault;\ncontext->sync_page = nonpaging_sync_page;\ncontext->invlpg = nonpaging_invlpg;\ncontext->update_pte = nonpaging_update_pte;\ncontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\ncontext->root_hpa = INVALID_PAGE;\ncontext->direct_map = true;\ncontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\ncontext->get_cr3 = get_cr3;\ncontext->get_pdptr = kvm_pdptr_read;\ncontext->inject_page_fault = kvm_inject_page_fault;\n</pre>\n\n当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。\n\n<pre class=\"hljs cpp\">\n//填充kvm mmu专用的slab\nr = mmu_topup_memory_caches(vcpu);\n//获取gfn使用的level，即hugepage的问题\nforce_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);\nif (likely(!force_pt_level)) {\n\tlevel = mapping_level(vcpu, gfn);\n\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n} else\n\tlevel = PT_PAGE_TABLE_LEVEL;\n\n//顾名思义，快速处理一个简单的page fault\n//即present同时有写权限的非mmio page fault\n//参考page_fault_can_be_fast函数\n//一部分处理没有写权限的page fault\n//一部分处理 TLB lazy\n//fast_pf_fix_direct_spte也就是将pte获取的写权限\nif (fast_page_fault(vcpu, gpa, level, error_code))\n\treturn 0;\n//下面函数主要就一件事情，gfn_to_pfn\nif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n      return 0;\n//direct map就是映射ept页表的过程\nr = __direct_map(vcpu, gpa, write, map_writable,\n      level, gfn, pfn, prefault);\n</pre>\n\n在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:\n\n<pre class=\"hljs objectivec\">\nstatic pfn_t\n__gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,\n\t\t     bool *async, bool write_fault, bool *writable)\n{\n\tunsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n\tif (addr == KVM_HVA_ERR_RO_BAD)\n\t\treturn KVM_PFN_ERR_RO_FAULT;\n\n\tif (kvm_is_error_hva(addr))\n\t\treturn KVM_PFN_NOSLOT;\n\n\t/* Do not map writable pfn in the readonly memslot. */\n\tif (writable && memslot_is_readonly(slot)) {\n\t\t*writable = false;\n\t\twritable = NULL;\n\t}\n\n\treturn hva_to_pfn(addr, atomic, async, write_fault,\n\t\t\t  writable);\n}\n</pre>\n\ngfn2hva本质就是\n\n<pre class=\"hljs cpp\">\nstaticinline unsigned long\n__gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE;\n}\n</pre>\n\n而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。\n\n<pre class=\"hljs php\">\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,\n\t\t\tint map_writable, int level, gfn_t gfn, pfn_t pfn,\n\t\t\tbool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn0;\n//遍历ept四级页表\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n//如果是最后一级，level是hugepage下的level\n\t\tif (iterator.level == level) {\n//设置pte，页表下一级的page地址就是pfn写入到pte\n\t\t\tmmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t     write, &emulate, level, gfn, pfn,\n\t\t\t\t     prefault, map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n//mmu page不在位的情况，也就是缺页\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n//获取指向的具体mmu page entry的index\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n//获取mmu page\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1,\n\t\t\t\t\t      1, ACC_ALL, iterator.sptep);\n//将当前的mmu page的地址写入到上一级别mmu page的pte中\n\t\t\tlink_shadow_page(iterator.sptep, sp, true);\n\t\t}\n\t}\n\treturn emulate;\n}\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access,\n\t\t\t\t\t     u64 *parent_pte)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n//根据一个hash索引来的\n\tfor_each_gfn_sp(vcpu->kvm, sp, gfn) {\n//检查整个mmu ept是否被失效了\n\t\tif (is_obsolete_sp(vcpu->kvm, sp))\n\t\t\tcontinue;\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync && kvm_sync_page_transient(vcpu, sp))\n\t\t\tbreak;\n\n\t\tmmu_page_add_parent_pte(vcpu, sp, parent_pte);\n\t\tif (sp->unsync_children) {\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\tkvm_mmu_mark_parents_unsync(sp);\n\t\t} else if (sp->unsync)\n\t\t\tkvm_mmu_mark_parents_unsync(sp);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\tsp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);\n\tif (!sp)\n\t\treturn sp;\n\tsp->gfn = gfn;\n\tsp->role = role;\n//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有\n//被分配\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\tif (rmap_write_protect(vcpu->kvm, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tkvm_sync_pages(vcpu, gfn);\n\n\t\taccount_shadowed(vcpu->kvm, gfn);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tinit_shadow_page_table(sp);\n\ttrace_kvm_mmu_get_page(sp, true);\n\treturn sp;\n}\n</pre>\n\n这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。\n","source":"_posts/kvm-src-4-mem.md","raw":"---\ntitle: KVM源代码分析4:内存虚拟化\ndonate: true\ndate: 2014-12-11 11:05:05\ncategories: KVM\ntags: KVM\n---\n\n代码版本：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v3.16.37\n\n在虚拟机的创建与运行中pc_init_pci负责(\"KVM源代码分析2:虚拟机的创建与运行\")，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine->init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。\n\n插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedefstruct RAMBlock {\n//对应宿主的内存地址\n    uint8_t *host;\n//block在ramlist中的偏移\n    ram_addr_t offset;\n//block长度\n    ram_addr_t length;\n    uint32_t flags;\n//block名字\n    char idstr[256];\n    QLIST_ENTRY(RAMBlock) next;\n\\#if defined(__linux__) && !defined(TARGET_S390X)\n    int fd;\n\\#endif\n} RAMBlock;\n\ntypedef struct RAMList {\n//看代码理解就是list的head，但是不知道为啥叫dirty...\n    uint8_t *phys_dirty;\n    QLIST_HEAD(ram, RAMBlock) blocks;\n} RAMList;\n</pre>\n\n下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在\"KVM源代码分析2:虚拟机的创建与运行\"，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block->host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid \\*qemu_memalign(size_t alignment, size_t size){\n    void *ptr;\n//使用posix进行内存针对页大小对齐\n\\#if defined(_POSIX_C_SOURCE) && !defined(__sun__)\n    int ret;\n    ret = posix_memalign(&ptr, alignment, size);\n    if (ret != 0) {\n        fprintf(stderr, \"Failed to allocate %zu B: %sn\",\n                size, strerror(ret));\n        abort();\n    }\n\\#elif defined(CONFIG_BSD)\n    ptr = qemu_oom_check(valloc(size));\n\\#else\n//所谓检查oom就是看memalign对应malloc申请内存是否成功\n    ptr = qemu_oom_check(memalign(alignment, size));\n\\#endif\n    trace_qemu_memalign(alignment, size, ptr);\n    return ptr;\n}\n</pre>\n\n以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。  \n然后一层层的退回到pc_memory_init函数。\n\n此时pc.ram已经分配完成，ram_addr已经拿到了[分配的内存](http://www.oenhan.com/kernel-program-exec \"从一次内存泄露看程序在内核中的执行过程\")地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_userspace_memory_region {\n__u32 slot;\n__u32 flags;\n__u64 guest_phys_addr;\n__u64 memory_size; /* bytes */\n__u64 userspace_addr; /* start of the userspace allocated memory */\n};\n</pre>\n\nkvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到__kvm_set_memory_region函数，check_memory_region_flags检查mem->flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem->memory_size & (PAGE_SIZE - 1))要求以页为单位，(mem->guest_phys_addr & (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem->userspace_addr & (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void __user *)(unsigned long)mem->userspace_addr,mem->memory_size))则保证host的线性地址页对齐而且该地址域有写权限。  \nid_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm \"KVM源代码分析2:虚拟机的创建与运行\"中，kvm_init_memslots_id初始化对应关系，即slots->id_to_index[i] = slots->memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。  \n扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：\n\n<pre class=\"lang:c decode:1 hljs cs\">\n//映射内存有大小，不是删除内存条if (npages) {\n//内存槽号没有虚拟内存条，意味内存新创建if (!old.npages)\n\t\tchange = KVM_MR_CREATE;\n\telse { /* Modify an existing slot. */\n//修改已存在的内存修改标志或者平移映射地址\n//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）\n\t\tif ((mem->userspace_addr != old.userspace_addr) ||\n\t\t    (npages != old.npages) ||\n\t\t    ((new.flags ^ old.flags) & KVM_MEM_READONLY))\n\t\t\tgoto out;\n//guest地址不同，内存条平移\n\t\tif (base_gfn != old.base_gfn)\n\t\t\tchange = KVM_MR_MOVE;\n\t\telse if (new.flags != old.flags)\n//修改属性\n\t\t\tchange = KVM_MR_FLAGS_ONLY;\n\t\telse { /* Nothing to change. */\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n} else if (old.npages) {\n//申请插入的内存为0，而内存槽上有内存，意味删除\n\tchange = KVM_MR_DELETE;\n} else /* Modify a non-existent slot: disallowed. */\n\tgoto out;\n</pre>\n\n另外看kvm_mr_change就知道memslot的变动值了：\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nenum kvm_mr_change {\n\tKVM_MR_CREATE,\n\tKVM_MR_DELETE,\n\tKVM_MR_MOVE,\n\tKVM_MR_FLAGS_ONLY,\n};\n</pre>\n\n在往下是一段检查\n\n<pre class=\"lang:c decode:1 hljs php\">\nif ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {\n\t/* Check for overlaps */\n\tr = -EEXIST;\n\tkvm_for_each_memslot(slot, kvm->memslots) {\n\t\tif ((slot->id >= KVM_USER_MEM_SLOTS) ||\n//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的\n\t\t    (slot->id == mem->slot))\n\t\t\tcontinue;\n//下面就是当前已有的slot与new在guest线性区间上有交集\n\t\tif (!((base_gfn + npages <= slot->base_gfn) ||\n\t\t      (base_gfn >= slot->base_gfn + slot->npages)))\n\t\t\tgoto out;\n//out错误码就是EEXIST\n\t}\n}\n</pre>\n\n如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot->base_gfn + npages - 1,slot->base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages>>0*9,然后为slot->arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages>>1*9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。  \n如果有脏页,并且脏页位图为空,则分配[脏页位图](http://www.oenhan.com/linux-cache-writeback), kvm_create_dirty_bitmap实际就是\"页数/8\".\n\n<pre class=\"lang:c decode:1 hljs cpp\">\nif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n\t\tif (kvm_create_dirty_bitmap(&new) < 0)\n\t\t\tgoto out_free;\n\t}\n</pre>\n\n当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm->memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots->generation的值。\n\n内存的添加说完了，看一下[EPT页表](http://www.oenhan.com/kernel-program-exec)的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu->arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。\n\n<pre class=\"hljs php\">\ncontext->page_fault = tdp_page_fault;\ncontext->sync_page = nonpaging_sync_page;\ncontext->invlpg = nonpaging_invlpg;\ncontext->update_pte = nonpaging_update_pte;\ncontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\ncontext->root_hpa = INVALID_PAGE;\ncontext->direct_map = true;\ncontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\ncontext->get_cr3 = get_cr3;\ncontext->get_pdptr = kvm_pdptr_read;\ncontext->inject_page_fault = kvm_inject_page_fault;\n</pre>\n\n当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。\n\n<pre class=\"hljs cpp\">\n//填充kvm mmu专用的slab\nr = mmu_topup_memory_caches(vcpu);\n//获取gfn使用的level，即hugepage的问题\nforce_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);\nif (likely(!force_pt_level)) {\n\tlevel = mapping_level(vcpu, gfn);\n\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n} else\n\tlevel = PT_PAGE_TABLE_LEVEL;\n\n//顾名思义，快速处理一个简单的page fault\n//即present同时有写权限的非mmio page fault\n//参考page_fault_can_be_fast函数\n//一部分处理没有写权限的page fault\n//一部分处理 TLB lazy\n//fast_pf_fix_direct_spte也就是将pte获取的写权限\nif (fast_page_fault(vcpu, gpa, level, error_code))\n\treturn 0;\n//下面函数主要就一件事情，gfn_to_pfn\nif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n      return 0;\n//direct map就是映射ept页表的过程\nr = __direct_map(vcpu, gpa, write, map_writable,\n      level, gfn, pfn, prefault);\n</pre>\n\n在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:\n\n<pre class=\"hljs objectivec\">\nstatic pfn_t\n__gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,\n\t\t     bool *async, bool write_fault, bool *writable)\n{\n\tunsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n\tif (addr == KVM_HVA_ERR_RO_BAD)\n\t\treturn KVM_PFN_ERR_RO_FAULT;\n\n\tif (kvm_is_error_hva(addr))\n\t\treturn KVM_PFN_NOSLOT;\n\n\t/* Do not map writable pfn in the readonly memslot. */\n\tif (writable && memslot_is_readonly(slot)) {\n\t\t*writable = false;\n\t\twritable = NULL;\n\t}\n\n\treturn hva_to_pfn(addr, atomic, async, write_fault,\n\t\t\t  writable);\n}\n</pre>\n\ngfn2hva本质就是\n\n<pre class=\"hljs cpp\">\nstaticinline unsigned long\n__gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE;\n}\n</pre>\n\n而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。\n\n<pre class=\"hljs php\">\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,\n\t\t\tint map_writable, int level, gfn_t gfn, pfn_t pfn,\n\t\t\tbool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn0;\n//遍历ept四级页表\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n//如果是最后一级，level是hugepage下的level\n\t\tif (iterator.level == level) {\n//设置pte，页表下一级的page地址就是pfn写入到pte\n\t\t\tmmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t     write, &emulate, level, gfn, pfn,\n\t\t\t\t     prefault, map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n//mmu page不在位的情况，也就是缺页\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n//获取指向的具体mmu page entry的index\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n//获取mmu page\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1,\n\t\t\t\t\t      1, ACC_ALL, iterator.sptep);\n//将当前的mmu page的地址写入到上一级别mmu page的pte中\n\t\t\tlink_shadow_page(iterator.sptep, sp, true);\n\t\t}\n\t}\n\treturn emulate;\n}\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access,\n\t\t\t\t\t     u64 *parent_pte)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n//根据一个hash索引来的\n\tfor_each_gfn_sp(vcpu->kvm, sp, gfn) {\n//检查整个mmu ept是否被失效了\n\t\tif (is_obsolete_sp(vcpu->kvm, sp))\n\t\t\tcontinue;\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync && kvm_sync_page_transient(vcpu, sp))\n\t\t\tbreak;\n\n\t\tmmu_page_add_parent_pte(vcpu, sp, parent_pte);\n\t\tif (sp->unsync_children) {\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\tkvm_mmu_mark_parents_unsync(sp);\n\t\t} else if (sp->unsync)\n\t\t\tkvm_mmu_mark_parents_unsync(sp);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\tsp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);\n\tif (!sp)\n\t\treturn sp;\n\tsp->gfn = gfn;\n\tsp->role = role;\n//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有\n//被分配\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\tif (rmap_write_protect(vcpu->kvm, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tkvm_sync_pages(vcpu, gfn);\n\n\t\taccount_shadowed(vcpu->kvm, gfn);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tinit_shadow_page_table(sp);\n\ttrace_kvm_mmu_get_page(sp, true);\n\treturn sp;\n}\n</pre>\n\n这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。\n","slug":"kvm-src-4-mem","published":1,"updated":"2018-12-11T03:27:01.008Z","_id":"cjpj6h7e600064po43lc93c9a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>代码版本：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v3.16.37</p>\n<p>在虚拟机的创建与运行中pc_init_pci负责(“KVM源代码分析2:虚拟机的创建与运行”)，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。</p>\n<p>插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedefstruct RAMBlock {\n//对应宿主的内存地址\n    uint8_t *host;\n//block在ramlist中的偏移\n    ram_addr_t offset;\n//block长度\n    ram_addr_t length;\n    uint32_t flags;\n//block名字\n    char idstr[256];\n    QLIST_ENTRY(RAMBlock) next;\n\\#if defined(__linux__) && !defined(TARGET_S390X)\n    int fd;\n\\#endif\n} RAMBlock;\n\ntypedef struct RAMList {\n//看代码理解就是list的head，但是不知道为啥叫dirty...\n    uint8_t *phys_dirty;\n    QLIST_HEAD(ram, RAMBlock) blocks;\n} RAMList;\n</pre>\n\n<p>下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在”KVM源代码分析2:虚拟机的创建与运行”，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid \\*qemu_memalign(size_t alignment, size_t size){\n    void *ptr;\n//使用posix进行内存针对页大小对齐\n\\#if defined(_POSIX_C_SOURCE) && !defined(__sun__)\n    int ret;\n    ret = posix_memalign(&ptr, alignment, size);\n    if (ret != 0) {\n        fprintf(stderr, \"Failed to allocate %zu B: %sn\",\n                size, strerror(ret));\n        abort();\n    }\n\\#elif defined(CONFIG_BSD)\n    ptr = qemu_oom_check(valloc(size));\n\\#else\n//所谓检查oom就是看memalign对应malloc申请内存是否成功\n    ptr = qemu_oom_check(memalign(alignment, size));\n\\#endif\n    trace_qemu_memalign(alignment, size, ptr);\n    return ptr;\n}\n</pre>\n\n<p>以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。<br>然后一层层的退回到pc_memory_init函数。</p>\n<p>此时pc.ram已经分配完成，ram_addr已经拿到了<a href=\"http://www.oenhan.com/kernel-program-exec\" title=\"从一次内存泄露看程序在内核中的执行过程\" target=\"_blank\" rel=\"noopener\">分配的内存</a>地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_userspace_memory_region {\n__u32 slot;\n__u32 flags;\n__u64 guest_phys_addr;\n__u64 memory_size; /* bytes */\n__u64 userspace_addr; /* start of the userspace allocated memory */\n};\n</pre>\n\n<p>kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到<strong>kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE - 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void </strong>user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。<br>id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm “KVM源代码分析2:虚拟机的创建与运行”中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。<br>扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：</p>\n<pre class=\"lang:c decode:1 hljs cs\">\n//映射内存有大小，不是删除内存条if (npages) {\n//内存槽号没有虚拟内存条，意味内存新创建if (!old.npages)\n        change = KVM_MR_CREATE;\n    else { /* Modify an existing slot. */\n//修改已存在的内存修改标志或者平移映射地址\n//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）\n        if ((mem->userspace_addr != old.userspace_addr) ||\n            (npages != old.npages) ||\n            ((new.flags ^ old.flags) & KVM_MEM_READONLY))\n            goto out;\n//guest地址不同，内存条平移\n        if (base_gfn != old.base_gfn)\n            change = KVM_MR_MOVE;\n        else if (new.flags != old.flags)\n//修改属性\n            change = KVM_MR_FLAGS_ONLY;\n        else { /* Nothing to change. */\n            r = 0;\n            goto out;\n        }\n    }\n} else if (old.npages) {\n//申请插入的内存为0，而内存槽上有内存，意味删除\n    change = KVM_MR_DELETE;\n} else /* Modify a non-existent slot: disallowed. */\n    goto out;\n</pre>\n\n<p>另外看kvm_mr_change就知道memslot的变动值了：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nenum kvm_mr_change {\n    KVM_MR_CREATE,\n    KVM_MR_DELETE,\n    KVM_MR_MOVE,\n    KVM_MR_FLAGS_ONLY,\n};\n</pre>\n\n<p>在往下是一段检查</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {\n    /* Check for overlaps */\n    r = -EEXIST;\n    kvm_for_each_memslot(slot, kvm->memslots) {\n        if ((slot->id >= KVM_USER_MEM_SLOTS) ||\n//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的\n            (slot->id == mem->slot))\n            continue;\n//下面就是当前已有的slot与new在guest线性区间上有交集\n        if (!((base_gfn + npages <= slot-=\"\">base_gfn) ||\n              (base_gfn >= slot->base_gfn + slot->npages)))\n            goto out;\n//out错误码就是EEXIST\n    }\n}\n</=></pre>\n\n<p>如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages - 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;0<em>9,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;1</em>9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。<br>如果有脏页,并且脏页位图为空,则分配<a href=\"http://www.oenhan.com/linux-cache-writeback\" target=\"_blank\" rel=\"noopener\">脏页位图</a>, kvm_create_dirty_bitmap实际就是”页数/8”.</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n        if (kvm_create_dirty_bitmap(&new) < 0)\n            goto out_free;\n    }\n</pre>\n\n<p>当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。</p>\n<p>内存的添加说完了，看一下<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">EPT页表</a>的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。</p>\n<pre class=\"hljs php\">\ncontext->page_fault = tdp_page_fault;\ncontext->sync_page = nonpaging_sync_page;\ncontext->invlpg = nonpaging_invlpg;\ncontext->update_pte = nonpaging_update_pte;\ncontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\ncontext->root_hpa = INVALID_PAGE;\ncontext->direct_map = true;\ncontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\ncontext->get_cr3 = get_cr3;\ncontext->get_pdptr = kvm_pdptr_read;\ncontext->inject_page_fault = kvm_inject_page_fault;\n</pre>\n\n<p>当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。</p>\n<pre class=\"hljs cpp\">\n//填充kvm mmu专用的slab\nr = mmu_topup_memory_caches(vcpu);\n//获取gfn使用的level，即hugepage的问题\nforce_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);\nif (likely(!force_pt_level)) {\n    level = mapping_level(vcpu, gfn);\n    gfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n} else\n    level = PT_PAGE_TABLE_LEVEL;\n\n//顾名思义，快速处理一个简单的page fault\n//即present同时有写权限的非mmio page fault\n//参考page_fault_can_be_fast函数\n//一部分处理没有写权限的page fault\n//一部分处理 TLB lazy\n//fast_pf_fix_direct_spte也就是将pte获取的写权限\nif (fast_page_fault(vcpu, gpa, level, error_code))\n    return 0;\n//下面函数主要就一件事情，gfn_to_pfn\nif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n      return 0;\n//direct map就是映射ept页表的过程\nr = __direct_map(vcpu, gpa, write, map_writable,\n      level, gfn, pfn, prefault);\n</pre>\n\n<p>在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:</p>\n<pre class=\"hljs objectivec\">\nstatic pfn_t\n__gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,\n             bool *async, bool write_fault, bool *writable)\n{\n    unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n    if (addr == KVM_HVA_ERR_RO_BAD)\n        return KVM_PFN_ERR_RO_FAULT;\n\n    if (kvm_is_error_hva(addr))\n        return KVM_PFN_NOSLOT;\n\n    /* Do not map writable pfn in the readonly memslot. */\n    if (writable && memslot_is_readonly(slot)) {\n        *writable = false;\n        writable = NULL;\n    }\n\n    return hva_to_pfn(addr, atomic, async, write_fault,\n              writable);\n}\n</pre>\n\n<p>gfn2hva本质就是</p>\n<pre class=\"hljs cpp\">\nstaticinline unsigned long\n__gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n    return slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE;\n}\n</pre>\n\n<p>而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。</p>\n<pre class=\"hljs php\">\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,\n            int map_writable, int level, gfn_t gfn, pfn_t pfn,\n            bool prefault)\n{\n    struct kvm_shadow_walk_iterator iterator;\n    struct kvm_mmu_page *sp;\n    int emulate = 0;\n    gfn_t pseudo_gfn;\n\n    if (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n        return0;\n//遍历ept四级页表\n    for_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n//如果是最后一级，level是hugepage下的level\n        if (iterator.level == level) {\n//设置pte，页表下一级的page地址就是pfn写入到pte\n            mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n                     write, &emulate, level, gfn, pfn,\n                     prefault, map_writable);\n            direct_pte_prefetch(vcpu, iterator.sptep);\n            ++vcpu->stat.pf_fixed;\n            break;\n        }\n\n        drop_large_spte(vcpu, iterator.sptep);\n//mmu page不在位的情况，也就是缺页\n        if (!is_shadow_present_pte(*iterator.sptep)) {\n            u64 base_addr = iterator.addr;\n//获取指向的具体mmu page entry的index\n            base_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n            pseudo_gfn = base_addr >> PAGE_SHIFT;\n//获取mmu page\n            sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n                          iterator.level - 1,\n                          1, ACC_ALL, iterator.sptep);\n//将当前的mmu page的地址写入到上一级别mmu page的pte中\n            link_shadow_page(iterator.sptep, sp, true);\n        }\n    }\n    return emulate;\n}\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n                         gfn_t gfn,\n                         gva_t gaddr,\n                         unsigned level,\n                         int direct,\n                         unsigned access,\n                         u64 *parent_pte)\n{\n    union kvm_mmu_page_role role;\n    unsigned quadrant;\n    struct kvm_mmu_page *sp;\n    bool need_sync = false;\n\n    role = vcpu->arch.mmu.base_role;\n    role.level = level;\n    role.direct = direct;\n    if (role.direct)\n        role.cr4_pae = 0;\n    role.access = access;\n    if (!vcpu->arch.mmu.direct_map\n        && vcpu->arch.mmu.root_level <= pt32_root_level)=\"\" {=\"\" quadrant=\"gaddr\">> (PAGE_SHIFT + (PT64_PT_BITS * level));\n        quadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n        role.quadrant = quadrant;\n    }\n//根据一个hash索引来的\n    for_each_gfn_sp(vcpu->kvm, sp, gfn) {\n//检查整个mmu ept是否被失效了\n        if (is_obsolete_sp(vcpu->kvm, sp))\n            continue;\n\n        if (!need_sync && sp->unsync)\n            need_sync = true;\n\n        if (sp->role.word != role.word)\n            continue;\n\n        if (sp->unsync && kvm_sync_page_transient(vcpu, sp))\n            break;\n\n        mmu_page_add_parent_pte(vcpu, sp, parent_pte);\n        if (sp->unsync_children) {\n            kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n            kvm_mmu_mark_parents_unsync(sp);\n        } else if (sp->unsync)\n            kvm_mmu_mark_parents_unsync(sp);\n\n        __clear_sp_write_flooding_count(sp);\n        trace_kvm_mmu_get_page(sp, false);\n        return sp;\n    }\n    ++vcpu->kvm->stat.mmu_cache_miss;\n    sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);\n    if (!sp)\n        return sp;\n    sp->gfn = gfn;\n    sp->role = role;\n//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有\n//被分配\n    hlist_add_head(&sp->hash_link,\n        &vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n    if (!direct) {\n        if (rmap_write_protect(vcpu->kvm, gfn))\n            kvm_flush_remote_tlbs(vcpu->kvm);\n        if (level > PT_PAGE_TABLE_LEVEL && need_sync)\n            kvm_sync_pages(vcpu, gfn);\n\n        account_shadowed(vcpu->kvm, gfn);\n    }\n    sp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n    init_shadow_page_table(sp);\n    trace_kvm_mmu_get_page(sp, true);\n    return sp;\n}\n</=></pre>\n\n<p>这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>代码版本：<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v3.16.37</p>\n<p>在虚拟机的创建与运行中pc_init_pci负责(“KVM源代码分析2:虚拟机的创建与运行”)，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。</p>\n<p>插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\ntypedefstruct RAMBlock {\n//对应宿主的内存地址\n    uint8_t *host;\n//block在ramlist中的偏移\n    ram_addr_t offset;\n//block长度\n    ram_addr_t length;\n    uint32_t flags;\n//block名字\n    char idstr[256];\n    QLIST_ENTRY(RAMBlock) next;\n\\#if defined(__linux__) && !defined(TARGET_S390X)\n    int fd;\n\\#endif\n} RAMBlock;\n\ntypedef struct RAMList {\n//看代码理解就是list的head，但是不知道为啥叫dirty...\n    uint8_t *phys_dirty;\n    QLIST_HEAD(ram, RAMBlock) blocks;\n} RAMList;\n</pre>\n\n<p>下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在”KVM源代码分析2:虚拟机的创建与运行”，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nvoid \\*qemu_memalign(size_t alignment, size_t size){\n    void *ptr;\n//使用posix进行内存针对页大小对齐\n\\#if defined(_POSIX_C_SOURCE) && !defined(__sun__)\n    int ret;\n    ret = posix_memalign(&ptr, alignment, size);\n    if (ret != 0) {\n        fprintf(stderr, \"Failed to allocate %zu B: %sn\",\n                size, strerror(ret));\n        abort();\n    }\n\\#elif defined(CONFIG_BSD)\n    ptr = qemu_oom_check(valloc(size));\n\\#else\n//所谓检查oom就是看memalign对应malloc申请内存是否成功\n    ptr = qemu_oom_check(memalign(alignment, size));\n\\#endif\n    trace_qemu_memalign(alignment, size, ptr);\n    return ptr;\n}\n</pre>\n\n<p>以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。<br>然后一层层的退回到pc_memory_init函数。</p>\n<p>此时pc.ram已经分配完成，ram_addr已经拿到了<a href=\"http://www.oenhan.com/kernel-program-exec\" title=\"从一次内存泄露看程序在内核中的执行过程\" target=\"_blank\" rel=\"noopener\">分配的内存</a>地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nstruct kvm_userspace_memory_region {\n__u32 slot;\n__u32 flags;\n__u64 guest_phys_addr;\n__u64 memory_size; /* bytes */\n__u64 userspace_addr; /* start of the userspace allocated memory */\n};\n</pre>\n\n<p>kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到<strong>kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE - 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void </strong>user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。<br>id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm “KVM源代码分析2:虚拟机的创建与运行”中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。<br>扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：</p>\n<pre class=\"lang:c decode:1 hljs cs\">\n//映射内存有大小，不是删除内存条if (npages) {\n//内存槽号没有虚拟内存条，意味内存新创建if (!old.npages)\n        change = KVM_MR_CREATE;\n    else { /* Modify an existing slot. */\n//修改已存在的内存修改标志或者平移映射地址\n//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）\n        if ((mem->userspace_addr != old.userspace_addr) ||\n            (npages != old.npages) ||\n            ((new.flags ^ old.flags) & KVM_MEM_READONLY))\n            goto out;\n//guest地址不同，内存条平移\n        if (base_gfn != old.base_gfn)\n            change = KVM_MR_MOVE;\n        else if (new.flags != old.flags)\n//修改属性\n            change = KVM_MR_FLAGS_ONLY;\n        else { /* Nothing to change. */\n            r = 0;\n            goto out;\n        }\n    }\n} else if (old.npages) {\n//申请插入的内存为0，而内存槽上有内存，意味删除\n    change = KVM_MR_DELETE;\n} else /* Modify a non-existent slot: disallowed. */\n    goto out;\n</pre>\n\n<p>另外看kvm_mr_change就知道memslot的变动值了：</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nenum kvm_mr_change {\n    KVM_MR_CREATE,\n    KVM_MR_DELETE,\n    KVM_MR_MOVE,\n    KVM_MR_FLAGS_ONLY,\n};\n</pre>\n\n<p>在往下是一段检查</p>\n<pre class=\"lang:c decode:1 hljs php\">\nif ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {\n    /* Check for overlaps */\n    r = -EEXIST;\n    kvm_for_each_memslot(slot, kvm->memslots) {\n        if ((slot->id >= KVM_USER_MEM_SLOTS) ||\n//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的\n            (slot->id == mem->slot))\n            continue;\n//下面就是当前已有的slot与new在guest线性区间上有交集\n        if (!((base_gfn + npages <= slot-=\"\">base_gfn) ||\n              (base_gfn >= slot->base_gfn + slot->npages)))\n            goto out;\n//out错误码就是EEXIST\n    }\n}\n</=></pre>\n\n<p>如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages - 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;0<em>9,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;1</em>9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。<br>如果有脏页,并且脏页位图为空,则分配<a href=\"http://www.oenhan.com/linux-cache-writeback\" target=\"_blank\" rel=\"noopener\">脏页位图</a>, kvm_create_dirty_bitmap实际就是”页数/8”.</p>\n<pre class=\"lang:c decode:1 hljs cpp\">\nif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n        if (kvm_create_dirty_bitmap(&new) < 0)\n            goto out_free;\n    }\n</pre>\n\n<p>当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。</p>\n<p>内存的添加说完了，看一下<a href=\"http://www.oenhan.com/kernel-program-exec\" target=\"_blank\" rel=\"noopener\">EPT页表</a>的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。</p>\n<pre class=\"hljs php\">\ncontext->page_fault = tdp_page_fault;\ncontext->sync_page = nonpaging_sync_page;\ncontext->invlpg = nonpaging_invlpg;\ncontext->update_pte = nonpaging_update_pte;\ncontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\ncontext->root_hpa = INVALID_PAGE;\ncontext->direct_map = true;\ncontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\ncontext->get_cr3 = get_cr3;\ncontext->get_pdptr = kvm_pdptr_read;\ncontext->inject_page_fault = kvm_inject_page_fault;\n</pre>\n\n<p>当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。</p>\n<pre class=\"hljs cpp\">\n//填充kvm mmu专用的slab\nr = mmu_topup_memory_caches(vcpu);\n//获取gfn使用的level，即hugepage的问题\nforce_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);\nif (likely(!force_pt_level)) {\n    level = mapping_level(vcpu, gfn);\n    gfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n} else\n    level = PT_PAGE_TABLE_LEVEL;\n\n//顾名思义，快速处理一个简单的page fault\n//即present同时有写权限的非mmio page fault\n//参考page_fault_can_be_fast函数\n//一部分处理没有写权限的page fault\n//一部分处理 TLB lazy\n//fast_pf_fix_direct_spte也就是将pte获取的写权限\nif (fast_page_fault(vcpu, gpa, level, error_code))\n    return 0;\n//下面函数主要就一件事情，gfn_to_pfn\nif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n      return 0;\n//direct map就是映射ept页表的过程\nr = __direct_map(vcpu, gpa, write, map_writable,\n      level, gfn, pfn, prefault);\n</pre>\n\n<p>在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:</p>\n<pre class=\"hljs objectivec\">\nstatic pfn_t\n__gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,\n             bool *async, bool write_fault, bool *writable)\n{\n    unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n    if (addr == KVM_HVA_ERR_RO_BAD)\n        return KVM_PFN_ERR_RO_FAULT;\n\n    if (kvm_is_error_hva(addr))\n        return KVM_PFN_NOSLOT;\n\n    /* Do not map writable pfn in the readonly memslot. */\n    if (writable && memslot_is_readonly(slot)) {\n        *writable = false;\n        writable = NULL;\n    }\n\n    return hva_to_pfn(addr, atomic, async, write_fault,\n              writable);\n}\n</pre>\n\n<p>gfn2hva本质就是</p>\n<pre class=\"hljs cpp\">\nstaticinline unsigned long\n__gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n    return slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE;\n}\n</pre>\n\n<p>而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。</p>\n<pre class=\"hljs php\">\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,\n            int map_writable, int level, gfn_t gfn, pfn_t pfn,\n            bool prefault)\n{\n    struct kvm_shadow_walk_iterator iterator;\n    struct kvm_mmu_page *sp;\n    int emulate = 0;\n    gfn_t pseudo_gfn;\n\n    if (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n        return0;\n//遍历ept四级页表\n    for_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n//如果是最后一级，level是hugepage下的level\n        if (iterator.level == level) {\n//设置pte，页表下一级的page地址就是pfn写入到pte\n            mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n                     write, &emulate, level, gfn, pfn,\n                     prefault, map_writable);\n            direct_pte_prefetch(vcpu, iterator.sptep);\n            ++vcpu->stat.pf_fixed;\n            break;\n        }\n\n        drop_large_spte(vcpu, iterator.sptep);\n//mmu page不在位的情况，也就是缺页\n        if (!is_shadow_present_pte(*iterator.sptep)) {\n            u64 base_addr = iterator.addr;\n//获取指向的具体mmu page entry的index\n            base_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n            pseudo_gfn = base_addr >> PAGE_SHIFT;\n//获取mmu page\n            sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n                          iterator.level - 1,\n                          1, ACC_ALL, iterator.sptep);\n//将当前的mmu page的地址写入到上一级别mmu page的pte中\n            link_shadow_page(iterator.sptep, sp, true);\n        }\n    }\n    return emulate;\n}\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n                         gfn_t gfn,\n                         gva_t gaddr,\n                         unsigned level,\n                         int direct,\n                         unsigned access,\n                         u64 *parent_pte)\n{\n    union kvm_mmu_page_role role;\n    unsigned quadrant;\n    struct kvm_mmu_page *sp;\n    bool need_sync = false;\n\n    role = vcpu->arch.mmu.base_role;\n    role.level = level;\n    role.direct = direct;\n    if (role.direct)\n        role.cr4_pae = 0;\n    role.access = access;\n    if (!vcpu->arch.mmu.direct_map\n        && vcpu->arch.mmu.root_level <= pt32_root_level)=\"\" {=\"\" quadrant=\"gaddr\">> (PAGE_SHIFT + (PT64_PT_BITS * level));\n        quadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n        role.quadrant = quadrant;\n    }\n//根据一个hash索引来的\n    for_each_gfn_sp(vcpu->kvm, sp, gfn) {\n//检查整个mmu ept是否被失效了\n        if (is_obsolete_sp(vcpu->kvm, sp))\n            continue;\n\n        if (!need_sync && sp->unsync)\n            need_sync = true;\n\n        if (sp->role.word != role.word)\n            continue;\n\n        if (sp->unsync && kvm_sync_page_transient(vcpu, sp))\n            break;\n\n        mmu_page_add_parent_pte(vcpu, sp, parent_pte);\n        if (sp->unsync_children) {\n            kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n            kvm_mmu_mark_parents_unsync(sp);\n        } else if (sp->unsync)\n            kvm_mmu_mark_parents_unsync(sp);\n\n        __clear_sp_write_flooding_count(sp);\n        trace_kvm_mmu_get_page(sp, false);\n        return sp;\n    }\n    ++vcpu->kvm->stat.mmu_cache_miss;\n    sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);\n    if (!sp)\n        return sp;\n    sp->gfn = gfn;\n    sp->role = role;\n//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有\n//被分配\n    hlist_add_head(&sp->hash_link,\n        &vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n    if (!direct) {\n        if (rmap_write_protect(vcpu->kvm, gfn))\n            kvm_flush_remote_tlbs(vcpu->kvm);\n        if (level > PT_PAGE_TABLE_LEVEL && need_sync)\n            kvm_sync_pages(vcpu, gfn);\n\n        account_shadowed(vcpu->kvm, gfn);\n    }\n    sp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n    init_shadow_page_table(sp);\n    trace_kvm_mmu_get_page(sp, true);\n    return sp;\n}\n</=></pre>\n\n<p>这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/kvm-cpu/vcpu-ring.png","slug":"vcpu-ring.png","post":"cjpj2qxl20006y0o4x7l2g2zg","modified":0,"renderable":0},{"_id":"source/_posts/kvm-overview/01_brief.png","slug":"01_brief.png","post":"cjpj2qxl50008y0o4k9kcizvb","modified":0,"renderable":0},{"_id":"source/_posts/kvm-overview/02_kvm_framework.png","slug":"02_kvm_framework.png","post":"cjpj2qxl50008y0o4k9kcizvb","modified":0,"renderable":0},{"_id":"source/_posts/kvm-cpu/vcpu-follow.png","slug":"vcpu-follow.png","post":"cjpj2qxl20006y0o4x7l2g2zg","modified":0,"renderable":0},{"_id":"source/_posts/kvm-cpu/vmm_guest_switch.png","slug":"vmm_guest_switch.png","post":"cjpj2qxl20006y0o4x7l2g2zg","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-1/hypervisor-1.png","slug":"hypervisor-1.png","post":"cjpj2qxl9000dy0o4a5wekojb","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-1/kvm_arch_map-1.png","slug":"kvm_arch_map-1.png","post":"cjpj2qxl9000dy0o4a5wekojb","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-1/kvm_process-1.png","slug":"kvm_process-1.png","post":"cjpj2qxl9000dy0o4a5wekojb","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa.png","slug":"gpa_hpa.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa2.png","slug":"gpa_hpa2.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa3_shadow.png","slug":"gpa_hpa3_shadow.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa4.png","slug":"gpa_hpa4.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/gpa_hpa5_ept.png","slug":"gpa_hpa5_ept.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/logical_address.png","slug":"logical_address.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-memory/page.png","slug":"page.png","post":"cjpj2qxl60009y0o49ykpqr1t","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_create_kvm_vm-1.png","slug":"qemu_create_kvm_vm-1.png","post":"cjpj2ui2v0000ydo4ap3hu06u","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_module_init-1.png","slug":"qemu_module_init-1.png","post":"cjpj2ui2v0000ydo4ap3hu06u","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-2-vm-run/qemu_memory_module-1.bmp","slug":"qemu_memory_module-1.bmp","post":"cjpj2ui2v0000ydo4ap3hu06u","modified":0,"renderable":0},{"_id":"source/_posts/kvm-src-3-cpu/kvm_vmx_intel-1.jpg","slug":"kvm_vmx_intel-1.jpg","post":"cjpj4usjw000979o4vikassxr","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjpj2qxl10004y0o4ettba52g","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj2qxlb000gy0o4agkz6g9h"},{"post_id":"cjpj2qxl50008y0o4k9kcizvb","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj2qxlb000iy0o4vlok3dvl"},{"post_id":"cjpj2qxl7000by0o4ixvghs3b","category_id":"cjpj2qxlb000fy0o4litygjf7","_id":"cjpj2qxlc000ky0o4c3avb9p2"},{"post_id":"cjpj2ui2v0000ydo4ap3hu06u","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj4mm05000179o4ttwkky3u"},{"post_id":"cjpj2qxl9000dy0o4a5wekojb","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj4n8zd000379o4401ut0n0"},{"post_id":"cjpj2qxl60009y0o49ykpqr1t","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj4orp7000579o49i8p2jkn"},{"post_id":"cjpj2qxl20006y0o4x7l2g2zg","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj4p6dw000779o419xwplhc"},{"post_id":"cjpj4usjw000979o4vikassxr","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj4x09g000b79o4c3rdrewa"},{"post_id":"cjpj6h7e600064po43lc93c9a","category_id":"cjpj2qxl30007y0o4r7kiziq7","_id":"cjpj6h7e600084po4m4x5an6a"}],"PostTag":[{"post_id":"cjpj2qxl50008y0o4k9kcizvb","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj2qxlb000hy0o48ay9yu5h"},{"post_id":"cjpj2qxl7000by0o4ixvghs3b","tag_id":"cjpj2qxla000ey0o4yn7q1otx","_id":"cjpj2qxlc000ly0o47amgy0u3"},{"post_id":"cjpj2qxl7000by0o4ixvghs3b","tag_id":"cjpj2qxlb000jy0o4wsky72gl","_id":"cjpj2qxlc000my0o4w8ik881p"},{"post_id":"cjpj2ui2v0000ydo4ap3hu06u","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4mlqz000079o4neb57u7p"},{"post_id":"cjpj2qxl9000dy0o4a5wekojb","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4n8zd000279o4cl636eqt"},{"post_id":"cjpj2qxl60009y0o49ykpqr1t","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4orp7000479o495a1wah5"},{"post_id":"cjpj2qxl20006y0o4x7l2g2zg","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4p6dw000679o4nj0ljaut"},{"post_id":"cjpj2qxl10004y0o4ettba52g","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4s98f000879o493k2tjsn"},{"post_id":"cjpj4usjw000979o4vikassxr","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj4x09f000a79o4mfia4nbn"},{"post_id":"cjpj6h7e600064po43lc93c9a","tag_id":"cjpj2qxl7000ay0o4u6s445tv","_id":"cjpj6h7e600074po4d7i6r0m5"}],"Tag":[{"name":"KVM","_id":"cjpj2qxl7000ay0o4u6s445tv"},{"name":"QEMU","_id":"cjpj2qxla000ey0o4yn7q1otx"},{"name":"QMP","_id":"cjpj2qxlb000jy0o4wsky72gl"}]}}
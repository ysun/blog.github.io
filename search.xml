<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由浅入深CrosVM（三）—— 虚拟机的网络配置]]></title>
    <url>%2F2020%2F04%2F07%2Fcrosvm-network%2F</url>
    <content type="text"><![CDATA[所有虚拟机都面临的问题——网络访问。关于虚拟机的网络模型在前文 QEMU虚拟机网络模拟已经有过详细的描述。基于上篇文章，这里简要说明下如何在CrosVM的虚拟机中使用网络。 NAT模式网络拓扑结构参照QEMU虚拟机网络模拟配置很简单，在启动虚拟机的时候，增加三个参数--host_ip --netmask --mac:123456789./crosvm run --disable-sandbox \ --cpus 4 --mem 4096 \ --rwdisk=ubuntu-rootfs.img \ --params=root=/dev/vda \ --gpu --x-display :0 \ --socket=crosvm.sock \ --evdev /dev/input/event18 --evdev /dev/input/event19 \ --host_ip 192.168.0.1 --netmask 255.255.255.0 --mac AA:BB:CC:00:00:12 \ vmlinux-5.4.18 这样crosvm会在host中创建一个虚拟网卡，IP地址，子网掩码以及Mac地址都是参数给定的样子:12345678vmtap0: flags=67&lt;UP,BROADCAST,RUNNING&gt; mtu 1500 inet 192.168.0.1 netmask 255.255.255.0 broadcast 192.168.0.255 inet6 fe80::a8bb:ccff:fe00:12 prefixlen 64 scopeid 0x20&lt;link&gt; ether aa:bb:cc:00:00:12 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 然后登录虚拟机之后，给虚拟机中的网卡配置同网段的IP之后，就可以相互访问了:1ifconfig eth0 192.168.0.22 netmask 255.255.255.0 Bridge模式这方法跟”QEMU虚拟机网络模拟”中描述的Bridge思路一致，甚至方法都一样:首先在host中创建一个bridge: 1234ip link add br0 type bridgeip link set eth0 master br0ip link set dev br0 up dhclient br0 然后启动VM的时候，同样加上上述三个参数--host_ip --netmask --mac用于创建vmtap0和虚拟机中的virtio network设备。 当虚拟机启动起来之后，需要在Host中，把vmtap0绑定到br0上12ip link set vmtap0 master br0ip link set vmtap0 up 最后，回到虚拟机中动态获得IP1dhclient 虚拟机就可以获得跟Host同一网段的IP地址了。]]></content>
      <categories>
        <category>ChromeOS</category>
      </categories>
      <tags>
        <tag>ChromeOS CrosVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由浅入深CrosVM（二）—— 如何在虚拟机中使用3D加速(借助Virgil 3D项目)]]></title>
    <url>%2F2020%2F04%2F03%2Fcrosvm-virtio-gpu%2F</url>
    <content type="text"><![CDATA[什么是Virgil 3d项目Virgil是Dave Airlie(from Red Hat)的一个研究项目。该项目在虚拟机中创建一个虚拟GPU，通过它允许虚拟机操作系统(Guest OS)使用物理机(宿主机，Host)的物理GPU来加速3D渲染。让用户感觉拥有一个完全独立于主机的虚拟机GPU。 该虚拟显卡的设计基于Gallium3D，使用Gallium TGSI中间件作为着色器。虚拟显卡的渲染实现是在主机系统中作为qemu、crosvm等VMM(virtual machine manager)的一部分完成的。目前支持OpenGL(4.3)和OpenGL ES (3.2)，并且需要SDL支持。可以在任何支持的显卡/驱动程序上加速渲染。 该项目还包含一个完整的Linux虚拟机技术栈，包括Linux内核KMS驱动程序(DRM/i915)，X.org(2D DDX驱动程序)和Mesa(3D驱动程序)组成。 现在，所有组件都已经集成到了各个项目中: Linux 内核4.4开始，包含3D支持的部分。 Mesa master分支包含virgl 3D驱动程序。 QEMU 2.5开始包含virtio-gpu，以及支持GL的GTK3前端。 virglrenderer库已经可以提供QEMU或者CrosVM所需要的API。 未来的功能以及缺点： 通过编解码实现远程渲染(rendering)暂不支持。 Windows Guest以及Direct 3D暂不支持。 不支持Passing through GPU给guest。 参考: Virgil 3D GPU project 开始搭建环境有了上面的virgl技术栈的图，事情变得清晰多了：在Host端安装virglrenderer，安装最新的Mesa、和Linux Kernel。 编译安装virglrenderer12345678910111213141516apt install python3-pippip3 install meson# 安装依赖apt install libgbm-dev mesa-utils llvm llvm-9-dev libpciaccess-dev wayland-protocols libwayland-egl-backend-devgit clone https://github.com/anholt/libepoxy.gitcd libepoxymkdir build &amp;&amp; cd build &amp;&amp; meson .. &amp;&amp; meson install &amp;&amp; cd ..git clone https://gitlab.freedesktop.org/virgl/virglrenderer.gitmkdir build &amp;&amp; cd build &amp;&amp; meson .. &amp;&amp; meson install &amp;&amp; cd ..git clone https://gitlab.freedesktop.org/mesa/drm.gitcd drmmkdir build &amp;&amp; meson build/ &amp;&amp; ninja -C build install 确认Mesa 支持1# glxinfo |grep renderer 如果renderer string使用 llvmpipe，说明Mesa不支持:1OpenGL renderer string: llvmpipe (LLVM 5.0, 256 bits) 如果renderer string使用 Intel，说明3D驱动安装正确:1OpenGL renderer string: Mesa DRI Intel(R) HD Graphics 620 (Kaby Lake GT2) 如果当前Mesa不支持的话，请参考Mesa的官网，编译安装Mesa 重新编译安装CrosVM加上参数--features=gpu,x1234cargo build --features=gpu,x #BTW, 如果需要图形加速，需要打开gpu和xmkdir -p /usr/share/policy/crosvm/ #这里面是CrosVM运行时的一些policy配置cp -r src/platform/crosvm/seccomp/x86_64/* /usr/share/policy/crosvm/ 创建虚拟机Host启动X(xinit)，或者桌面环境。加上参数-gpu --x-display :012345678crosvm run --disable-sandbox \ --cpus 4 --mem 4096 \ --rwdisk=ubuntu-rootfs.img \ --params=root=/dev/vda \ --gpu --x-display :0 \ --socket=crosvm.sock \ --evdev /dev/input/event18 --evdev /dev/input/event19 \ vmlinux-5.4.18 参数说明: –disable-sandbox: 如果上一篇文章里面的minijail已经正确安装，可以省略这个参数，大概是为了安全性，不详述了吧，因为——不懂~！ –cpus 4 –mem 4096: vCPU数目和虚拟内存大小4096M –rwdisk=ubuntu-rootfs.img: 虚拟机镜像。可以使用上一篇文章中的方法，使用debootstrap生成一个rootfs镜像；CrosVM同样支持带有分区信息虚拟机镜像，可以直接使用QEMU虚拟机的Raw或者Qcow2类型的镜像，没有压力。 –gpu –x-display :0 : 开起GPU以及X显示支持，这个参数是全篇的”精髓”，上面安装一大堆的库，就为了这两个参数。 –socket=crosvm.sock : socket用于控制CrosVM以及通信。 –evdev /dev/input/event18 : Passthrough 鼠标和键盘给虚拟机，需要额接一套键鼠。不过后面想尽量可以专门讲一期外设吧，尽量……。 vmlinux-5.4.18 : 虚拟机内核，ELF 64-bit LSB executable格式的，就是编译完kernel之后，在源码根目录生成的那个静态链接的内核文件(statically linked)。注: 为了方便，建议将所有用到的内核模块(module)都配置成built-in (y)而不是m。否则，需要一个initramfs，通过(-i)参数传递给crosvm，而且initrd的大小有限制，比较麻烦。 Guest启动X(xinit)，执行3D程序。同样可以使用glxinfo来确认3D驱动是否安装正确123# glxinfo |grep rendererOpenGL renderer string: virgl 如果renderer string是virgl，说明guest里的3D环境已经ready了。Have Fun!]]></content>
      <categories>
        <category>ChromeOS</category>
      </categories>
      <tags>
        <tag>ChromeOS crosvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由浅入深CrosVM（一）—— 如何在Ubuntu中搭建CrosVM]]></title>
    <url>%2F2020%2F03%2F30%2Fcrosvm-setup%2F</url>
    <content type="text"><![CDATA[什么是CrosVMCrosVM是Chrome操作系统中，用于创建虚拟机的应用。是一个Rust编写的轻量级的虚拟机。亚马逊的Firecracker从crosvm开始。借助于CrosVM 用户可以很容易的在ChromeOS中运行Linux、Android以及Windows应用程序。 CrosVM 的源码是Google ChromeOS的一部分，但也可以独立编译使用。哎，还是那句话“不要问为什么连接打不开”。还好github.com有好多CrosVM的镜像，有需要的可以上去找下。本文，我们着重描述下如何在Ubuntu 19.10中使用CrosVM创建一个Linux 虚拟机。 环境准备安装minijail这个是CrosVM 打开feature ’sandbox‘时需要的，因为是默认打开的，这里就罗列一下。如果编译有问题，或者很费劲，可以在运行crosvm的时候加上’–disable-sandbox’ 参数即可。12345apt install build-essential libcap-dev libfdt-dev pkg-config pythongit clone https://android.googlesource.com/platform/external/minijailcd minijailmakemake install 或者，如有有cros_sdk的话，在~/trunk/src/aosp/external/minijail目录中执行cargo build同样可以编译得到库文件，然后可以复制到/usr/local/lib/下面就好。 编译安装CrosVM123456789mkdir crosvmcd crosvmrepo init -g crosvm -u https://chromium.googlesource.com/chromiumos/manifest.git --repo-url=https://chromium.googlesource.com/external/repo.gitrepo synccargo buildmkdir -p /usr/share/policy/crosvm/ #这里面是CrosVM运行时的一些policy配置cp -r src/platform/crosvm/seccomp/x86_64/* /usr/share/policy/crosvm/ 编译虚拟机的内核(Kernel)1git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git 这里是我自己配置的kernel config下载并并且改名字为 .config然后编译内核:12make olddefconfigmake -j8 在内核根目录中生成的vmlinux就是需要的内核文件了(ELF 64-bit LSB executable)。 准备虚拟镜像123456789101112131415# 创建一个空的image，大小是20Gdd if=/dev/zero of=ubuntu19.10_rootfs.img bs=1M count=20480方法2：qemu-img create -f raw ubuntu19.10_rootfs.img 20G# 格式化mkfs.ext4 ubuntu19.10_rootfs.imgmkdir rootfs/sudo mount ubuntu19.10_rootfs.img rootfs/# 下载Ubuntu 19.10文件系统(eoan)debootstrap --arch amd64 eoan rootfs/ http://archive.ubuntu.com/ubuntusudo umount rootfs/ 对镜像的一些修改：123456sudo mount ubuntu19.10_rootfs.img rootfs/# 去掉rootfs中的密码：vim /etc/passwdroot:x:0:0:root:/root:/bin/bash取掉 root: 后面的那个x 建议尝试启动VM之前，在rootfs中安装udev 和 systemd, 似乎debootstrap创建的rootfs并没有自带这两个tool，需要自己安装下，否则启动的时候会遇到问题。123456mount ubuntu19.10_rootfs.img rootfs/chroot rootfsapt install udev systemdexitumount rootfs 注: 如果有同学玩过Qemu，那么可以直接使用Qemu支持的raw或者qcow2格式的虚拟机镜像。 创建虚拟机1234sudo LD_LIBRARY_PATH=~/project/vm/minijail/ ./target/debug/crosvm run \ --rwroot ubuntu19.10_rootfs.img \ --seccomp-policy-dir=/usr/share/policy/crosvm/x86_64/ \ vmlinux 或者，CrosVM同样支持带有initrd的内核，如果编译内核有困难或者比较“懒”的同学，可以直接把Ubuntu或者其他Linux发行版的内核拿来用下，启动时可能会有少许问题，但或许可以起来尝鲜一下虚拟机:12345sudo LD_LIBRARY_PATH=~/project/vm/minijail/ ./target/debug/crosvm run \ --rwroot ubuntu19.10_rootfs.img \ --seccomp-policy-dir=/usr/share/policy/crosvm/x86_64/ \ -i /boot/initrd.img-4.13.0-46-generic \ /boot/vmlinuz-4.13.0-46-generic 运气好的话，在创建VM的终端里面，应该可以看到Kernel启动的log，最后停在登录提示符。输入root 并回车，就可以直接登录虚拟机了。]]></content>
      <categories>
        <category>ChromeOS</category>
      </categories>
      <tags>
        <tag>ChromeOS Crosvm KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新安装ChromeOS之后需要做的事情]]></title>
    <url>%2F2020%2F03%2F03%2Fchromeos-setup%2F</url>
    <content type="text"><![CDATA[最近“被迫”研究ChromeOS——这个东东在国内往实在是太痛苦了！！不管怎么样，把最近玩ChromeOS的过程记个流水账。防止自己遗忘，也给国内同样想玩ChromeOS的玩家提供点参考——国内可以搜到的东西实在是太少了。下面所有的步骤，都默认读者是可以无障碍访问互联网的，对于GFW这件事情，这篇文章基本上帮不上忙，因为我自己没有找到一个完美解决的办法。 安装ChromeOS从源码使用cros_sdk编译这个不多说了，再华丽的描述都不及Google的官方文档非常的详细。 Google partner账户另外，如果不想自己编译，可以选择下载Google的FE built 登录登录时须要有网络，或许是因为ChromeOS的bug，在登录时的网络窗口是无法设置代理的。还是那么那句话，没有办法解决网络的问题。 配置开始上面都是准备工作，这里我们正式开始配置ChromeBook了。 安装Linux Beta点“开始”(或许ChromeOS里左下角那个按钮不叫“开始”)，输入Linux 或者 Terminal 出现一个终端的图标，点它。这是ChromeOS会联网下载Guest的镜像或者是镜像里的容器。 大概过10分钟，就会弹出来一个类似Linux下terminal的窗口，可以输入命令了 ———— 这就是Linux 虚拟机，基于CrosVM的虚拟机。 安装Chromebrew使用CTRL+ALT+F2 切换到终端；或者打开浏览器 CTRL+ALT+T 输入shell 都可以通过终端操作ChromeOS。但此时你会惊讶的发现，其实啥装不了。官方的安装需要通过cros_sdk 来编译(emerge)和部署(deploy)，但这样不够灵活，也非常的慢。强烈推荐Chromebrew git 安装方法也很简单，切换到chronos用户，然后输入curl -Ls http://skycocker.github.io/chromebrew/然后等就好了。然后需要安装软件大概有：12crew install vimcrew install git 安装CroutonCrouton是Chrome下的一个choot，可以让用户在ChromeOS里安装Linux Distribution的文件系统，比如Ubuntu Debain 等，对于想在ChromeOS的Host环境里做点hack事情的玩家，还是很方便的！1234git clone https://github.com/dnschneid/crouton.git./installer/crouton # 查看help./installer/crouton -r help #列出所有的可以用的&apos;release&apos;./installer/crouton -t help #列出所有的可以用的&apos;target&apos; 通常我这样安装:注意，需要在桌面环境的shell里面运行，而不是CTRL+ALT+F2的VT！！1./installer/crouton -r buster -t xfce 然后就是等就好了 :) 中间会让输入一个常用用户名和密码，结束之后这样用：12enter-chroot #进入chroot环境startxfce4 #启动桌面 好了现在就看像使用Debian一样，使用Chromebook了。如果想要退出chroot的环境，使用快捷键 CTRL+ALT+SHIFT+F1，回到native的桌面 读写分区默认的ChromeOS的分区是只读的，这样给他重新挂载12mount -o remount,rw /mount -o remount,exec /mnt/stateful_partition/ 清空iptable规则1234iptables -Fiptables -P INPUT ACCEPTiptables -P OUTPUT ACCEPTiptables -P FORWARD ACCEPT 安装pip3crew install python3-pip 或者 python2-pip 安装paramiko – python的一个包pip3 install paramiko Chroot中 安装apitrace1234git clone https://github.com/apitrace/apitrace.gitsudo apt install libx11-dev automake gcc cmakecmake .make &amp;&amp; make install 总结至此，基本上，一个ChromeBook已经可以用起来了。如果谁还有那些新奇好玩的用法，欢迎留言 安装其他benchmarkglmark2source code: https://github.com/glmark2/glmark2.git Chroot 中编译：1234sudo apt install libx11-dev libjpeg-dev libpng*./waf configure --with-flavors x11-glsudo ./waf install VM 中编译：1234apt install libjpeg-dev pkg-config libpng* libdrm-dev libgbm-dev libwayland-client0 libudev-dev libx11-dev./waf configure --with-flavors x11-glsudo ./waf install 安装Steam目前基于Linux的游戏平台，可以说就只有Steam了。安装Steam的坑在于，Steam自己为了支持多数游戏运行，平台客户端软件只支持32bit。安装步骤： 安装32bit支持1234sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get dist-upgradesudo apt-get install libc-i386 下载Steam 安装包官方下载地址: https://store.steampowered.com/about/dpkg -i setup.deb]]></content>
      <categories>
        <category>ChromeOS</category>
      </categories>
      <tags>
        <tag>ChromeOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春城外来车辆管理系统]]></title>
    <url>%2F2020%2F02%2F27%2Fchuncheng-parking%2F</url>
    <content type="text"><![CDATA[许久没更新了，刚好由于新冠肺炎，让我有一段完整的时间可以学点新东西，然后顺手帮小区居委、业委、物业做了套关于外来车辆管理的小系统。把项目的来龙去脉、实现过程做个流水账，防止自己遗忘。 项目的由来（需求）几年前搬到春城，小区真如名字般美好，小区内部特有的商业街更是给日常生活增添了不少便利。但随之而来的问题也比较烦，就是外来车辆（包括业主访客、商业街工作人员、外来消费等等）让小区变的越来越拥挤，于是新的外来车辆管理规则成了当务之急。这里要感谢新来的居委孙书记，大刀阔斧的变革，到任几个月就制定了新的外来车辆规则以及定价规范，同时已经线上线下与业主以及商铺充分沟通讨论。为了配合新的外车收费规则，于是有了这个项目。 系统设计用户页面 注册申请、登录 1小时停车优惠券申请、直系亲属车优惠券申请 管理员页面 登录 用户申请订单的审批、打印 用户权限、信息显示、修改 技术选型前端 Ant-design To be continued…]]></content>
      <categories>
        <category>业余</category>
      </categories>
      <tags>
        <tag>ant-design antd TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QEMU虚拟机网络模拟]]></title>
    <url>%2F2019%2F12%2F26%2Fnetwork-in-vm%2F</url>
    <content type="text"><![CDATA[当我们创建和使用虚拟机时，通常都伴随着虚拟机的联网问题。下面就帮大家梳理下QEMU虚拟机中几种网络的模拟和用法。 概述QEMU可以模拟多种网卡设备(例如PCI或者ISA设备)，同时可将这些虚拟网卡与host上的虚拟网络设备(或者虚拟的hub)连接起来。各种不同类型的网络设备既可以为虚拟机提供真实的网络访问(例如TAP、SLiRP user模式)，也可以是同一个host上面的不同虚拟机之间的访问(Socket)。常见的网络设备实现有4种： User模式: -net user (如果没有指定-net xx这是默认配置)。 TAP(Terminal Access Point): 这是QEMU推荐的虚拟机联网的虚拟网络设备的后端实现。可以认为虚拟网卡直接与其相连。TAP接口的行为应该与真实的网络设备一样，一旦将TAP绑定到“网桥”(bridge)上之后，他们就可以网络通信了。 Hubs: hub实现将多个网络设备连接起来，比如QEMU的虚拟网卡(TAP设备)，将虚拟机中的多个网卡相连，或者host的网络设备通过参数-netdev hubport或者-nic hubport相连。 Socket: 通过参数-netdev socket (或-nic socket或-net socket) 可以实现多个虚拟机之间的互联。 对于虚拟机上网，以上四种QEMU网络相关的模拟，这里暂时只关心前两个(3、4实际还没有用到过:p,如有必要日后补充)，User模式以及TAP接口。下面详细介绍下如何使用这两种方式搭建不同类型的网络供虚拟机使用。 NAT方式如图所示，NAT方式与家里上网的方式有点类似，虚拟机在一个子网内(192.168.122.255)，宿主机看做双网卡(虚拟了一个网卡),这也是QEMU默认就支持的。 QEMU默认的NAT (SLiRP)首先，在我们没有为QEMU指定任何网络参数的情况下，我们很多时候依然可以使用网络，拓扑结构如下图所示： 这是因为通常在编译QEMU的时候，默认会编译模块SLiRP(除非显式的指定--disable-slirp)，这样QEMU在创建虚拟机的时候，即便用户不指定，也会有默认的参数-net=user。user mode的NAT网络优缺点很明显： 设置最为简单，不需要额外的配置就能满足虚拟机最基本的网络需求。 缺点是这个NAT网络也仅仅是“最基本“的需求。slirp模块有许多网络协议不支持，最常见的ICMP不支持，所以，在虚拟机中是无法使用ping的；另外，performance大概就更不需要奢求太多。 通过TAP配置NAT拓扑结构跟user模式一模一样，见下图： 确保已安装libvirt-clients和libvirt-daemon 1234Ubuntu:apt-get install libvirt-clients //使用virshapt-get install libvirt-daemon //使用libvirtdapt-get install qemu-system-common //使用qemu-bridge-helper 确保libvirt-daemon服务开启 12systemctl start libvirtdsystemctl enable libvirtd 如果遇到libvird启动失败，尝试一下: 12# brctl addbr br0add bridge failed: Package not installed 如果出现上述错误，说明需要重新编译内核，同时需要打开 networking &gt; 802.1d Ethernet Bridging 如果libvirtd启动成功的话会出现一个虚拟桥virbr0和virbr0-nic： 1234567891011121314151617181920#ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether d4:5d:df:07:c1:07 brd ff:ff:ff:ff:ff:ff inet 10.239.48.54/24 brd 10.239.48.255 scope global dynamic noprefixroute eno1 valid_lft 12387sec preferred_lft 12387sec inet6 fe80::d65d:dfff:fe07:c107/64 scope link valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:d3:6d:2d brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc fq_codel master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:d3:6d:2d brd ff:ff:ff:ff:ff:ff 使用virsh配置网络在没有进行任何网络配置之前，应该是这样的： 1234#virsh net-list --all Name State Autostart Persistent---------------------------------------------------------- 一个比较偷懒的办法是使用现成的配置文件default.xml，内容如下: 123456789101112&lt;network&gt; &lt;name&gt;default&lt;/name&gt; &lt;uuid&gt;417b7ead-6342-40a4-b29f-02fa2d4df491&lt;/uuid&gt; &lt;forward mode=&apos;nat&apos;/&gt; &lt;bridge name=&apos;virbr0&apos; stp=&apos;on&apos; delay=&apos;0&apos;/&gt; &lt;mac address=&apos;52:54:00:d3:6d:2d&apos;/&gt; &lt;ip address=&apos;192.168.122.1&apos; netmask=&apos;255.255.255.0&apos;&gt; &lt;dhcp&gt; &lt;range start=&apos;192.168.122.2&apos; end=&apos;192.168.122.254&apos;/&gt; &lt;/dhcp&gt; &lt;/ip&gt;&lt;/network&gt; 1234567#virsh net-define default.xml#virsh net-start default#virsh net-list --all Name State Autostart Persistent---------------------------------------------------------- default active yes yes 如果看到看到上面的结果，那么“虚拟桥”（virt bridge）就配置成功了。实际上虚拟机通过NAT联网的时候，各个网络设备之间的关系如图所示: QEMU创建虚拟机 123qemu-system-x86_64 --enable-kvm -M q35 -m 4G -smp 1 -hda /root/ubuntu1904.qcow -vnc :7 \ -device virtio-net-pci,netdev=nic0,mac=00:16:3e:0c:12:78 \ -netdev tap,id=nic0,br=br0,helper=/usr/local/libexec/qemu-bridge-helper,vhost=on 因为使用了工具qemu-bridge-helper，它需要一个配置文件： 1234567/usr/local/etc/qemu/bridge.conf:#把我们有可能用得到的网桥名字都列在这里。allow br0allow br1allow virbr0 顺利的话，虚拟机起来之后会DHCP得到一个IP例如192.168.122.177。 Bridge方式如图所示，bridge方式是让虚拟机获得跟host一样网段的IP地址，就像是host的一个“网上邻居”一样。既然是使用TAP那么思路跟上面”通过TAP配置NAT”是一样的，配置”网桥“。但区别是这个网桥是需要跟网卡”绑定“的。下面用两种方法做网卡和网桥的”绑定“，但最后的效果是一样的。 通过TAP配置Bridge方法1首先使用’ip’工具来配置，注意这种方法是临时的，一旦重启系统，这些配置需要重新做。 创建一个“网桥”(bridge),取名br0 12ip link add name br0 type bridgeip link set br0 up 把物理网卡绑定到网桥上: 1ip link set dev enp3s0f1 master br0 //enp3s0f1 是网卡interface的名字 这步之后，可以通过ip a查看，br0 和 enp3s0f1具有相同的mac地址。 重启网络服务： 1systemctl restart NetworkManager 正常情况下，网络重启之后，br0会拿到IP，而之前的enp3s0f1不会拿到IP了。如果不是，执行下面命令: 12345ifdown enp3s0f1ifdown br0ifup br0ifup enp3s0f1systemctl restart NetworkManager QEMU创建虚拟机 123qemu-system-x86_64 --enable-kvm -M q35 -m 4G -smp 1 -hda /root/ubuntu1904.qcow -vnc :7 \ -device virtio-net-pci,netdev=nic0,mac=00:16:3e:0c:12:78 \ -netdev tap,id=nic0,br=br0,helper=/usr/local/libexec/qemu-bridge-helper,vhost=on 吼吼，创建虚拟机的步骤与NAT时，没有区别，除了注意一下网桥的名字之外。 (选做)如果想要删掉“网桥”执行下面的步骤： 123ip link set dev enp3s0f1 nomasterip link set dev br0 downip link del br0 通过TAP配置Bridge方法2这里借用工具nmcli来配置，参考了USING THE NETWORKMANAGER COMMAND LINE TOOL, NMCLI 简单来说执行下面的命令： 123456#nmcli con add type bridge ifname br0#nmcli con add type ethernet ifname enp3s0f1 master bridge-br0#nmcli connection down enp3s0f1#nmcli connection up bridge-br0#systemctl restart NetworkManager 这样应该就创建好网桥br1了 QEMU创建虚拟机的步骤还是跟之前的一样。这个方法的优点就是系统重启之后，配置还在。 pass-through物理网卡这种方法的网络拓扑结构跟bridge方式是一样的，不过这次虚拟机成为货真价实的网上邻居，因为它使用的是物理网卡。如果host上恰好有一个多余的网卡，不妨试下这个方法，它拥有理论上跟host一样的网络性能，使用虚拟机的网卡驱动。pass-through物理网卡虽然实现起来相对复杂，但用起来却比较容易： 确保host没有加载对应网卡的驱动不过通常这都不太可能，可以参考这个脚本 1# ./vfio-pci.sh -h &lt;B:D:F&gt; QEMU创建虚拟机 12qemu-system-x86_64 --enable-kvm -M q35 -m 4G -smp 1 -hda /root/ubuntu1904.qcow -vnc :7 \ -device vfio-pci,host=81:00.0,romfile= 相比几种方法，去掉了复杂的网络参数，仅仅加上了一个设备，并且指定其B:D:F是需要被pass-through给虚拟机的网卡对应的B:D:F的即可(例子中为81:00.0)。 参考文献：2.9 Network emulationQEMU’s new -nic command line optionDocumentation/Networking9.2.USING THE NETWORKMANAGER COMMAND LINE TOOL, NMCLI]]></content>
      <categories>
        <category>QEMU KVM</category>
      </categories>
      <tags>
        <tag>qemu kvm network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用虚拟机(QEMU)实现宿主机快速重启]]></title>
    <url>%2F2019%2F12%2F18%2Ffast-restart%2F</url>
    <content type="text"><![CDATA[为什么这么做？ 系统完成一次重启的时间太久。 越来越频繁的安全相关的紧急的升级，包括Firmware/microcode/OS/VMM/QEMU。 运行中断给“云”服务提供商带来不好的用户体验。 目前已有的类似方案 Live patch在线补丁； 虚拟机热迁移； 这里暂且不评价各个方案的优劣，仅仅是想提供一个选择3！ 重点是，简单快捷，包教包会。 方案的工作流程 运行QEMU创建VM，在VM中进行任何操作。 将现有的虚拟机（VM）保存（Snapshot）到内存（pmem）中。 退出qemu，并且可以使用kexec软重启系统，同时可以升级内核、QEMU、Microcode 等。 重新运行QEMU，恢复VM使其继续执行。 内核准备编译内核大概率需要重新编译一个内核，确保所有的所需kernel config都打开。主要是三类内核Configure： NVDIMM，DAX和PMEM相关的都打开吧。123456789101112131415161718CONFIG_X86_PMEM_LEGACY_DEVICE=yCONFIG_X86_PMEM_LEGACY=mCONFIG_BLK_DEV_PMEM=mCONFIG_ARCH_HAS_PMEM_API=yCONFIG_DAX_DRIVER=yCONFIG_DAX=yCONFIG_DEV_DAX=yCONFIG_DEV_DAX_PMEM=mCONFIG_DEV_DAX_KMEM=mCONFIG_DEV_DAX_PMEM_COMPAT=mCONFIG_FS_DAX=yCONFIG_FS_DAX_PMD=yCONFIG_LIBNVDIMM=mCONFIG_NVDIMM_PFN=yCONFIG_NVDIMM_DAX=yCONFIG_NVDIMM_KEYS=y 内核参数1memmap=2G!4G 含义是，需要在内存中4G的位置开始，预留2G的内存空间。了解更详细的memmap用法及含义。 QEMU准备下载QEMU1git clone git://git.qemu.org/qemu.git 其中包含了几个子模块，会在编译过程中下载。但是如果在墙内的网络环境中，通常这会失败，下面是墙内的步骤：1234git clone git://git.qemu.org/qemu.gitcd qemugit submodule initgit submodule update --recursive 如果在git submodule update的过程中出现某个module下载失败，需要手动下载到相应的目录里，路径通常在错误日志中会提到12git clone http://git.qemu.org/git/seabios.git/ roms/seabiosgit submodule update --recursive 直到这样的状态就可以放心编译QEMU了：123456789101112git submodule status --recursive65cc4d2748a2c2e6f27f1cf39e07a5dbabd80ebf dtc (v1.4.0)87eea99e443b389c978cf37efc52788bf03a0ee0 pixman (pixman-0.32.6)b4c93802a5b2c72f096649c497ec9ff5708e4456 roms/SLOF (qemu-slof-20141202-63-gb4c9380)4e03af8ec2d497e725566a91fd5c19dd604c18a6 roms/ipxe (v1.0.0-2016-g4e03af8)3caee1794ac3f742315823d8447d21f33ce019e9 roms/openbios (3caee17)c559da7c8eec5e45ef1f67978827af6f0b9546f5 roms/openhackware (heads/master)c87a92639b28ac42bc8f6c67443543b405dc479b roms/qemu-palcode (heads/master)33fbe13a3e2a01e0ba1087a8feed801a0451db21 roms/seabios (rel-1.8.2)23d474943dcd55d0550a3d20b3d30e9040a4f15b roms/sgabios (heads/master)2072e7262965bb48d7fffb1e283101e6ed8b21a8 roms/u-boot (v2014.07-rc1-79-g2072e72)19ea12c230ded95928ecaef0db47a82231c2e485 roms/vgabios (heads/master) 编译QEMUQEMU的编译并没有什么特别的，参数都可以“顾名思义” :)123./configure --target-list=x86_64-softmmu --enable-kvm --enable-libpmem --enable-vnc --enable-gtk --enable-sdl --disable-werrormake 具体步骤可以通过DAX设备（DAX device）或者DAX文件（DAX file)两种方式来达到同样的效果。 方法一：DEV device实现方法使用/dev/dax0.0作为vNVDIMM的后端（backend） 准备一个DAX设备(dax dev)前提是Kernel已经按照前面的configure配置，并且成功编译安装。1ndctl create-namespace --mode devdax --map mem -e namespace0.0 -f 这样会产生一个 /dev/dax0.0 创建虚拟机123456789x86_64-softmmu/qemu-system-x86_64 \ --enable-kvm \ -M q35 \ -m 2G -smp 1 \ -hda ubuntu-1904.qcow2 \ -object memory-backend-file,id=dimm0,size=4g,mem-path=/dev/dax0.0,share=on,pmem=on,align=2M \ -numa node,memdev=dimm0,cpus=0 \ -monitor stdio \ -vnc :7 -sdl 两点说明： -object memory-backend-file,id=dimm0,size=4g,mem-path=/dev/dax0.0,share=on,pmem=on,align=2M意思是： 创建一个容量为4g的后端存储设备，设备节点路径是/dev/dax0.0，所有对这个虚拟NVDIMMM设备（vNDVIMM）设备的访问，都会走到/dev/dax0.0 share=on 控制虚拟机写操作的可见性。如果share=on，那么虚拟机对这个存储设备的“写”操作会提交到设备上，同时，如果有其他虚拟机使用同一个存储设备，上面的“写”操作同样会被“看”到。如果share=off,那么虚拟机的“写”操作不会被提交到存储设备，也因此其他虚拟机无法“看“到此虚拟机”写“的内容。 pmem=on 同时需要满足QEMU编译的时候，打开了libpmem支持（–enable-libpmem）, 此时QEMU会保证虚拟机的对vNVDIMM设备的“写”操作的“持续性”；但如果这时候QEMU并没有enable libpmep，虚拟机会创建失败并且提示”lack of libpmem support”。 align=2M DAX设备需要2M对齐。 -numa node,memdev=dimm0,cpus=0 意思是：描述虚拟机的numa结构，这里主要是为了使用上一步创建的vNVDIMM作为虚拟机的内存。了解更详细的vNVDIMM用法及含义。 特别说明 guest的镜像_必须_是 qcow2 格式的！如果vm的镜像是raw格式，需要创建qcow2格式的镜像。 1qemu-img create -b xxxx.img -f qcow2 test.qcow2 这样虚拟机就创建好了，登录虚拟机（通过vncview :7）做点你想要做的事情。 保存虚拟机现场在QEMU console中输入HMP命令，并且退出QEMU 1234(qemu) migrate_set_capability x-ignore-shared on //设置QEMU在保存VM的时候，忽略share=on的那些内存。这里指代不保存VM的pmem。(qemu) stop //停止虚拟机(qemu) savevm s0 //保存虚拟机snapshot为s0(qemu) q //退出QEMU 升级操作系统这个时候，可以对宿主机为所欲为，比如更新QEMU，更新microcode，安装新kernel，kexec软重启。kexec的使用方法: 123kernel_image=&quot;/boot/vmlinuz-`uname -r`&quot; initrd_image=&quot;/boot/initrd.img-`uname -r`&quot;sudo kexec -l $kernel_image --reuse-cmdline --initrd=$initrd_image 重启QEMU，恢复虚拟机现场 123456789x86_64-softmmu/qemu-system-x86_64 \ --enable-kvm \ -M q35 \ -m 4G -smp 1 \ -hda $IMAGE_PATH/ubuntu-1904.qcow2 \ -object memory-backend-file,id=dimm0,size=4g,mem-path=/dev/dax0.0,share=on,pmem=on,align=2M \ -numa node,memdev=dimm0,cpus=0 \ -monitor stdio \ -vnc :7 -sdl 在QEMU console中输入HMP命令，重新加载snapshot s0 123(qemu) stop(qemu) loadvm s0(qemu) c 方法二：DAX file实现方法使用DAX file实现时，是用一个支持文件（支持影射为pmem）作为后端。“写”操作的“持续性”是“宿主机”的内核来支持（v4.15之后）。 创建虚拟机前的准备工作1ndctl create-namespace --mode fsdax --map mem -e namespace0.0 -f 没有意外的话，会出现`/dev/pmem0’的一个块设备。然后执行: 12mkfs.ext4 -b 4096 -E stride=512 -F /dev/pmem0 //格式化pmem设备mount -t ext4 -o dax /dev/pmem0 /dax //把pmem设备mount到一个目录，支持DAX 创建虚拟机123456789x86_64-softmmu/qemu-system-x86_64 \ --enable-kvm \ -M q35 \ -m 4G -smp 1 \ -hda $IMAGE_PATH/ubuntu-1904.qcow2 \ -mem-path /dax \ -device vfio-pci,host=81:00.0,romfile= \ -monitor stdio \ -vnc :7 -sdl -mem-path /dax ：为虚拟机分配内存，使用一个临时创建的文件路径。这里是指之前mount的pmem0设备 保存虚拟机现场保存虚拟机的方法跟Dev DAX一模一样，在QEMU console中输入HMP命令，并且退出QEMU。 1234(qemu) migrate_set_capability x-ignore-shared on //设置QEMU在保存VM的时候，忽略share=on的那些内存。这里指代不保存VM的pmem。(qemu) stop //停止虚拟机(qemu) savevm s0 //保存虚拟机snapshot为s0(qemu) q //退出QEMU 升级操作系统这个时候，可以对宿主机为所欲为，比如更新QEMU，更新microcode，安装新kernel，kexec软重启。kexec的使用方法: 123kernel_image=&quot;/boot/vmlinuz-`uname -r`&quot; initrd_image=&quot;/boot/initrd.img-`uname -r`&quot;sudo kexec -l $kernel_image --reuse-cmdline --initrd=$initrd_image 重启QEMU，恢复虚拟机现场 123456789x86_64-softmmu/qemu-system-x86_64 \ --enable-kvm \ -M q35 \ -m 4G -smp 1 \ -hda $IMAGE_PATH/ubuntu-1904.qcow2 \ -mem-path /dax \ -device vfio-pci,host=81:00.0,romfile= \ -monitor stdio \ -vnc :7 -sdl 至此，虚拟机又可以接着之前的地方呼啸的跑下去了。效果看下面的视频吧： 快速启动演示 step1=>operation: 创建虚拟机。 step2=>operation: 保存虚拟机到pmem。 step3=>operation: 退出QEMU、更新kernel、Microcode等升级。 step4=>operation: 重新运行QEMU，恢复VM使其继续执行。 step1->step2->step3->step4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>KVM QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用虚拟机(QEMU)学习X86指令集1--内存存储的重排序以及FENCE指令]]></title>
    <url>%2F2019%2F07%2F16%2Fstudy-x86-fence%2F</url>
    <content type="text"><![CDATA[浅谈“内存读写重排序”在我们编写C/C++代码时，以及它在CPU上运行时，按照一些规则，代码中原有的内存读写指令的执行顺序(又叫“程序顺序”, program ordering)会被重新排列。这个现象会在两个地方引入，编译时候由编译器引入；以及运行时由处理器引入。目的都是为了”使代码运行的更快”。尽管本文重在说明运行时CPU对内存读写的重排序作用。但考虑完整性以及防止读者混淆，我们会两种重排序一起介绍。 X86的内存读写顺序模型按照内存访问重排序发生情况的多少，大概划分为下面三种“顺序模型”。 弱顺序模型弱顺序模型中，可能会出现四种内存重排序(Load-Load, Store-Store, Load-Store 和 Store-Load)。任意读(load)操作和写(store)操作都有可能与其他读写操作重排序，只要它能保证原来程序的行为。采用弱顺序模型的处理器可以称为“weakly-order”或者”weak ordering”。对于C/C++的编译器gcc(因为我只用过gcc:p)，都可以呈现弱顺序模型，稍后我们看下例子。 强顺序模型强顺序模型和弱顺序模型的界限可能不一定有确切的标准，但从SDM 8.2章开头可以看到，奔腾4之后的X86处理器大概属于强顺序类型：To allow performance optimization of instruction execution, the IA-32 architecture allows departures from strongordering model called processor ordering in Pentium 4, Intel Xeon, and P6 family processors继续读SDM8.2 可以发现如下约定： Reads are not reordered with other reads. (任何‘读-读’之间不可重排序)这就意味着前述弱顺序模型中的重排序中的”load-load”禁止。 Writes are not reordered with older reads. (‘写’不可向前重排到‘读’之前)这就意味着弱顺序模型中的”load-store”被禁止。 Writes to memory are not reordered with other writes, with the following exceptions:… (‘写’与‘写’之间不可以重排序，但除了如下例外。例外的部分我们暂时忽略)这就意味着弱顺序模型中的大部分”store-store”是被禁止的，例外情况文末会提到。 Reads may be reordered with older writes to different locations but not with older writes to the same location. (‘读’可以向前重排序到不同内存位置的‘写’之前)这就明确的说明4种弱顺序模型中的store-load是被允许的!。这也是我们后面实例的重要依据。 顺序一致所有运行时内存访问的顺序跟程序顺序一模一样。现如今都是多核系统，可能很难找到可以成为顺序一致(Sequential consistency)的CPU了。如果真要追溯可能是386时代。 编译时内存顺序重排序我们先通过下面这个最简单的实例，体验编译器如何进行内存访问的重排序的，直接看代码：12345int a, b;void test() &#123; a = b; b = 1;&#125; 写了一个.c 文件，里面仅仅包含了上面这几行，然后我们用gcc把它翻译成汇编语言： 12345$gcc -S -O0 test.c -o test1.smovl b(%rip), %eaxmovl %eax, a(%rip)movl $1, b(%rip) 12345$gcc -S -O2 test.c -o test2.smovl b(%rip), %eaxmovl $1, b(%rip) &lt;--- 被提前了!!movl %eax, a(%rip) 通过这个例子可以明显的感受到gcc的弱顺序模型：-O0的时候，顺序跟我们预期的程序顺序是一致的；但当使用-O2优化时，test函数的最后一句的变量b赋值明显已经被向前重排到了变量a的存储之前！但我们需要知道的是，这样的重排序，对于单线程的硬件来说，重排序并不会影响程序最后的执行结果。但是对于多线程来说，如果有另外的线程实时的读取变量a的值的话，很可能会得到错误的结果。 如何阻止编译器的重排序？前辈们习惯的用法是这样的：123456int a, b;void test() &#123; a = b; asm volatile(&quot;&quot; ::: &quot;memory&quot;); b = 1;&#125; 加了嵌入式汇编asm volatile(&quot;&quot; ::: &quot;memory&quot;);后的test.c再无论怎么优化，都会得到跟-O0一样的汇编结果。 CPU运行时重排序前面的一篇文章大概翻译了下SDM的8.2章节SMD Chapter 8.2 内存存取顺序，我们按照SDM8.2.3.4的描述，重现一个store-read操作的重排序，并且观察MFENCE是如何工作的，以保证执行顺序的正确。 回顾SDM8.2.3.4的内容intel-64存取顺序重排允许加载操作重排序到不同地址的存储之前，但不允许重排序到同一个地址的存储之前。 处理器0 处理器1 mov [x],1 mov [y],1 mov r1 [y] mov r2,[x] 初始值 x=y=0 r1 = 0 并且 r2 = 0 允许 代码实现下面我们就来实现上面这段逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define USE_CPU_FENCE 0atomic_t begin_sem1;atomic_t begin_sem2;atomic_t end_sem;int X, Y;int r1, r2;int main(int ac, char **av) &#123; int detected = 0; atomic_set(&amp;begin_sem1, 0); atomic_set(&amp;begin_sem2, 0); atomic_set(&amp;end_sem, 0); id = 0; for (int i = 1; ; ++i) &#123; X = Y = 0; r1 = r2 = 1; atomic_inc(&amp;begin_sem1); atomic_inc(&amp;begin_sem2); while(atomic_read(&amp;end_sem) != 2) NOP(); atomic_set(&amp;end_sem, 0); if (r1 == 0 &amp;&amp; r2 == 0) &#123; detected++; printf(&quot;%d reorders detected after %d iterations\n&quot;, detected, i); &#125; if( i % 10000 == 0) printf(&quot;BSP: times %d\n&quot;, i); &#125; while(1) &#123; NOP(); &#125; return 0;&#125;void test1() &#123; while(atomic_read(&amp;begin_sem1) != 1) NOP(); atomic_dec(&amp;begin_sem1); asm volatile( &quot;xor %0, %0\n\t &quot; &quot;movl $1, %1\n\t &quot;#if USE_CPU_FENCE &quot;mfence\n\t &quot;#endif &quot;movl %2, %0\n\t &quot; : &quot;=r&quot;(r1), &quot;=m&quot; (X) : &quot;m&quot;(Y) : &quot;memory&quot;); atomic_inc(&amp;end_sem);&#125;void test2() &#123; while(atomic_read(&amp;begin_sem2) != 1) NOP(); atomic_dec(&amp;begin_sem2); asm volatile( &quot;xor %0, %0\n\t &quot; &quot;movl $1, %1\n\t &quot;#if USE_CPU_FENCE &quot;mfence\n\t &quot;#endif &quot;movl %2, %0\n\t &quot; : &quot;=r&quot;(r2), &quot;=m&quot; (Y) : &quot;m&quot;(X) : &quot;memory&quot;); atomic_inc(&amp;end_sem);&#125; 完整的可编译的code可以到github上clone:git clone -b memory_ordering https://github.com/ysun/acrn-unit-test.git在guest文件夹里执行make unit file=memory_order就可以执行了。 源码分析读代码难免有点枯燥，我们把流程图画一下就一目了然了： 上面这个例子中一共涉及到了三个逻辑CPU(core)。BSP(processor1)就是上电后第一个执行指令的逻辑CPU，负责另外两个AP(processor2和processor3)的同步工作。两个AP负责分别运行两段测试代码test1和test2。 程序一开始，两个AP(processor2和processor3)忙等待BSP发来的同步信号(begin_sem1和begin_sem2)。BSP在进行了必要的初始化操作之后，使用原子操作(atomic_inc)分别将上述两个信号 +1。两个AP等到各自的信号之后，立即清除该信号，然后准备测试。 所以，我们可以认为processor2和processor3几乎是同步运行的。也就是test1和test2代码块可以认为是同时运行。此时processor1在忙等待两个AP的测试完成end_sem == 2。 test1和test2的两段汇编很简单，严格按照前面的表各种所述。如果没有重排序的发生，那么两个寄存器变量中r1和r2中的值都应该是1。但如果我们发现某次test1和test2测试结束后，r1和r2的值同时为0的时候，那么就说明发生了重排序，test1和test2中的两个store操作，也就是movl %2, %0这句重排到了movl $1, %1这句之前，而且是两个processor同时发生这样的重排序。 processor1在end_sem == 2的时候，意味着两个AP都已完成，此时processor1检测是否r1 == r2 == 0。 通过改变宏定义USE_CPU_FENCE 的值来重现重排序，以及引入MFENCE来防止重排序。 执行结果下面两个图就是义USE_CPU_FENCE=0和USE_CPU_FENCE=1两次不同的运行结果。从打印的日志可以容易的看出图一发生了重排序，图二中大概200w次测试没有发生重排序。需要指出的是这里200w次循环执行时间不超过1秒钟，非常快。 LFENCE 和 SFENCE既然说到FNECE了，咱就得讲完另外两种LFENE和SFENCE。SDM里面讲LFENCE是保证load-load操作不被重排序，SFENCE是保证store-store不被重排序，就是前面在说SDM8.2里面列举了禁止的弱顺序模型中的store-store我们省略掉的部分。Writes to memory are not reordered with other writes, with the following exceptions:— streaming stores (writes) executed with the non-temporal move instructions (MOVNTI, MOVNTQ,MOVNTDQ, MOVNTPS, and MOVNTPD); and— string operations (see Section 8.2.4.1) 这里我利用RDTSC指令实现了LFENCE组织CPU指令的重排序，这里不列举了，大概意思是，在一个逻辑CPU上，利用两次rdtsc指令之间插入LFENCE来观察循环的周期的长短来判断LFENCE的作用。只放个链接在这里吧memory_ordering_lfence.c 但对于SFENCE，我按照SDM 8.2.2所述内容并没有重现MOVNTI指令的store-store重排序，所以没能确认SFENCE的作用。我的MOVNTI和SFENCE的测试代码在这里memory_ordering_sfence.c，幻想着某位大牛可以回复我一下！！！ 参考文档：https://preshing.com/20120930/weak-vs-strong-memory-models/https://preshing.com/20120515/memory-reordering-caught-in-the-act/http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/ c_code=>operation: C 语言 asm_code=>operation: 汇编语言 cpu_instruction=>operation: CPU执行序列 compiler_reorder=>inputoutput: 编译器重排序 cpu_reorder=>inputoutput: 处理器重排序 c_code(right)->compiler_reorder(right)->asm_code(right)->cpu_reorder(right)->cpu_instruction{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>X86</category>
      </categories>
      <tags>
        <tag>x86 KVM QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用虚拟机(QEMU)学习X86指令集0]]></title>
    <url>%2F2019%2F07%2F12%2Fstudy-x86-using-qemu%2F</url>
    <content type="text"><![CDATA[引言接下来的几个日志，我会写几篇关于如何学习X86指令集，也是帮助自己梳理和记忆知识点。下面是我大概总结了一下，一个操作系统需要掌握的知识点，仅供参考欢迎斧正！ 学习内容 上图用户层应用程序以及硬件部分暂不是本文考虑范围，中间的三个软件部分“Linux内核/模块”、“IA32e指令”以及“BIOS/UEFI部分指令”都可以通过本文的方法学习。需要说明的是，虽然这里划分了三个部分，并不是操作系统上的划分，只是一个建议的学习的阶段划分。 BIOS/UEFI 部分设计的指令是指硬件上电后CPU执行的最早期的指令。通常包括BIOS、boot loader等。这部分可以通过x86-bare-metal-examples来学习 IA32e指令是指操作系统已经经过一些初始化操作，例如开启页表、开启32bit或者32e模式、段寄存器初始化、开启中断（APIC/X2APIC)、开启SMP支持等。在这样的环境中，我们可以更专注于X86指令集的研究。上述初始化过程可以等日后展开讲述。 Linux内核/模块基本上Linux 内核开发涵盖之前两个方面，只是上来就学习Linux内核有点复杂，代码量太大。并且，本系教程的重点在于学习X86指令，并不在Linux中复杂的功能实现。 如何利用QEMU学习首先确保系统里安装了qemu，步骤略。大概有两种形式使用QEMU 编译随便举个例子，来自kvm-unit-test:12345678910gcc -m64 -g -Wall -fno-pic -no-pie -std=gnu99 -ffreestanding \ -I /home/works/kvm-unit-tests/lib -I /home/works/kvm-unit-tests/lib/x86 -I ./lib \ -c -o x86/tsc.o x86/tsc.cgcc -I /home/works/kvm-unit-tests/lib -I /home/works/kvm-unit-tests/lib/x86 \ -I lib -T /home/works/kvm-unit-tests/x86/flat.lds -fno-pic -no-pie -nostdlib \ x86/tsc.c x86/cstart64.o lib/libcflat.a /usr/lib/gcc/x86_64-linux-gnu/5/libgcc.a \ -o x86/tsc.elf objcopy -O elf32-i386 x86/tsc.elf x86/tsc.flat ##&amp;&amp; ./x86-run x86/tsc.flat 编译一个test case，代码如下：12345678910111213int main(void)&#123; u64 t1, t2; asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(a), &quot;=d&quot;(d)); t1 = a | ((long long)d &lt;&lt; 32); asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(a), &quot;=d&quot;(d)); t2 = a | ((long long)d &lt;&lt; 32); printf(&quot;rdtsc latency %u\n&quot;, (unsigned)(t2 - t1)); return 0;&#125; 这样得到一个测试两次rdtsc指令执行的时间差的测试tsc.flat。当然上面辣么麻烦的编译啊、链接啊都是为了得到最终的测试的binary，或者叫可执行文件？！我们后面有很多种方法以及机会得到这样的测试代码，如果读者一时没有成功，不要终止于此，不要气馁。 在虚拟机中作为内核直接运行(-kernel)1qemu-system-x86_64 -vnc none -serial stdio -machine accel=kvm -kernel x86/tsc.flat 这样运行的虚拟机，看上去并不真的像是一个“虚拟机”，因为没有窗口，仅仅是console端文字输出。但这样足够我们验证和尝试CPU 指令，而且非常的轻量。个人比较喜欢这样的运行方式。 制作一个镜像文件，并且使用QEMU启动我们可以手动制作一个镜像，步骤如下。但最后一步安装grub的时候，需要的条件有点苛刻，需要本地装有较新版本的grub-x86_64-efi。如果本地没有环境的同学，可以直接跳过制作镜像，直接下载文末的制作好的镜像文件raw.img。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$ dd if=/dev/zero of=raw.img bs=512 count=10485761048576+0 records in1048576+0 records out536870912 bytes (537 MB, 512 MiB) copied, 1.22641 s, 438 MB/s$ losetup /dev/loop0 raw.img$ fdisk /dev/loop0Welcome to fdisk (util-linux 2.27.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition table.Created a new DOS disklabel with disk identifier 0xe68d8ac0.Command (m for help): gCreated a new GPT disklabel (GUID: 93A91033-E421-48DD-88E9-662C17E83136).Command (m for help): nPartition number (1-128, default 1):First sector (2048-999966, default 2048):Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-999966, default 999966):Created a new partition 1 of type &apos;Linux filesystem&apos; and of size 487.3 MiB.Command (m for help): tSelected partition 1Hex code (type L to list all codes): 1Changed type of partition &apos;Linux filesystem&apos; to &apos;EFI System&apos;. Command (m for help): w #then to ensure the disk status$ sudo fdisk -l /dev/loop0#注意：#1.the disk type must be gpt#2.disk identifier should have sha id#3.the type must be EFI SystemDisklabel type: gptDisk identifier: 93A91033-E421-48DD-88E9-662C17E83136Device Start End Sectors Size Type/dev/loop0p1 2048 999966 997919 487.3M EFI System $ partprobe /dev/loop0$ lsblkloop0 7:0 0 488.3M 0 loop└─loop0p1 259:4 0 487.3M 0 loop $ sudo mkfs.vfat -F 32 /dev/loop0p1mkfs.fat 3.0.28 (2015-05-16)$ mkdir /virtfs$ mount -o rw,umask=000 /dev/loop0p1 /virtfs$ grub-install --removable --root-directory=/virtfs --target=x86_64-efi /dev/loop0p1Installing for x86_64-efi platform.Installation finished. No error reported. $ cp /boot/grub/grub.cfg /virtfs/boot/grub/grub.cfg 同样，这里附上UEFI/OVMF的build 方法，但同样可以直接下载文末的binary，毕竟这不是本文的主要内容。1234567891011121314151617181920212223242526272829$ git clone git://github.com/tianocore/edk2.git$ cd edk2# Because the latest version is missing a file, switch to an older version$ git checkout 984ba6a467$ cd edk2$ make -C BaseTools$ . edksetup.sh $ vi Conf/target.txt #Find # ACTIVE_PLATFORM = Nt32Pkg/Nt32Pkg.dsc # and replace it with # ACTIVE_PLATFORM = OvmfPkg/OvmfPkgX64.dsc # Find # TOOL_CHAIN_TAG = MYTOOLS # and replace it with your version on GCC here for example GCC 4.6 will be used. # TOOL_CHAIN_TAG = GCC5 //this is your gcc version # Find # TARGET_ARCH = IA32 # and replace it with &apos;X64&apos; for 64bit or &apos;IA32 X64&apos; to build both architectures. # TARGET_ARCH = X64 #mode detail:https://wiki.ubuntu.com/UEFI/EDK2 $ build $ find -name &quot;OVMF.fd&quot; #./Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd $ vim ~/.bashrc # add this to bashrc &quot;export OVMF_PATH=/home/huihuang/git/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd&quot; $ source ~/.bashrc 123456#!/bin/bash mkdir -p virt_fs sudo losetup /dev/loop7 raw.img partprobe /dev/loop7 sudo cp x86/tsc.elf virt_fs/tsx.elf# sudo umount $(virt_fs_path) 上面这个脚本是将之前生成的tsx.flat文件copy到预先准备好的镜像里面。同时，需要确保镜像中的grub.cfg文件中有正确的entry：1234567891011menuentry &apos;acrn_unit_test&apos; &#123; recordfail load_video insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_gpt insmod ext2 set root=&apos;hd0,gpt0&apos; search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt0 --hint-efi=hd0,gpt0 --hint-baremetal=ahci0,gpt4 A807-B387 multiboot /tsx.elf&#125; 要启动这个镜像需要使用OVMF（EDK2项目中的软件模拟的UEFI）。下面是QEMU的启动参数 1234 DISPLAY=:0 qemu-system-x86_64 --bios OVMF_CODE.fd \-drive file=raw.img,index=0,media=disk,format=raw \-serial mon:stdio -m 1024M -smp cpus=4 \-cpu Nehalem,+sse,+avx,+xsave,+sse2,+sse3,+mpx,+fpu,level=13 #-vnc :0 这里所需的所有文件都放在文末以备下载。这样启动的虚拟机，就有种仪式感了，QEMU会创建一个窗口，同时因为有UEFI/OVMF，所以可以看到一个虚拟的BIOS画面，然后还有GRUB的选择菜单，选择刚刚创建的tsx.elf的入口。 OVMF 点击下载：OVMFraw.img 点击下载： raw.img 调试虚拟机代码请参考 Debug QEMU with GDB 小结自此如何利用虚拟机学习底层编程的准备工作都已经搞定，我们会在后面的文章里陆续介绍X86的指令。可能不一定系统，甚至可以说的是零碎。因为Intel SDM实在是太长了，能吃透个一章半节的就挺开心的了。仅仅是为想学相关技术的同学们一点点思路，有不对的地方请留言指正！ blk_userspace=>parallel: 用户态应用程序 blk_kernel=>parallel: Linux内核/模块 blk_64bit=>parallel: IA32e指令|invalid blk_bios=>parallel: BIOS/UEFI 部分设计的指令|approved blk_hardware=>parallel: 系统硬件 blk_kernel_study=>parallel: linux-kernel-module-cheat:>https://github.com/cirosantilli/linux-kernel-module-cheat blk_64bit_study=>parallel: KVM Unit Test|future:>http://www.linux-kvm.org/page/KVM-unit-tests blk_bios_study=>parallel: x86-bare-metal-examples:>https://github.com/cirosantilli/x86-bare-metal-examples blk_userspace(path1, bottom)->blk_kernel(path1, bottom)->blk_64bit(path1,bottom)->blk_bios(path1,bottom)->blk_hardware blk_64bit(path2,right)->blk_64bit_study blk_bios(path2,right)->blk_bios_study blk_kernel(path2, right)->blk_kernel_study{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>X86</category>
      </categories>
      <tags>
        <tag>X86 KVM QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++ 中嵌入汇编总结]]></title>
    <url>%2F2019%2F05%2F22%2Finline-assembly%2F</url>
    <content type="text"><![CDATA[GCC汇编语法梗概AT&amp;T 与 Intel 汇编区别Linux GCC(GNU, C Compiler)使用AT&amp;T汇编语法。下面列一下AT&amp;T 和Intel汇编语法中的不同： 源-目的 顺序AT&amp;T中源和目的操作数的顺序相反。Intel语法中第一个操作数是目的，第二个是源。而AT&amp;T语法中，第一个是源第二个操作数是目的。“Op-code src, dst” —— AT&amp;T 语法“Op-code dst, src” —— Intel语法 寄存器命名AT&amp;T语法中，寄存器需要有‘%’前缀，例如eax需要写作%eax。这里只是强调Intel汇编语法中不使用各种前缀，具体寄存器命名后面会继续涉及。 立即数AT&amp;T中立即数需要有‘$’前缀。如果是静态“C”变量，同样需要’$’前缀。Intel语法中，16进制需要’h’前缀，而AT&amp;T则需要‘0x’前缀。所以，对于16进制的立即数写作 ‘$0x1234’ 操作数大小在AT&amp;T语法中，内存操作数的大小取决于Op-code的后缀字母’b’’w’以及’l’，分别指代’字节(8bit) 字(16bit) 和长字(32bit)内存指针。而Intel语法使用前置限定符’byte ptr’ ‘word ptr’ 以及’dword prt’。所以下面两句等效：12Intel &quot;mov al, byte ptr foo&quot;At&amp;T &quot;movb foo, %al&quot; 内存地址的访问在AT&amp;T中基址寄存器使用’()’，Intel中使用’[]’。 下面两句等效：12Intel &quot;section: [base + index*scale + disp]&quot;AT&amp;T &quot;section: disp(base, index, scale)&quot; GNU AT&amp;T汇编寄存器现代X86处理器（例如386及其以后）有8个32位通用寄存器（general purpose registers,GPR）如图:寄存器名字是继承过来的。例如EAX成为累加器，因为之前被大量的算法这样操作，ECX被称为计数器，因为它通常用来作为循环的索引。然而，在现代指令集中，大多数寄存器已经失去了它之前特殊的用途。但有两个例外的——堆指针（ESP）和基址指针（EBP）。对于EAX EBX ECX以及EDX，可以分段使用。例如，EAX的低2字节可以看做是16位寄存器，称作AX；低1字节可以看做8位寄存器，称作AL，而AX的高字节也可以看作是8位寄存器，成为AH。这些寄存器名字都指向相同的物理寄存器。当2字节数值存入DX中的时候，它会影响DH，DL以及EDX。123movb $2, (%ebx) /* Move 2 into the single byte at the address stored in EBX. */movw $2, (%ebx) /* Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in EBX. */movl $2, (%ebx) /* Move the 32-bit integer representation of 2 into the 4 bytes starting at the address in EBX. */ 内存操作符X86指令中，我们可以生命静态数据区域（类似全局变量）。使用.data指令来声明，紧跟在.data指令之后，使用指令.byte, .short 以及.long来声明1,2或者4字节数据位置，然后使用标签来引用之前创建的数据区。标签可以看做是内存区域的名字，可以在之后的汇编或者连接器中使用标签，这就跟用名字声明变量非常的相似，但稍微有些不同。比如，一个连续的内存数据位置的声明他们在内存中的位置是连续的。12345678.datavar: .byte 64 /* Declare a byte, referred to as location var, containing the value 64. */ .byte 10 /* Declare a byte with no label, containing the value 10. Its location is var + 1. */x: .short 42 /* Declare a 2-byte value initialized to 42, referred to as location x. */y: .long 30000 /* Declare a 4-byte value, referred to as location y, initialized to 30000. */ 并不像高级语言那样，数组可以有各种容量，并且可以使用索引访问。X86汇编中的数组仅仅是简单的一些内存中接续的存储单元。数组可以通过列出数值累声明（例如第一个例子）。对于一些特别的数组，可以使用字符串；再如果一个很大的内存需要填充0，那么可使用.zero指令。12345678s: .long 1, 2, 3 /* Declare three 4-byte values, initialized to 1, 2, and 3. The value at location s + 8 will be 3. */barr: .zero 10 /* Declare 10 bytes starting at location barr, initialized to 0. */str: .string &quot;hello&quot; /* Declare 6 bytes starting at the address str initialized to the ASCII character values for hello followed by a nul (0) byte. */ 内存寻址现代X86处理器最高可寻址2^32字节的内存地址（内存地址有32位宽）。上面的例子中，我们使用标签指向内存区域，这些标签实际上被编译器用实际32位地址取代。为了更进一步支持标签指向内存地址（例如常量），X86提供了一个灵活的计算和引用内存地址的方法：两个32位寄存器以及一个32位有符号常量相加，并且其中一个寄存器可以被2,4,8相乘。有一点需要注意，当disp/scale中使用常数的时候，这里不再需要”$”前缀。 Intel 代码 AT&amp;T 代码 mov eax, 1 movl $1, %eax mov ebx, 0ffh movl $0xff, %ebx int 80h int $0x80 mov ebx, eax mov %eax, %ebx mov eax, [ecx] movl (%ecx), %eax mov eax, [ebx + 3] movl 3(%ebx), %eax mov eax, [ebx + 20h] movl 0x20(%ebx), %eax mov eax, [ebx + ecx] movl (%ebx,%ecx), %eax mov eax, [ebx + ecx*2h] movl (%ebx,%ecx,0x2), %eax mov eax, [ebx + ecx*4h-20h] movl -0x20(%ebx,%ecx,0x4), %eax 基本内联基本内联汇编的格式比较简单：1asm(&quot;assembly code&quot;); 例如：12asm(&quot;movl %ecx, %eax&quot;); //把ecx中的内容移动到eax中__asm__(&quot;movb %bh, (%eax)&quot;) //把寄存器bh中的内容移动到eax指向的内存地址 这里有几点注意事项： 千万不要忘记src, dst两个操作数之间的逗号’,’ 这里asm() 和 __asm()__ 都是有效的。 如果有多行汇编，需要在每行末尾添加 \n\t，除最后一行汇编的末尾。例如： 1234__asm__ (&quot;movl %eax, %ebx \n\t&quot; &quot;movl $56, %esi \n\t&quot; &quot;movl %ecx, $label(%edx,%ebx,$4) \n\t&quot; &quot;movb %ah, (%ebx)&quot;); 如果在代码中，更改过一些寄存器并从asm返回后，则会发生一些难以预料的事情。这是因为GCC不知道寄存器内容的变化，所致，特别是当编译器进行一些优化时。这就需要一些扩展功能的地方。下面来看下扩展的asm语法。 扩展的ASM在基本内联汇编中，我们只有指令。但在扩展汇编中，我们可以指定操作数。并且允许指定输入寄存器，输出寄存器以及改动的寄存器列表。但不强制使用寄存器。格式如下：12345asm ( assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */ ); 如果没有输出操作符，但有输入操作，也必须保留两个冒号，例如:1234567asm (&quot;cld \n\t&quot; //多行指令 &quot;rep \n\t&quot; &quot;stosl&quot; : /* 没有输出寄存器 */ : &quot;c&quot; (count), &quot;a&quot; (fill_value), &quot;D&quot; (dest) : &quot;%ecx&quot;, &quot;%edi&quot; ); 上段代码意思是，把fill_value变量中的值往edi指向的内存地址写入count次。也就是说，eax和edi中的内容不再有效。再来看下面的例子：1234567int a=10, b;asm (&quot;movl %1, %%eax; \n\t&quot; &quot;movl %%eax, %0;&quot; :&quot;=r&quot;(b) /* output */ :&quot;r&quot;(a) /* input */ :&quot;%eax&quot; /* clobbered register */ ); 这段代码意思是，把变量a的值赋值给b。 ‘b’是输出操作符，%0引用它，并且’a’是输入操作符，1%引用它。 ‘r’是操作符的限定符。这里’r’告诉GCC可以使用任意一个寄存器来存储操作符。’=’是输出操作符的限定符，并且是只写的。 在寄存器之前有两个’%’号。用来帮助GCC区别操作符还是寄存器。操作符只有一个’%’前缀。换句话说，在扩展ASM语法中，如果在汇编中直接使用寄存器名字而不是通过%0 %1这样引用，则寄存器前需要两个%限定。 改动的寄存器%eax列在第三个冒号在后，告诉GCC %eax的值在汇编中有改动，所以GCC不会再用这个寄存器存储其他的值。当asm结束时，’b’会反应更新过的数据，因为他被指定为输出操作符。换句话说，在汇编中改变’b’的值，会被反映到汇编之外。 但如果一个寄存器已经出现在输出操作符列表中，那么无需再将它添加到clobber list里，如果添加了编译的时候会报错。例如下面这段汇编是错误的：1234567 int a=10, b;asm (&quot;movl %1, %%eax; \n\t&quot; &quot;movl %%eax, %0;&quot; :&quot;=b&quot;(b) /* 明确指出使用寄存器ebx */ :&quot;r&quot;(a) /* input */ :&quot;%eax&quot;, &quot;%ebx&quot; /* 编译出错！！ */ ); 编译器模板操作数每个 操作数都必须包含在“”之内。对于输出操作数，双引号（“”）中会多一个限定符，用来决定限定符地址的模式。如果有多个操作数，他们使用逗号（，）隔开。每个操作数都可以通过数字来引用，按照顺序一次命名。输入和输出操作数依次命名，第一个输出的操作数记作0，后面依次增加。输出操作数必须是长类型，输入操作数没有这个限制。扩展汇编最常用来调用机器指令本身，跟编译器无关。如果输出表达式不是一个直接地址，例如一个位阈，限定符必须是寄存器。此事，GCC会使用寄存器作为内联汇编的输出，并且把寄存器的值存储到输出里。综上，原始输出操作数必须是“只写”的；GCC假定在指令结束之前，数值都在这些操作数中，并且不需要生成。扩展汇编也支持读写操作数。来看几个例子：1234asm (&quot;leal (%1, %1, 4), %0&quot; : &quot;=r&quot; (five_times_x) : &quot;r&quot; (x) ); 这个例子中，输入是’x’，并且没有指定寄存器。GCC会自己选择一个。再同样给输出选择一个寄存器。如果我们想要输入输出使用同一个寄存器，可以告诉GCC我们希望那种读写的操作数，比如：1234asm (&quot;leal (%0, %0, 4), %0&quot; : &quot;=r&quot; (five_times_x) : &quot;0&quot; (x) ); 此时，输入输出操作数会是同一个寄存器。但我们并不知道是具体那一个。如果想明确指定某一个寄存器，也有方法，比如：1234asm (&quot;leal (%%ecx,%%ecx,4), %%ecx&quot; : &quot;=c&quot; (x) : &quot;c&quot; (x) ); 以上三个例子，并没有指定任何改动寄存器列表，为什么？前两个例子，GCC决定使用哪个寄存器，它会知道寄存器发生的变化。在最后一个例子中，我们也没有指定变化寄存器，因为GCC知道值最终保存到x中，在汇编之外，它知道ecx的值了，所以没有必要列出变化寄存器列表(clobber list)，如果列上%ecx编译就会错误。 变化寄存器列表(clobber)有些指令会改变硬件寄存器，因此必须明确指出这些改动过的寄存器，将其列在第三个’:’之后。这是为了告诉GCC汇编使用并修改了那些寄存器。所以，GCC会知道之前被加载到这些寄存器的值已经无效了。同时没有必要列出放在输入和输出操作数中的寄存器，以内GCC知道内联已经使用了他们。需要明确指出的是那些没有明确指出的隐式使用的寄存器，那些没有列在输入和输出操作数中的寄存器。如果指令修改了内存，需要在clobber list中添加”memory”。这样通知GCC内存缓存应该失效了。同时必须添加’volatile’关键字，如果内存修改并没有列在输入和输出操作数中时。我们多次可以读写更改的寄存器，参考下面的例子，意思是调用子程序_foo，并且通过eax 和 ecx传递两个参数给他。注：这里的寄存器名字前是否加%，eax和%eax都是正确的！1234567asm (&quot;movl %0,%%eax; \n\t&quot; &quot;movl %1,%%ecx; \n\t&quot; &quot;call _foo&quot; : /* no outputs */ : &quot;g&quot; (from), &quot;g&quot; (to) : &quot;eax&quot;, &quot;ecx&quot; ); Volatile 关键字如果熟悉内核源码，我们会经常看到volatile或者volatile关键字在 asm或者asm之后。如果内联汇编需要在它原来所在的位置处被执行，例如不被移到循环的外面或者不被优化掉，在asm 和 （）之间放一个volatile，像这样：1asm volatile ( ... : ... : ... : ...); 如果我们添加的汇编语言仅仅是为了计算并且没有任何边际效应，最好不要使用volatile关键字，因为volatile会妨碍代码优化。 关于限定符前面的例子中我们已经使用了很多限定符，但还没有具体讲限定符的作用。限定符可以规定操作数是否在寄存器中，什么样的寄存器；以及操作数是指向内存以及内存地址类型；操作数是否是立即数，和数字的范围。来看下常用的限定符。 寄存器操作数限定符 ‘r’当使用这个限定符时，操作数被存储在通用寄存器中（General Purpose Registers, GPR)。举例说明：1asm (&quot;movl %%eax, %0\n&quot; :&quot;=r&quot;(myval)); 变量myval被存储到及粗糙那其中，寄存器eax中的值被copy到那个寄存器中，并且myval的值会被从寄存器更新到内存中。因为限定符’r’，gcc会把变量保存到任何一个通用寄存器中。如果需要明确指定某一个寄存器，需要使用相对应的限定符，如下表： r GPRs a %eax, %ax, %al b %ebx, %bx, %bl c %ecx, %cx, %cl d %edx, %dx, %dl S %esi, %si D %edi, %di 内存操作数限定符 ‘m’当操作数在内存中，任何关于操作数的操作都直接访问内存地址。相反，寄存器操作数是先把数据存储到寄存器中，在写回到内存地址中。但寄存器限定符只有当指令明确需要或者明显加速处理，才会存储到寄存器中。当一个C变量需要在内联汇编更新的时候，内存限定符会更方便，并且，我们并不是真的需要用寄存器来存储值。例如存储IDTR的值到loc中：1asm(&quot;sidt %0\n&quot; : :&quot;m&quot;(loc)); 匹配限定符(Digit)很多情况下，一个变量就可以做输入也可以做输出操作数，例如：1asm (&quot;incl %0&quot; :&quot;=a&quot;(var):&quot;0&quot;(var)); 来看一个简单的例子，寄存器eax及用作输入同时用作输出操作数。变量var作为输入，传值给eax，并且在完成自增后，又更新到eax中。“0”这里指代同一个限定符，第0个，也就是输出变量。也就是输出变量var只会被存到eax中。通常下列情况可以这样使用： 当变量作为输入，并且协会到同一个变量中。 没必要把输入和输出分开的时候。匹配限定符最重要的作用是高效的使用寄存器。 其他限定符：“g” : Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.“m” : A memory operand is allowed, with any kind of address that the machine supports in general.“o” : A memory operand is allowed, but only if the address is offsettable. ie, adding a small offset to the address gives a valid address.“V” : A memory operand that is not offsettable. In other words, anything that would fit the m’ constraint but not theo’constraint.“i” : An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time.“n” : An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use ’n’ rather than ’i’. 下面是X86特有的限定符：“r” : Register operand constraint, look table given above.“q” : Registers a, b, c or d.“I” : Constant in range 0 to 31 (for 32-bit shifts).“J” : Constant in range 0 to 63 (for 64-bit shifts).“K” : 0xff.“L” : 0xffff.“M” : 0, 1, 2, or 3 (shifts for lea instruction).“N” : Constant in range 0 to 255 (for out instruction).“f” : Floating point register“t” : First (top of stack) floating point register“u” : Second floating point register“A” : Specifies the ‘a’ or ‘d’ registers. This is primarily useful for 64-bit integer values intended to be returned with the ‘d’ register holding the most significant bits and the ‘a’ register holding the least significant bits. 限定修饰符 ‘=’ 意思是操作数是“只写”的，之前的值会被输出值覆盖掉。 ‘&amp;’ 意思是输入操作数在本条指令完成之前，被修改。但这个操作数可能没有列在输入操作数列表或者是内存的一部分。如果输入仅仅用于早起结果的输入时，输入操作数可以被看做earlyclobber操作数 ‘+’ 意思是操作数是“可读可写”的。 参考：https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/ http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html 实例First we start with a simple example. We’ll write a program to add two numbers. 12345678910 int main(void)&#123; int foo = 10, bar = 15; __asm__ __volatile__(&quot;addl %%ebx,%%eax&quot; :&quot;=a&quot;(foo) :&quot;a&quot;(foo), &quot;b&quot;(bar) ); printf(&quot;foo+bar=%d\n&quot;, foo); return 0;&#125; Here we insist GCC to store foo in %eax, bar in %ebx and we also want the result in %eax. The ’=’ sign shows that it is an output register. Now we can add an integer to a variable in some other way. 1234567__asm__ __volatile__( &quot; lock ;\n&quot; &quot; addl %1,%0 ;\n&quot; : &quot;=m&quot; (my_var) : &quot;ir&quot; (my_int), &quot;m&quot; (my_var) : /* no clobber-list */ ); This is an atomic addition. We can remove the instruction ’lock’ to remove the atomicity. In the output field, “=m” says that my_var is an output and it is in memory. Similarly, “ir” says that, my_int is an integer and should reside in some register (recall the table we saw above). No registers are in the clobber list. Now we’ll perform some action on some registers/variables and compare the value. 12345__asm__ __volatile__( &quot;decl %0; sete %1&quot; : &quot;=m&quot; (my_var), &quot;=q&quot; (cond) : &quot;m&quot; (my_var) : &quot;memory&quot; ); Here, the value of my_var is decremented by one and if the resulting value is 0 then, the variable cond is set. We can add atomicity by adding an instruction “lock;\n\t” as the first instruction in assembler template. In a similar way we can use “incl %0” instead of “decl %0”, so as to increment my_var. Points to note here are that (i) my_var is a variable residing in memory. (ii) cond is in any of the registers eax, ebx, ecx and edx. The constraint “=q” guarantees it. (iii) And we can see that memory is there in the clobber list. ie, the code is changing the contents of memory. How to set/clear a bit in a register? As next recipe, we are going to see it. 12345__asm__ __volatile__( &quot;btsl %1,%0&quot; : &quot;=m&quot; (ADDR) : &quot;Ir&quot; (pos) : &quot;cc&quot; ); Here, the bit at the position ’pos’ of variable at ADDR ( a memory variable ) is set to 1 We can use ’btrl’ for ’btsl’ to clear the bit. The constraint “Ir” of pos says that, pos is in a register, and it’s value ranges from 0-31 (x86 dependant constraint). ie, we can set/clear any bit from 0th to 31st of the variable at ADDR. As the condition codes will be changed, we are adding “cc” to clobberlist. Now we look at some more complicated but useful function. String copy.123456789101112 static inline char * strcpy(char * dest,const char *src)&#123;int d0, d1, d2;__asm__ __volatile__( &quot;1:\tlodsb\n\t&quot; &quot;stosb\n\t&quot; &quot;testb %%al,%%al\n\t&quot; &quot;jne 1b&quot; : &quot;=&amp;S&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;a&quot; (d2) : &quot;0&quot; (src),&quot;1&quot; (dest) : &quot;memory&quot;);return dest;&#125; The source address is stored in esi, destination in edi, and then starts the copy, when we reach at 0, copying is complete. Constraints “&amp;S”, “&amp;D”, “&amp;a” say that the registers esi, edi and eax are early clobber registers, ie, their contents will change before the completion of the function. Here also it’s clear that why memory is in clobberlist. We can see a similar function which moves a block of double words. Notice that the function is declared as a macro.123456789 #define mov_blk(src, dest, numwords) \__asm__ __volatile__ ( \ &quot;cld\n\t&quot; \ &quot;rep\n\t&quot; \ &quot;movsl&quot; \ : \ : &quot;S&quot; (src), &quot;D&quot; (dest), &quot;c&quot; (numwords) \ : &quot;%ecx&quot;, &quot;%esi&quot;, &quot;%edi&quot; \ ) Here we have no outputs, so the changes that happen to the contents of the registers ecx, esi and edi are side effects of the block movement. So we have to add them to the clobber list. In Linux, system calls are implemented using GCC inline assembly. Let us look how a system call is implemented. All the system calls are written as macros (linux/unistd.h). For example, a system call with three arguments is defined as a macro as shown below.12345678910 #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \type name(type1 arg1,type2 arg2,type3 arg3) \&#123; \long __res; \__asm__ volatile ( &quot;int $0x80&quot; \ : &quot;=a&quot; (__res) \ : &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \ &quot;d&quot; ((long)(arg3))); \__syscall_return(type,__res); \&#125; Whenever a system call with three arguments is made, the macro shown above is used to make the call. The syscall number is placed in eax, then each parameters in ebx, ecx, edx. And finally “int 0x80” is the instruction which makes the system call work. The return value can be collected from eax. Every system calls are implemented in a similar way. Exit is a single parameter syscall and let’s see how it’s code will look like. It is as shown below.123456 &#123; asm(&quot;movl $1,%%eax; /* SYS_exit is 1 */ xorl %%ebx,%%ebx; /* Argument is in ebx, it is 0 */ int $0x80&quot; /* Enter kernel mode */ );&#125; The number of exit is “1” and here, it’s parameter is 0. So we arrange eax to contain 1 and ebx to contain 0 and by int $0x80, the exit(0) is executed. This is how exit works. 参考：https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMD Chapter 8.2 内存存取顺序]]></title>
    <url>%2F2019%2F05%2F12%2Fsdm-8-2-memory-ordering%2F</url>
    <content type="text"><![CDATA[‘内存存取顺序(Memory ordering)’一词说的是处理器通过系统总线进行读取（加载）以及写回（存储）到系统内存里面。Intel 64以及32位系统根据架构的实现，支持多种存储顺序模型。例如，intel 386处理器强制使用“程序顺序”（强顺序），就是说读写系统总线的顺序按照全部环境中CPU指令流产生的顺序。后来为了指令执行的效率，IA32架构允许脱离“强顺序”，在奔腾4、Xeon以及P6系列处理器中，称作“处理器顺序”。处理器顺序不同的方式，称作“内存存取顺序模型”，他们都允许增强执行，例如 允许读操作在可以缓存的写操作之前。所有这些不同模型的目的就是增强指令执行速度，同时保持存储内容的一致性，即使在多核系统中亦然。8.2.1和8.2.2章节描述在intel486、奔腾、Core2 Due、Atom、Core Due、奔腾4、Xeon以及P6系列处理器中内存存取模型的实现。8.2.3章节会给出具体的存储模型的例子。8.2.4章节是关于字节操作的特殊处理。8.2.5章节讨论一些特殊指令的使用会影响存储模型的行为。 8.2.1 奔腾以及486处理器上的存储模型奔腾和486处理器遵循“处理器顺序”的内存存取模型，但在大多数情况下他们是按照“强顺序”模型来运行的。加载和存储是按照系统总线顺序，但除了以下情况：加载允许放在缓存的写之前，当所有的写操作都被缓存，但是不可以跟加载操作是同一个地址。对于I/O操作，无论是加载还是存储都是程序顺序。 8.2.2 P6系列以及最新系列CPU的存储顺序Intel Core2 Due、Atom、Core Duo、奔腾4以及P6系列处理器上使用的处理器顺序模型可以被称为“带写缓存转发的存储顺序（write ordered with store-buffer forwarding）”（很拗口，可能读到后面才能理解上啥意思），我们本节来看这种模型。在单处理器系统中存储区域被定义为“可缓存的回写”。这种存取模型遵循下面的法则。注意，单核或者多核处理器存储模型中涉及到的名词“处理器”都是指逻辑处理器。比如，一个物理处理器支持多核或者支持intel 超线程技术（HT），那么它都被看做是“多核处理器” 加载操作之间不可以重排序。 存储不可以跟加载操作重排序。 存储操作间除下列例外情况之外，不可以重排。 流存储通过非时态（non-temporal)的move 指令，MOVINTI，MOVNTQ，MOVNTDQ， MOVNTPS以及MOVNTPD。 字符串操作（详见8.2.4.1） 不允许CLFLUSH指令的存储操作的重排序；当使用CLFLUSHOPT指令时，存储操作可以被重排序，并且刷新缓存而不是直接存储。CLFLUSH指令的执行不可以被重新排序。当刷新不同缓存线的时候，CLFLUSHOPT指令的执行可以被重新排序。 加载操作可以与不同地址的存储操作重排序，不可以与相同地址的存储重新排序。 在I/O操作、锁指令或者串行指令时加载和存储都不可以重排序。 加载不可以早于LFENCE和MFENCE指令。 存储和CLFUSH、CLFLUSHOPT不能早于LFENCE、SFENCE以及MFENCE指令。 LFENCE指令不可以早于加载。 SFENCE指令不可以早于存储或者CLFLUSH、CLFLUSHOPT指令。 MFENCE指令不能早于加载、存储或者CLFLUSH和CLFLUSHOPT指令。 对于多核处理器，还要遵守下面规则： 多核处理器中的每一个核都与单核处理器遵守同样的准则。 各个核中的存储顺序是跟所有处理器中存储顺序是一致的。 单个处理器上的存储操作与其他处理器上的存储操作顺序无关。 内存存取顺序遵从因果关系（memory ordering respects transitive visibility）。 在同一个处理器上的任何两个存储操作都可以看做是有确定顺序的，但整个存储操作看来却不一定。 锁指令具有绝对的执行顺序。 看一个例子，图8-1.有三个处理器，并且每个处理器中有三个存储操作，分别是A，B，C。单独来说，处理器是按照程序顺序来进行存储操作，但由于总线仲裁以及内存访问机制，三个处理器对同一个内存的访问，即使是执行同一段代码，可能每次都不太一样。本章处理器顺序模型是奔腾和486所使用的，在奔腾4、Xeon以及P6系列处理器中，仅仅加强了如下内容： 增加了推理加载，但依然遵守上午策略。 存储缓存转发，当一个读取操作在存储操作之后。 长字符串的乱序存储以及move操作（详见8.2.4） 8.2.3 举例说明存储顺序策略本章举例说明8.2.2中的内存存取顺序策略。目的是给软件开发人员深入理解内存存取顺序是如何影响不同指令序列的结果的。这些例子仅限于有回写缓存能力的内存区域。读者需要理解他们仅仅是软件可见的行为。即便某个例子说明不可以重排的两次方访问，逻辑处理器也可能会重排。此时软件是无法察觉这样的重排操作发生。 8.2.3.1 假设、术语以及注意事项如前文所述，本章所述的内容仅限于回写缓存（WB）的存储区域。此时仅提交原始的加载和存储操作，同时为“读-改-写”指令加锁。同时并不提交任何如下指令：字符串的乱序存储、用non-temporal hint访问存储、处理器加载页表以及更新段、页结构。在本节例子中，Intel64存储顺序模型保证下列内存访问指令视为一次单独的访问操作: 加载或存储一个字节的指令 加载或存储一个word（2字节），并且他们的地址是2字节对齐的。 加载或存储一个doubleword(4字节），并且他们的的地址是4字节对齐的 加载或存储一个quadword（8字节），并且他们的地址8字节对齐的。任何带锁的指令（例如XCHG或者其他读后写的指令都会有一个LOCK前缀指令），看上去是作为一次单独的、不会被中断的指令序列。其他指令也可能是有多次内存存取访问组合来实现的。从内存存取顺序的观点来看，并不能保证其操作的顺序，也不能保内存存取操作的顺序跟程序加载的顺序一致。8.2.3.2至8.2.3.7使用MOV指令来举例。通过内存存取操作来说明存储器策略以及其他各种存取指令的基础。8.2.3.8和8.2.3.9使用XCHG指令举例，用来说明那些带锁的以及读后写的指令。本章节中“处理器”是指逻辑处理器。例子是用intel-64汇编语言，并且使用如下写法： 使用’r’开头的参数，例如r1 r2看作是寄存器，只有处理器可见。 存储器地址记作x,y,z 存储记为 mov [_x],val, 意思是把val存到寄存器的_x地址中 加载记作 mov r,[_x], 意思是把内存地址_x中的值加载到寄存器r中 正如前文所述，例子只是设计软件可见的行为。当文中说“把两个存储操作重排”意思是“两个存储操作从软件的角度看上去被重新排列执行顺序了”。 8.2.3.2 相似的加载或者存储都不可以重排序Intel-64 内存存取顺序模型不允许同样类型的加载或者存储指令重新排列。也就是说，在程序中加载或者存储都是按照程序顺序，用下面的里说明： Processor0 Processor1 mov [_x],1 mov r1,[_y] mov [_y],1 mov r2,[_x] 初始值 x=y=0 r1 = 1 并且 r2 = 0 是不允许的 只有当处理器0的两个存储操作重排序，或者处理器1的两个加载操作重排的时候，返回值是非法的。 如果r1 = 1，那么对y的存储操作早于y的加载。因为Intel-64内存存取顺序模型不允许存储操作重排序，所以存储X的操作也应早于y，同事由于存储顺序模型不允许加载重排序，所以x的存储也早于x的加载，所以 r2 = 1. 8.2.3.3 存储不能重排到加载之前Intel-64 存储顺序模型确保处理器的存储操作不会在同一个处理器家在之前。 处理器0 处理器1 mov r1,[x] mov r2,[y] mov [y],1 mov [x],1 初始值 x=y=0 r1 = 1 并且 r2 = 1 非法 假设 r1 = 1 因为r1 = 1， 处理器1的x存储早于处理器0的x的加载 因为intel-64 存取顺序模型避免存储操作被重排序到同一个处理器的加载操作之前，处理器1的y的加载早于对x的存储。 同理，处理器0的x的加载早于y的存储 因此，处理器1中y的加载在处理器0y存储之前，所以r2 = 0. 8.2.3.4 加载可以被重排序到不同地址的存储之前intel-64存取顺序重排允许加载操作重排序到不同地址的存储之前，但不允许重排序到同一个地址的存储之前。 处理器0 处理器1 mov [x],1 mov [y],1 mov r1 [y] mov r2,[x] 初始值 x=y=0 r1 = 0 并且 r2 = 0 允许 在每个处理器中，对于不同的地址的加载和存储操作是允许重排序的。任何交替执行方式也因此被允许。其中一种交替执行的方式，是两个加载在两个存储之前。这样的结果就是r1和r2都返回0 处理器0 mov [x], 1 mov r1,[x] 初始值 x = 0 r1 = 0 非法 Intel64 存取顺序模型不允许加载重排序到同一个地址的存储之前，因此r1 = 1必须被加载。 8.2.3.5 允许处理器内转发存取顺序模型允许两个处理器并行的存储，但从各自处理器看来存储的顺序是不一样的。每一个处理器可能都认为自己的存储操作早于另一个处理器的存储操作。举例说明： 处理器0 处理器1 mov [x], 1 mov [y],1 mov r1,[x] mov r3,[y] mov r2,[y] mov r4,[x] 存储顺序模型不会在执行顺序上增加限制。这个情况允许处理器0认为它的存储操作早于处理器1，同事处理器1认为它的存储操作早于处理器0.这使得r2=0并且r4=0成为可能。事实上，这个例子可以看做是存储缓存区转发。当处理器临时含有存储缓存的时候，它可以传递给处理器自己的加载操作，但它不能被其他的处理器看到并加载。 8.2.3.6 内存存取顺序可见存取顺序模型确保存储的可见性。一个处理器上的存储操作需要被所有的处理器可见，并且按照一定的合理的顺序。举例说明： 处理器0 处理器1 处理器2 mov [x],1 mov r1,[x] mov [y],1 mov r2,[y] mov r3,[x] 初始值 x=y=0 r1 = 1并且r2 =1并且 r3=0 非法 假设 r1=1 并且 r2 = 1. 因为r1=1，处理器0的存储早于处理器1的加载 因为存取顺序模型避免存储被重排序到加载之前，处理器1中的加载早于存储。因此处理器0的存储的存储势必早于处理器1的存储。 因为处理器0的存储早于处理器1的存储，存储顺序模型确保处理器0的存储在所有处理器看来早于处理器1. 因为r2 = 1, 处理器1的存储早于处理器2的加载操作。 因为Intel-64存储模型避免加载操作重排序，处理器2的加载顺序执行。 综上分析，处理器0的存储在处理器2的加载之前，这就意味着r3 = 1. 8.2.3.7 存储顺序一致正如8.2.3.5中提到，存取顺序模型允许两个处理器看到不同的处理顺序。然而，任意两个存储操作必须在所有处理器看来有一致的执行顺序。举例说明： 处理器0 处理器1 处理器2 处理器3 mov [x],1 mov [y],1 mov r1,[x] mov r3,[y] mov r2,[y] mov r4,[x] 初始值 x=y=0 r1=1并且r2=0并且r3=1并且r4=0 非法 根据8.2.3.2中讨论的原则 处理器2中的两个加载不可以被重排序 处理器3中的两个加载不可以被重排序 如果 r1=1 并且 r2=0，根据处理器2的加载，处理器0的存储在处理器1的存储之前。 同理，r3=1并且r4=0，意味着，根据处理器1的加载，处理器1的存储在处理器0的存储之前。因此，内存存取顺序模型确保两个存储在所有处理器看来具有同样的顺序，所以这组返回值非法。 8.2.3.8 带锁的指令具有绝对顺序存取顺序模型确保所有的处理器处理对待锁指令的时候保持一致，包括大于8字节的或者没有自然对齐的指令。举例说明： 处理器0 处理器1 处理器2 处理器3 xchg [x],r1 xchg [y],r2 mov r3,[x] mov r5,[y] mov r4,[y] mov r6,[x] 初始值 r1=r2=1, x=y=0 r3=1 并且 r4=0 并且r5=1 并且r6=0 非法 处理器2 和处理器3必须确保两个xchg指令的执行顺序。这里假定处理器1的xchg指令早于处理器3中y的加载指令发生。 如果r5=1, 处理器1的xchg执行早于处理器3的加载，先发生。 因为intel64 内存顺序模型避免加载重排序，处理器3中按顺序加载。所以处理器1的xchg早于处理器3中x的加载，先发生。 根据假设，处理器0中的xchg早于处理器1xchg，并且是在处理器3的加载之前，所以r6=1 8.2.3.9 加载和存储不允许跟锁指令重排序存取顺序模型避免加载和存储操作跟其前后的锁指令重排序。举例说明：第一个例子说明，加载操作不可以跟之前的锁指令重排序 处理器0 处理器1 xchg [x],r1 xchg [y],r3 mov r2,[y] mov r4,[x] 初始值 x=y=0, r1=r3=1 r2=0 并且 r4=0 非法 根据8.2.3.8的解释，锁指令有绝对的执行顺序，这里假设处理器0上的schg0先发生。因为intel64 内存存取顺序模型避免处理器1的加载跟锁指令重排序，处理器0上的xchg在处理器1的加载之前，这意味着，r4=1.相似的，如果处理器1的xchg先发生, 也可得非法返回值。 第二个例子说明存储操作不能跟之前的锁指令重排序。 处理器0 处理器1 xchg [x],r1 mov r2,[y] mov [y],1 mov r3,[x] 初始值 x=y=0, r1=1 r2=1 并且r3=0 非法 假设r2=1 因为r2=1， 处理器0的y存储早于处理器1的y的加载。 因为内存存取顺序模型避免存储跟前面的锁指令重排序，处理器0上的xchg早于y的加载发生。 因为内存存取顺序模型避免加载重排序，处理器1上按顺序加载，并且处理器1上的对x的xchg操作早于处理器1的x的加载，因为r3=1 8.2.4 快速字符串操作和乱序存储SDM 第一卷7.3.9.3 章节中描述描述了优化重复执行fast-string操作。该章节中阐述，存储产生fast-string操作，可能会乱序执行。软件则需要串行化存储顺序，所以不可以使用字符操作来存储整个的数据结构。数据和信号量应该分隔开。有顺序依赖的代码在进行字符串操作之后，需要写到一个单独的信号量中，以保证所有处理看到正确的数据顺序。加载和存储操作的原子化，仅能保证本地字符串数据元素，并且他们还得在用一个缓存中。8.2.4.1 和4.2.4.2提供的进一步的说明和例子。 8.2.4.1 字符串的内存存取模型本章讲述字符串操作的内存存取模型。存取规则如下： 单个字符串的存储可能是乱序执行。 一个独立的字符串的存储，例如保存一个连续的字符串，并不希望乱序。所有的存储操作都必须在完成上一次存储之后，进行新的存储操作。 字符串操作不可以跟其他存储操作重排序。 快速字符串操作（例如，使用MOVS/STOS指令，并且使用REP前缀）可能会被中断或者异常而打断。中断是准确的，但可能会延迟，比如中断可能在每个几次循环或者在每操隔几次操作之后，在缓存的边界触发。不同的实现方式可能配置不同，或者甚至选择不延迟中断handle，所以软件不要依赖延迟。如果运行到中断或者陷入的处理函数，源/目的寄存器指向下一个等待处理的字符串元素。当EIP存储在指向指令的栈中,并且ECX寄存器还持有上一条指令成功时的值。中断或者陷阱处理函数应该引起字符串指令被恢复到它之前中断的地方。字符串操作内存存取顺序规则（上面的2,3点）可以举例说明。如果一个快速字符串操作在第k次遍历时被中断，那么中断处理函数中的存储操作变为可见的（*）。只有当快速字符串操作开启时，存储单个字符串的操作可能乱序执行。（上面的1） 8.2.4.2 举例说明字符串操作中的内存存取策略To-do 8.2.5 加强型和减弱型内存存取模型Intel64和32体系结构提供了多种加强型或者减弱型的内存存取模型，以应对不同的程序条件。这些机制包括： I/O指令、锁指令，锁前缀以及串行化指令强制较强的存取顺序 SFENCE指令（IA32体系结构的奔腾3系列处理器）和LFENCE以及MFENCE指令（奔腾4处理器引入）提供内存存取顺序以及对某些特定指令的串行化的能力。 内存类型鸡寄存器（Memory type range registers，MTRR）可以在特定的物理内存区域中被用于增强或者减弱型的内存存取顺序。 MTRR只在奔腾4，Xeon 以及P6系列处理器中。 页属性表（page attribute table,PAT) 可以被用于页表或者页表组的增强型以及减弱型的内存存取顺序。PAT只在奔腾4，Xeon 以及P6系列处理器中。这些机制可以如下使用：映射到设备或者其他IO设备的内存地址通常顺序敏感。I/O指令（IN和OUt指令）强制使用写顺序。在执行一个I/O指令之前，处理器会等待所有的之前指令完成，并且所有的缓存写回内存中。但除了页表的获取和遍历指令。多核处理器系统的同步机制可以依赖强内存存取顺序模型。这里应用程序可以使用锁指令，例如XCHG指令以及所前缀，来确保读-改-写才做。锁指令通常操作起来像I/O操作，他们同样等待之前的指令结束并且把所有的缓存写回内存中。程序的同步也可以使用串行化指令（8.3章节）。这些指令通常在紧急的步骤中，或者边界任务，以确保所有之前的指令都完成，然后再跳转到新的代码段或者上下文切换。类似I/O或者锁指令，处理器会在之前的指令完成之前一直等待，并且把所有的缓存写回到内存中，然后再执行串行的指令。SFENCE、LFENCE以及MFENCE指令提供了高效的方法来确保通常情况下产生的弱顺序以及数据的处理过程中的加载和存储顺序。这些指令的方法如下： SFENCE：串行化所有的发生在SFENCE指令之前的程序指令流中的存储操作，但不影响加载操作。 LFENSE： 串行所有发生在在LFENCE指令之前的程序指令流中的加载操作，但不影响存储操作。 MFENCE： 串行化所有发生在MFENCE指令之前的存储和加载操作。 注意，相比CPUID指令，SFENCE、LFENCE以及MFENCE指令提供了更搞笑的方法控制内存存取顺序。MTRR在P6系列处理器中杯引入，来定义指定物理内存区域的缓存特性。下面的两个例子说明内存类型的设置可以使用增强或者减弱的内存存取顺序。 非缓存（uncached）内存类型，强制内存访问中使用强顺序模型。这里所有读写非缓存内存区域，不可能使用乱序或者预测的方法。这种类型的内存可以被用于I/O设备映射。 回写（write back,WB)内存类型是弱存取顺序。这时，加载可以使用预测的方法，并且存储可以被缓存或者合并。这种类型的内存，缓存锁作为原子操作，不可以被中断，可以用来指令同步，同时降低的程序运行的速度，例如XCHG指令，它会在整个读-改-写的操作中锁住总线。使用写回内存类型，如果缓存命中，那么XCGH指令只是锁缓存，而并不需要锁总线 PAT是在奔腾3处理器中被引入的，来增强缓存特性，可以用在页表或者页表组中。PAT机制通常用在页表层的增强特性，与MTRR相关。Intel推荐软件运行在Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium 4, Intel Xeon, and P6 family等系列处理器中，假定处理器顺序或者更弱的内存存取顺序模型。上述处理器没有实现强内存存取模型，除非使用非缓存内存。尽管其中一些处理器支持处理器顺序，但intel不保证未来的处理器会支持这种模型。为了让软件可以一直到未来的处理器，推荐操作系统提供紧急区域以及资源控制构造和基于I/O的API ，锁以及串行化指令，用来多处理器间同步访问共享的内存区域。并且，软件不应该依赖处理器顺序，当硬件系统不支持该种内存存取顺序模型。]]></content>
      <categories>
        <category>SDM</category>
      </categories>
      <tags>
        <tag>SDM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EFI Shell中使用tfpt.efi 自动化Kernel测试方案]]></title>
    <url>%2F2019%2F05%2F07%2Fefi-shell-tftp%2F</url>
    <content type="text"><![CDATA[引言对于Linux Kernel 或者OS相关的自动化测试，如何自动更新被测的Kernel以及OS image有时候是比较困难的事情。Linux社区的”老神仙”Fengguang同学牵头开发了0-day自动化测试系统，系统期初的核心功能是利用kexec加载待测的kernel image二次启动。大概流程是: 这个方法对于绝大多数kernel或者module测试中是工作的，也是非常灵活的。但有几个特例： 由于Kexec的限制，上述方法对Xen支持的不好。 对于被测对象是hypervisor的情况，因为没有host OS的支持，无法加载ramfs 这里大概验证了一个补充的方法，可以覆盖对于hypervisor等运行在Linux Kernel下层的组建进行自动化测试。 EFI 以及EDKII我不是EFI或者EDKII的专家，这里就简单描述使用方法。另外之所以需要编译EDKII，是因为一般平台自带的EFI shell网络支持都不是很好。 下载EDKII source code：123git clone https://github.com/tianocore/edk2.gitcd edk2git submodule update --init --recursive 编译edk2的编译工具123. edksetup.sh BaseToolscd BaseTools/make 编译EFI Shell包1build -p ShellPkg/ShellPkg.dsc -t GCC5 -a IA32 -a X64 然后就可以在目录Build/Shell/RELEASE_GCC5/X64/ 中找到shell.efi和tftp.efi。可以将这两个文件copy到efi分区中，就可以使用了。 加载shell.efishell.efi也只是个EFI 的application，可以使用Linux下的工具efibootmgr让BIOS自动加载1efibootmgr -c -l &quot;\EFI\shell.efi&quot; -d /dev/nvme0n1 -p 1 -L &quot;MY EFI SHELL&quot; 大概意思是创建(-c)一个entry，加载(-l)EFI文件\EFI\shell.efi，磁盘(-d)/dev/nvme0n1的第1个分区(-p 1)，标签命名为(-L &quot;MY EFI SHELL&quot;) 另外还有两个常用命令：12efibootmgr -vefibootmgr -o 0001,0002,0005,0003,0004,0000 -v 列出当前的启动顺序，一般新加入的都是第一个启动-o 后面列出来重新排列的启动顺序，需要需要从上一条命令中查到。 确认网络工作执行命令1ifconfig -l 可以列出来所有的网络接口。默认会自动dhcp，如果没有可以使用1ifconfig -i etho dhcp 来手动获取IP地址。 tips: 如果在BIOS里面设置关闭PXE网络启动的话，网络驱动就不会加载了，所以，建议在BIOS里面enable PXE boot，尽管我们并不使用它。 TFTP接下来简单说下TFTP的使用方法 搭建TFTP server以Ubuntu为例：12345678910111213141516171819202122安装：apt-get install tftp-hpa tftpd-hpa创建目录：mkdir /tftpboot # 这是建立tftp传输目录。sudo chmod 0777 /tftpbootsudo touch test.txt # test.txt文件最好输入内容以便区分配置：vim /etc/default/tftpd-hpa3TFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot; # 这里是你的tftpd-hpa的服务目录,这个想建立在哪里都行TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-l -c -s&quot; # 这里是选项,-c是可以上传文件的参数，-s是指定tftpd-hpa服务目录，上面已经指定重启服务sudo service tftpd-hpa restart # 启动服务，这里要注意，采用的独立服务形式。测试$ tftp 127.0.0.1tftp&gt;get test.txttftp&gt;put test1.txt EFI Shell 中使用tftp.efi在EFI shell中进入tftp.efi所在目录然后执行1tftp.efi &lt;tftp server IP&gt; &lt;文件名字&gt; 就可以下载文件了。 自动化kernel 测试方案：在EFI Shell的根目录中，比如fs0: 中添加一个文件 startup.nsh 内容如下：12345678910111213if not exist fs0:\EFI\tftp.efi then echo &quot;No tftp.efi&quot;endiffs0:cd \EFItftp.efi 10.239.159.139 kernel_images/bzImage_current bzImage:boot_os cd \EFI\ubuntu grubx64.efi 这样Ubuntu grub加载的时候，就可以使用刚刚下载来的kernel了，因为grub和efi都可以使用FAT分区格式。 当系统死掉了，并且需要更新kernel的时候，只需要覆盖tftp server上的bzimage_current或者改变其软连接的指向，然后重启系统，就可以一次性更新kernel。 Todo目前EFI shell能做的事情相比Linux shell还相差甚远，没有太多现成的application可以直接使用。tftp.efi也能是download，并不能upload，这使得EFI直接并不能对server进行通知，需要借助OS。后面，可以增加application，实现类似Linux工具curl，或者patch tfpt让它可以上传文件，这样就可以双向通信了。 附件EDKII是不是有点bug似乎，附上我build的efi shell 以及tftp，有需要的小伙伴可以直接点击下载64bit: shell.efi tftp.efi32bit: shell.efi tftp.efi st=>start: 系统启动 op1=>operation: 启动small size的kernel + ramfs op2=>operation: 初始化网络并获取IP地址 op3=>operation: 从服务器上获取可用的kernel image列表 op4=>operation: 根据列表的配置获取待测的kernel image op5=>operation: 在ramfs初始化的最后阶段使用Kexec加载待测的kernel image启动本地文件系统 e=>end: 系统启动结束 st->op1->op2->op3->op4->op5->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>efi</category>
      </categories>
      <tags>
        <tag>efi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM(Kernel-based Virtual Machine)源码分析]]></title>
    <url>%2F2019%2F02%2F20%2Fkvm-src-analysis%2F</url>
    <content type="text"><![CDATA[(编者按：写完才发现，这篇分析写的又臭又长…… 原谅语言凝练不足和code阅读还没有炉火纯青，我会慢慢提炼，有兴趣的同学可以评论区吐槽:) 在看code之前，先把KVM-QEMU的source code的大框架拎出来，给读者直观一点的感受，本文最后还有一个稍微详细的call graph。中间这些文字是帮助读者以及我自己阅读和理解code的，大多数是kernel source code，因为Qemu相关的在之前的日志中已经涉及到了。 VMCS对于Intel的虚拟化技术(VT)而言，它的软件部分基本体现在VMCS结构中(Virtual Machine Control Block)。主要通过VMCS结构来控制VCPU的运转。 VMCS是个不超过4K的内存块。 VMCS通过下列的指令控制: VMCLEAR: 清空VMCS结构 VMREAD: 读取VMCS数据 VMWRITE: 数据写入VMCS 通过VMPTR指针指向VMCS结构，该指针包含VMCS的物理地址。 VMCS包含的信息可以分为六个部分: Guest state area：虚拟机状态域，保存非根模式的vcpu运行状态。当VM-Exit发生，vcpu的运行状态要写入这个区域，当VM-Entry发生时，cpu会把这个区域保存的信息加载到自身，从而进入非根模式。这个过程是硬件自动完成的,软件只需要修改这个区域的信息就可以控制cpu的运转。 Host state area：宿主机状态域，保存根模式下cpu的运行状态。在vm-exit时需要将状态加载到CPU。大概包含如下寄存器： CR0, CR3, CR4, RSP, RIP (都是64bit的，不支持32位) 段选择器CS, SS, DS, ES, FS, GS, TR，不包含LDTR。 基址部分FS, GS, TR, GDTR 和IDTR 一些MSR: IA32_SYSENTER_CS, IA32_SYSENTER_ESP,IA32_SYSENTER_EIP, IA32_PERF_GLOBAL_CTRL, IA32_PAT, IA32_EFER。 VM-Execution control filelds：包括page fault控制，I/O位图地址，CR3目标控制，异常位图，pin-based运行控制(异步事件)，processor-based运行控制(同步事件)。这个域可以设置哪些指令触发VM-Exit。触发VM-Exit的指令分为无条件指令和有条件指令，这里设置的是有条件指令。（SDM 24.6） VM-entry contorl filelds：包括‘vm-entry控制’，‘vm-entry MSR控制’和‘VM-Entry事件注入’。（SDM 24.8） VM-exit control filelds：包括’VM-Exit控制’，’VM-Exit MSR控制’。(SDM 24.7) VM退出信息：这个域保存VM-Exit退出时的信息，并且描述原因。(SDM 24.9) 有了VMCS结构后，对虚拟机的控制就是读写VMCS结构。后面对VCPU设置中断，检查状态实际上都是在读写VMCS结构。在vmx.c文件给出了intel定义的VMCS结构的内容。 struct __packed vmcs12 CPU 虚拟化创建VM12345678910111213141516171819virt/kvm/kvm_main.c: (有所省略)static int kvm_dev_ioctl_create_vm(void)&#123; int fd; struct kvm *kvm; kvm = kvm_create_vm(type); if (IS_ERR(kvm)) return PTR_ERR(kvm); r = kvm_coalesced_mmio_init(kvm); r = get_unused_fd_flags(O_CLOEXEC); /*生成kvm-vm控制文件*/ file = anon_inode_getfile(&quot;kvm-vm&quot;, &amp;kvm_vm_fops, kvm, O_RDWR); return fd;&#125; 调用了函数kvm_create_vm，然后是创建一个文件，这个文件的作用是提供对vm的io_ctl控制。 12345678910111213141516171819202122232425262728293031virt/kvm/kvm_main.c:(简略)static struct kvm *kvm_create_vm(void)&#123; int r, i;----&gt; struct kvm *kvm = kvm_arch_create_vm(); /*设置kvm的mm结构为当前进程的mm,然后引用计数为1*/----&gt; kvm-&gt;mm = current-&gt;mm;----&gt; kvm_eventfd_init(kvm); mutex_init(&amp;kvm-&gt;lock); mutex_init(&amp;kvm-&gt;irq_lock); mutex_init(&amp;kvm-&gt;slots_lock); refcount_set(&amp;kvm-&gt;users_count, 1); INIT_LIST_HEAD(&amp;kvm-&gt;devices); INIT_HLIST_HEAD(&amp;kvm-&gt;irq_ack_notifier_list); r = kvm_arch_init_vm(kvm, type); r = hardware_enable_all() for (i = 0; i &lt; KVM_NR_BUSES; i++) &#123; rcu_assign_pointer(kvm-&gt;buses[i],----&gt; kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL)); &#125; kvm_init_mmu_notifier(kvm); /*把kvm链表加入总链表*/ list_add(&amp;kvm-&gt;vm_list, &amp;vm_list); return kvm;&#125; 可以看到，这个函数首先是申请一个kvm结构。然后执行初始化工作。初始化第一步是把kvm的mm结构设置为当前进程的mm。我们知道，mm结构反应了整个进程的内存使用情况，也包括进程使用的页目录信息。然后是初始化io bus和eventfd。这两者和设备io有关。最后把kvm加入到一个全局链表头。通过这个链表头，可以遍历所有的vm虚拟机。 创建VCPU创建VM之后，就是创建VCPU。 123456789101112131415161718192021222324252627282930313233343536373839404142434445virt/kvm/kvm_main.c:static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)&#123; int r; struct kvm_vcpu *vcpu, *v; /*调用相关cpu的vcpu_create 通过arch/x86/x86.c 进入vmx.c*/----&gt; vcpu = kvm_arch_vcpu_create(kvm, id); /*调用相关cpu的vcpu_setup*/ r = kvm_arch_vcpu_setup(vcpu); /*判断是否达到最大cpu个数*/ mutex_lock(&amp;kvm-&gt;lock); if (atomic_read(&amp;kvm-&gt;online_vcpus) == KVM_MAX_VCPUS) &#123; r = -EINVAL; goto vcpu_destroy; &#125;----&gt; kvm-&gt;created_vcpus++; mutex_unlock(&amp;kvm-&gt;lock); /*生成kvm-vcpu控制文件*/ /* Now it&apos;s all set up, let userspace reach it */----&gt; kvm_get_kvm(kvm); r = create_vcpu_fd(vcpu); kvm_get_kvm(kvm); r = create_vcpu_fd(vcpu); if (r &lt; 0) &#123; kvm_put_kvm(kvm); goto unlock_vcpu_destroy; &#125; kvm-&gt;vcpus[atomic_read(&amp;kvm-&gt;online_vcpus)] = vcpu; /* * Pairs with smp_rmb() in kvm_get_vcpu. Write kvm-&gt;vcpus * before kvm-&gt;online_vcpu&apos;s incremented value. */ smp_wmb(); atomic_inc(&amp;kvm-&gt;online_vcpus); mutex_unlock(&amp;kvm-&gt;lock); kvm_arch_vcpu_postcreate(vcpu);&#125; 从代码可见，分别调用相关cpu提供的vcpu_create和vcpu_setup来完成vcpu创建。 12345678910111213141516171819202122232425262728293031323334353637383940arch/x86/kvm/vmx.c:static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)&#123; int err; /*申请一个vmx结构*/ struct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL); int cpu; err = kvm_vcpu_init(&amp;vmx-&gt;vcpu, kvm, id); /*申请guest的msrs,host的msrs*/ vmx-&gt;guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL); vmx-&gt;host_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL); /*申请一个vmcs结构*/ err = alloc_loaded_vmcs(&amp;vmx-&gt;vmcs01); cpu = get_cpu(); vmx_vcpu_load(&amp;vmx-&gt;vcpu, cpu); /*设置vcpu为实模式，设置各种寄存器*/ err = vmx_vcpu_setup(vmx); vmx_vcpu_put(&amp;vmx-&gt;vcpu); put_cpu(); /*为中断分配slot，当虚拟机访问中断的时候，会map到vmcs中的相应地址中*/ if (cpu_need_virtualize_apic_accesses(&amp;vmx-&gt;vcpu)) &#123; err = alloc_apic_access_page(kvm); if (err) goto free_vmcs; &#125; if (enable_ept &amp;&amp; !enable_unrestricted_guest) &#123; err = init_rmode_identity_map(kvm); &#125; if (nested) nested_vmx_setup_ctls_msrs(&amp;vmx-&gt;nested.msrs, kvm_vcpu_apicv_active(&amp;vmx-&gt;vcpu)); vmx-&gt;msr_ia32_feature_control_valid_bits = FEATURE_CONTROL_LOCKED;&#125; 首先申请一个vcpu_vmx结构，然后初始化vcpu_vmx。MSR寄存器是cpu模式寄存器，所以要分别为guest 和host申请页面，这个页面要保存MSR寄存器的信息。然后申请一个vmcs结构。然后调用vmx_vcpu_setup设置vcpu工作在实模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293arch/x86/kvm/vmx.c:static int vmx_vcpu_setup(struct vcpu_vmx *vmx)&#123; /* Control */ vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx)) vmx-&gt;hv_deadline_tsc = -1; vmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx)); if (cpu_has_secondary_exec_ctrls()) &#123; vmx_compute_secondary_exec_control(vmx); vmcs_write32(SECONDARY_VM_EXEC_CONTROL, vmx-&gt;secondary_exec_control); &#125; if (kvm_vcpu_apicv_active(&amp;vmx-&gt;vcpu)) &#123; vmcs_write64(EOI_EXIT_BITMAP0, 0); vmcs_write64(EOI_EXIT_BITMAP1, 0); vmcs_write64(EOI_EXIT_BITMAP2, 0); vmcs_write64(EOI_EXIT_BITMAP3, 0); vmcs_write16(GUEST_INTR_STATUS, 0); vmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR); vmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&amp;vmx-&gt;pi_desc))); &#125; if (!kvm_pause_in_guest(vmx-&gt;vcpu.kvm)) &#123; vmcs_write32(PLE_GAP, ple_gap); vmx-&gt;ple_window = ple_window; vmx-&gt;ple_window_dirty = true; &#125; vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0); vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0); vmcs_write32(CR3_TARGET_COUNT, 0); /* 22.2.1 */ vmcs_write16(HOST_FS_SELECTOR, 0); /* 22.2.4 */ vmcs_write16(HOST_GS_SELECTOR, 0); /* 22.2.4 */ vmx_set_constant_host_state(vmx); vmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */ vmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */ if (cpu_has_vmx_vmfunc()) vmcs_write64(VM_FUNCTION_CONTROL, 0); vmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0); vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0); vmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx-&gt;msr_autoload.host.val)); vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0); vmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx-&gt;msr_autoload.guest.val)); if (vmcs_config.vmentry_ctrl &amp; VM_ENTRY_LOAD_IA32_PAT) vmcs_write64(GUEST_IA32_PAT, vmx-&gt;vcpu.arch.pat); for (i = 0; i &lt; ARRAY_SIZE(vmx_msr_index); ++i) &#123; u32 index = vmx_msr_index[i]; u32 data_low, data_high; int j = vmx-&gt;nmsrs; if (rdmsr_safe(index, &amp;data_low, &amp;data_high) &lt; 0) continue; if (wrmsr_safe(index, data_low, data_high) &lt; 0) continue; vmx-&gt;guest_msrs[j].index = i; vmx-&gt;guest_msrs[j].data = 0; vmx-&gt;guest_msrs[j].mask = -1ull; ++vmx-&gt;nmsrs; &#125; vmx-&gt;arch_capabilities = kvm_get_arch_capabilities(); vm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl); /* 22.2.1, 20.8.1 */ vm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl); vmx-&gt;vcpu.arch.cr0_guest_owned_bits = X86_CR0_TS; vmcs_writel(CR0_GUEST_HOST_MASK, ~X86_CR0_TS); set_cr4_guest_host_mask(vmx); if (vmx_xsaves_supported()) vmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP); if (enable_pml) &#123; vmcs_write64(PML_ADDRESS, page_to_phys(vmx-&gt;pml_pg)); vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1); &#125; if (cpu_has_vmx_encls_vmexit()) vmcs_write64(ENCLS_EXITING_BITMAP, -1ull);&#125; 这个函数到这里之所以列这么而详细，其实因为也不是很确定需要保留那几个，那就索性加深下印象吧，记住Kernel对虚拟机VT-X是如何操作的——读写VMCS结构体。一堆的寄存器和控制信息，具体的都在SDM Vol3 第24章里面描述的。只重点聊下其中的几个地方：设置CPU_BASED控制器（VMCS的一部分）；GUEST中断状态寄存器；CR3,CR0 以及各种段选寄存器CS, DS, ES；之后，要保存host的MSR寄存器的值到前面分配的guest_msrs页面; Guest PML地址等等…… VCPU运行推动vcpu运行，启动虚拟机开始运行，主要在vcpu_run函数执行。 12345678910111213141516171819202122232425262728293031323334353637383940arch/x86/kvm/x86.c:static int vcpu_run(struct kvm_vcpu *vcpu)&#123; int r; struct kvm *kvm = vcpu-&gt;kvm; for (;;) &#123; /*vcpu进入guest模式*/ if (kvm_vcpu_running(vcpu)) &#123;----&gt; r = vcpu_enter_guest(vcpu); &#125; else &#123; r = vcpu_block(kvm, vcpu); &#125; kvm_clear_request(KVM_REQ_PENDING_TIMER, vcpu); /*检查是否有阻塞的时钟timer*/ if (kvm_cpu_has_pending_timer(vcpu)) kvm_inject_pending_timer_irqs(vcpu); /*检查是否有用户空间的中断注入*/ if (dm_request_for_irq_injection(vcpu) &amp;&amp; kvm_vcpu_ready_for_interrupt_injection(vcpu)) &#123; r = 0; vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN; ++vcpu-&gt;stat.request_irq_exits; break; &#125; kvm_check_async_pf_completion(vcpu); /*是否有阻塞的signal*/ if (signal_pending(current)) &#123; r = -EINTR; vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTR; ++vcpu-&gt;stat.signal_exits; break; &#125; /*执行一个调度*/ if (need_resched()) &#123; cond_resched(); &#125; &#125; 这里理解的关键是vcpu_enter_guest进入了Guest，然后一直是vcpu在运行，当退出这个函数的时候，虚拟机已经执行了VM-Exit指令，也就是说，已经退出了虚拟机，进入根模式了。退出之后，要检查退出的原因。如果有时钟中断发生，则插入一个时钟中断，如果是用户空间的中断发生，则退出原因要填写为KVM_EXIT_INTR。注意一点的是，对于导致退出的事件，vcpu_enter_guest函数里面已经处理了一部分，处理的是虚拟机本身运行导致退出的事件。虚拟机一旦退出后，执行vmx_handle_exit。比如虚拟机内部写磁盘io导致退出，就在vcpu_enter_guest里面处理（只是设置了退出的原因为io，并没有真正执行io）。KVM是如何知道退出的原因的？这个就是vmcs结构的作用了，vmcs结构里面有VM-Exit的信息。退出VM之后，如果内核没有完成处理，那么要退出内核到QEMU进程。然后是QEMU进程要处理.后面io处理时，我们再看下QEMU的处理过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768arch/x86/kvm/x86.carch/x86/kvm/x86.c:static int vcpu_enter_guest(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)&#123; r = kvm_mmu_reload(vcpu); preempt_disable(); kvm_x86_ops-&gt;prepare_guest_switch(vcpu); /* * Disable IRQs before setting IN_GUEST_MODE. Posted interrupt * IPI are then delayed after guest entry, which ensures that they * result in virtual interrupt delivery. */ local_irq_disable(); vcpu-&gt;mode = IN_GUEST_MODE; /* * This handles the case where a posted interrupt was * notified with kvm_vcpu_kick. */ if (kvm_lapic_enabled(vcpu) &amp;&amp; vcpu-&gt;arch.apicv_active) kvm_x86_ops-&gt;sync_pir_to_irr(vcpu); kvm_load_guest_xcr0(vcpu); trace_kvm_entry(vcpu-&gt;vcpu_id); if (lapic_timer_advance_ns) wait_lapic_expire(vcpu); guest_enter_irqoff(); /* KVM故事的核心*/----&gt; kvm_x86_ops-&gt;run(vcpu); vcpu-&gt;arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc()); vcpu-&gt;mode = OUTSIDE_GUEST_MODE; smp_wmb(); kvm_put_guest_xcr0(vcpu); kvm_before_interrupt(vcpu); kvm_x86_ops-&gt;handle_external_intr(vcpu); kvm_after_interrupt(vcpu); ++vcpu-&gt;stat.exits; guest_exit_irqoff(); local_irq_enable(); preempt_enable(); /* * Profile KVM exit RIPs: */ if (unlikely(prof_on == KVM_PROFILING)) &#123; unsigned long rip = kvm_rip_read(vcpu); profile_hit(KVM_PROFILING, (void *)rip); &#125; kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); kvm_lapic_sync_from_vapic(vcpu); vcpu-&gt;arch.gpa_available = false; /* KVM故事兜底的包袱*/----&gt; r = kvm_x86_ops-&gt;handle_exit(vcpu);&#125; 首先要装载mmu，然后注入事件，像中断，异常什么的。然后调用cpu架构相关的run函数(vmx_vcpu_run)，这个函数里面调用__vmx_vcpu_run这是一个用汇编实现的函数在vmx/vmenter.S里面，用来进入虚拟机以及指定从虚拟机退出的执行地址。最后调用cpu的handle_exit，用来从vmcs读取退出的信息。下面展开函数vmx_vcpu_run，这个函数实在是……需要对照SDM一行一行的看，已无力分析，那就看原文中的注释简单的了解个大概就好了，他日如果有机会做这部分code，定努力哈哈哈~~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154arch/x86/kvm/vmx.c:static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)&#123; struct vcpu_vmx *vmx = to_vmx(vcpu); unsigned long cr3, cr4, evmcs_rsp; /* Record the guest&apos;s net vcpu time for enforced NMI injections. */ if (unlikely(!enable_vnmi &amp;&amp; vmx-&gt;loaded_vmcs-&gt;soft_vnmi_blocked)) vmx-&gt;loaded_vmcs-&gt;entry_time = ktime_get(); /* Don&apos;t enter VMX if guest state is invalid, let the exit handler start emulation until we arrive back to a valid state */ if (vmx-&gt;emulation_required) return; if (vmx-&gt;ple_window_dirty) &#123; vmx-&gt;ple_window_dirty = false; vmcs_write32(PLE_WINDOW, vmx-&gt;ple_window); &#125; if (vmx-&gt;nested.need_vmcs12_sync) &#123; /* * hv_evmcs may end up being not mapped after migration (when * L2 was running), map it here to make sure vmcs12 changes are * properly reflected. */ if (vmx-&gt;nested.enlightened_vmcs_enabled &amp;&amp; !vmx-&gt;nested.hv_evmcs) nested_vmx_handle_enlightened_vmptrld(vcpu, false); if (vmx-&gt;nested.hv_evmcs) &#123; copy_vmcs12_to_enlightened(vmx); /* All fields are clean */ vmx-&gt;nested.hv_evmcs-&gt;hv_clean_fields |= HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL; &#125; else &#123; copy_vmcs12_to_shadow(vmx); &#125; vmx-&gt;nested.need_vmcs12_sync = false; &#125; if (test_bit(VCPU_REGS_RSP, (unsigned long *)&amp;vcpu-&gt;arch.regs_dirty)) vmcs_writel(GUEST_RSP, vcpu-&gt;arch.regs[VCPU_REGS_RSP]); if (test_bit(VCPU_REGS_RIP, (unsigned long *)&amp;vcpu-&gt;arch.regs_dirty)) vmcs_writel(GUEST_RIP, vcpu-&gt;arch.regs[VCPU_REGS_RIP]); cr3 = __get_current_cr3_fast(); if (unlikely(cr3 != vmx-&gt;loaded_vmcs-&gt;host_state.cr3)) &#123; vmcs_writel(HOST_CR3, cr3); vmx-&gt;loaded_vmcs-&gt;host_state.cr3 = cr3; &#125; cr4 = cr4_read_shadow(); if (unlikely(cr4 != vmx-&gt;loaded_vmcs-&gt;host_state.cr4)) &#123; vmcs_writel(HOST_CR4, cr4); vmx-&gt;loaded_vmcs-&gt;host_state.cr4 = cr4; &#125; atomic_switch_perf_msrs(vmx); vmx_update_hv_timer(vcpu); /* * If this vCPU has touched SPEC_CTRL, restore the guest&apos;s value if * it&apos;s non-zero. Since vmentry is serialising on affected CPUs, there * is no need to worry about the conditional branch over the wrmsr * being speculatively taken. */ x86_spec_ctrl_set_guest(vmx-&gt;spec_ctrl, 0); vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched; evmcs_rsp = static_branch_unlikely(&amp;enable_evmcs) ? (unsigned long)&amp;current_evmcs-&gt;host_rsp : 0; //大概kernel 4.19之后的版本，这个部分汇编被已到了__vmx_vcpu_run asm( /* Store host registers */ &quot;push %%&quot; _ASM_DX &quot;; push %%&quot; _ASM_BP &quot;;&quot; ...... /* Avoid VMWRITE when Enlightened VMCS is in use */ &quot;test %%&quot; _ASM_SI &quot;, %%&quot; _ASM_SI &quot; \n\t&quot; ...... /* Reload cr2 if changed */ &quot;mov %c[cr2](%0), %%&quot; _ASM_AX &quot; \n\t&quot; ...... /* Check if vmlaunch of vmresume is needed */ &quot;cmpl $0, %c[launched](%0) \n\t&quot; /* Load guest registers. Don&apos;t clobber flags. */ &quot;mov %c[rax](%0), %%&quot; _ASM_AX &quot; \n\t&quot; ...... /* Enter guest mode */ &quot;jne 1f \n\t&quot; __ex(&quot;vmlaunch&quot;) &quot;\n\t&quot; &quot;jmp 2f \n\t&quot; &quot;1: &quot; __ex(&quot;vmresume&quot;) &quot;\n\t&quot; &quot;2: &quot; /* Save guest registers, load host registers, keep flags */ &quot;mov %0, %c[wordsize](%%&quot; _ASM_SP &quot;) \n\t&quot; &quot;pop %0 \n\t&quot; ...... /* * Clear host registers marked as clobbered to prevent * speculative use. */ [rdx]&quot;i&quot;(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])), ); /* * We do not use IBRS in the kernel. If this vCPU has used the * SPEC_CTRL MSR it may have left it on; save the value and * turn it off. */ if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))) vmx-&gt;spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL); x86_spec_ctrl_restore_host(vmx-&gt;spec_ctrl, 0); /* Eliminate branch target predictions from guest mode */ vmexit_fill_RSB(); /* All fields are clean at this point */ if (static_branch_unlikely(&amp;enable_evmcs)) current_evmcs-&gt;hv_clean_fields |= HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL; /* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */ if (vmx-&gt;host_debugctlmsr) update_debugctlmsr(vmx-&gt;host_debugctlmsr); /* * The sysexit path does not restore ds/es, so we must set them to * a reasonable value ourselves. */ loadsegment(ds, __USER_DS); loadsegment(es, __USER_DS); vcpu-&gt;arch.regs_avail = ~((1 &lt;&lt; VCPU_REGS_RIP) | (1 &lt;&lt; VCPU_REGS_RSP) | (1 &lt;&lt; VCPU_EXREG_RFLAGS) | (1 &lt;&lt; VCPU_EXREG_PDPTR) | (1 &lt;&lt; VCPU_EXREG_SEGMENTS) | (1 &lt;&lt; VCPU_EXREG_CR3)); vcpu-&gt;arch.regs_dirty = 0; vmx-&gt;exit_reason = vmx-&gt;fail ? 0xdead : vmcs_read32(VM_EXIT_REASON); if (vmx-&gt;fail || (vmx-&gt;exit_reason &amp; VMX_EXIT_REASONS_FAILED_VMENTRY)) return; vmx-&gt;loaded_vmcs-&gt;launched = 1; vmx-&gt;idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD); vmx_complete_atomic_exit(vmx); vmx_recover_nmi_blocking(vmx); vmx_complete_interrupts(vmx); &#125; ‘中断’从来都是很意外的出现，我们分析也不例外没有过度令补丁的——我们简单看下中断的注入函数。 12345678910111213141516171819202122232425arch/x86/kvm/vmx.c:static void vmx_inject_irq(struct kvm_vcpu *vcpu)&#123; ++vcpu-&gt;stat.irq_injections; if (vmx-&gt;rmode.vm86_active) &#123; int inc_eip = 0; if (vcpu-&gt;arch.interrupt.soft) inc_eip = vcpu-&gt;arch.event_exit_inst_len; if (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_ kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu); return; &#125; intr = irq | INTR_INFO_VALID_MASK; if (vcpu-&gt;arch.interrupt.soft) &#123; intr |= INTR_TYPE_SOFT_INTR; vmcs_write32(VM_ENTRY_INSTRUCTION_LEN, vmx-&gt;vcpu.arch.event_exit_inst_len); &#125; else intr |= INTR_TYPE_EXT_INTR; vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr); vmx_clear_hlt(vcpu);&#125; 可以看到，实际上注入中断就是写vmcs里面的VM_ENTRY_INTR_INFO_FIELD这个域。然后在vcpu的run函数里面设置cpu进入非根模式，vcpu会自动检查vmcs结构，然后注入中断，这是硬件自动完成的工作。而处理中断，这就是另外一个故事了，不知道后面有没有篇幅和时间继续看下吧。:p 调度KVM只是个内核模块，虚拟机实际上是运行在QEMU的进程上下文中。所以VCPU的调度实际上直接使用了LINUX自身的调度机制。也就是linux自身的进程调度机制。QEMU可以设置每个VCPU都运作在一个线程中。 123456789101112131415static void qemu_kvm_start_vcpu(CPUState *cpu)&#123; char thread_name[VCPU_THREAD_NAME_SIZE]; cpu-&gt;thread = g_malloc0(sizeof(QemuThread)); cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond)); qemu_cond_init(cpu-&gt;halt_cond); snprintf(thread_name, VCPU_THREAD_NAME_SIZE, &quot;CPU %d/KVM&quot;, cpu-&gt;cpu_index); qemu_thread_create(cpu-&gt;thread, thread_name, qemu_kvm_cpu_thread_fn, cpu, QEMU_THREAD_JOINABLE); while (!cpu-&gt;created) &#123; qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex); &#125;&#125; 从Qemu的代码，看到Qemu启动了一个kvm_cpu_thread线程。其主线程函数qemu_kvm_cpu_thread_fn内循环调用kvm_cpu_exec函数，前面已经有一篇文章KVM 虚拟化原理2— QEMU启动过程大概了解了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int kvm_cpu_exec(CPUState *env)&#123; do &#123; MemTxAttrs attrs; if (cpu-&gt;kvm_vcpu_dirty) &#123; kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE); cpu-&gt;kvm_vcpu_dirty = false; &#125; kvm_arch_pre_run(cpu, run); if (cpu-&gt;exit_request) &#123; qemu_cpu_kick_self(); &#125;----&gt; run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0); attrs = kvm_arch_post_run(cpu, run);----&gt; switch (run-&gt;exit_reason) &#123; case KVM_EXIT_IO: DPRINTF(&quot;handle_io\n&quot;); /* Called outside BQL */ kvm_handle_io(run-&gt;io.port, attrs, (uint8_t *)run + run-&gt;io.data_offset, run-&gt;io.direction, run-&gt;io.size, run-&gt;io.count); ret = 0; break; case KVM_EXIT_MMIO: DPRINTF(&quot;handle_mmio\n&quot;); /* Called outside BQL */ address_space_rw(&amp;address_space_memory, run-&gt;mmio.phys_addr, attrs, run-&gt;mmio.data, run-&gt;mmio.len, run-&gt;mmio.is_write); ret = 0; break; case KVM_EXIT_IRQ_WINDOW_OPEN: DPRINTF(&quot;irq_window_open\n&quot;); ret = EXCP_INTERRUPT; break; case KVM_EXIT_SHUTDOWN: DPRINTF(&quot;shutdown\n&quot;); qemu_system_reset_request(); ret = EXCP_INTERRUPT; break; case KVM_EXIT_UNKNOWN: fprintf(stderr, &quot;KVM: unknown exit, hardware reason %&quot; PRIx64 &quot;\n&quot;, (uint64_t)run-&gt;hw.hardware_exit_reason); ret = -1; break; case KVM_EXIT_INTERNAL_ERROR: ret = kvm_handle_internal_error(cpu, run); break; case KVM_EXIT_SYSTEM_EVENT: switch (run-&gt;system_event.type) &#123; case KVM_SYSTEM_EVENT_SHUTDOWN: qemu_system_shutdown_request(); ret = EXCP_INTERRUPT; break; &#125; &#125; while (ret == 0);&#125; 这个函数就是调用了前面分析过的KVM_RUN。回顾一下前面的分析，KVM_RUN就进入了虚拟机，如果从虚拟化退出到这里，那么Qemu要处理退出的事件。这些事件，可能是因为io引起的KVM_EXIT_IO，也可能是内部错误引起的KVM_EXIT_INTERNAL_ERROR。如果事件没有被完善处理，那么要停止虚拟机。 中断如何向vcpu注入中断？是通过向真实CPU模拟注入NMI（非可屏蔽中断）中断来实现。KVM要模拟一个中断控制芯片，这个是通过KVM_CREATE_IRQCHIP来实现的。然后，如果Qemu想注入一个中断，就通过KVM_IRQ_LINE实现。这个所谓中断控制芯片只是在内存中存在的结构，kvm通过软件方式模拟了中断的机制。KVM_CREATE_IRQCHIP实际上调用了kvm_pic_init这个函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354qemu-2.5.1/kvm-all.c:static int kvm_init(MachineState *ms)&#123;...... if (machine_kernel_irqchip_allowed(ms)) &#123;----&gt; kvm_irqchip_create(ms, s); &#125; kvm_state = s; s-&gt;memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add; s-&gt;memory_listener.listener.eventfd_del = kvm_mem_ioeventfd_del; s-&gt;memory_listener.listener.coalesced_mmio_add = kvm_coalesce_mmio_region; s-&gt;memory_listener.listener.coalesced_mmio_del = kvm_uncoalesce_mmio_region; kvm_memory_listener_register(s, &amp;s-&gt;memory_listener, &amp;address_space_memory, 0); memory_listener_register(&amp;kvm_io_listener, &amp;address_space_io); s-&gt;many_ioeventfds = kvm_check_many_ioeventfds(); cpu_interrupt_handler = kvm_handle_interrupt;&#125;qemu-2.5.1/kvm-all.c:static void kvm_irqchip_create(MachineState *machine, KVMState *s)&#123; int ret; /* First probe and see if there&apos;s a arch-specific hook to create the * in-kernel irqchip for us */ ret = kvm_arch_irqchip_create(s); if (ret == 0) &#123; ret = kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP); &#125; if (ret &lt; 0) &#123; fprintf(stderr, &quot;Create kernel irqchip failed: %s\n&quot;, strerror(-ret)); exit(1); &#125; kvm_kernel_irqchip = true; /* If we have an in-kernel IRQ chip then we must have asynchronous * interrupt delivery (though the reverse is not necessarily true) */ kvm_async_interrupts_allowed = true; kvm_halt_in_kernel_allowed = true; kvm_init_irq_routing(s); s-&gt;gsimap = g_hash_table_new(g_direct_hash, g_direct_equal);&#125; IRQ的初始化就在kvm_init中，通过调用KVM_CREATE_IRQCHIP就搞定。而KVM_IRQ_LINE实际上依旧是通过IOCTL在kernel中完成的。进到Kernel里面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445kvm-all.cint kvm_set_irq(KVMState *s, int irq, int level)&#123; struct kvm_irq_level event; int ret; assert(kvm_async_interrupts_enabled()); event.level = level; event.irq = irq;--&gt; ret = kvm_vm_ioctl(s, s-&gt;irq_set_ioctl, &amp;event); if (ret &lt; 0) &#123; perror(&quot;kvm_set_irq&quot;); abort(); &#125; return (s-&gt;irq_set_ioctl == KVM_IRQ_LINE) ? 1 : event.status;&#125;--------------------------------------------linux-stable/virt/kvm/irqchip.c:int kvm_set_irq(struct kvm *kvm, int irq_source_id, int irq, int level)&#123; struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS]; int ret = -1, i, idx; trace_kvm_set_irq(irq, level, irq_source_id); /* Not possible to detect if the guest uses the PIC or the * IOAPIC. So set the bit in both. The guest will ignore * writes to the unused one. */ idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu); i = kvm_irq_map_gsi(kvm, irq_set, irq); srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx); while (i--) &#123; int r;----&gt; r = irq_set[i].set(&amp;irq_set[i], kvm, irq_source_id, level, line_status); if (r &lt; 0) continue; ret = r + ((ret &lt; 0) ? 0 : ret); &#125; 从注释中可以看到，因为不能判断Guest使用的是PIC还是APIC，所以为每一个中断路由都设置中断。PIC就是传统的中断控制器8259，x86体系最初使用的中断控制器。后来，又推出了APIC，也就是高级中断控制器。APIC为支持多核架构做了更多的设计。实际上，在kvm模拟中，既有PIC的模拟，也有APIC的模拟。如果使用PIC的话，这里的这个set函数，其实就是kvm_pic_set_irq123456789101112131415161718arch/x86/kvm/i8259.cint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)&#123; int ret, irq_level; BUG_ON(irq &lt; 0 || irq &gt;= PIC_NUM_PINS); pic_lock(s); irq_level = __kvm_irq_line_state(&amp;s-&gt;irq_states[irq], irq_source_id, level); ret = pic_set_irq1(&amp;s-&gt;pics[irq &gt;&gt; 3], irq &amp; 7, irq_level); pic_update_irq(s); trace_kvm_pic_set_irq(irq &gt;&gt; 3, irq &amp; 7, s-&gt;pics[irq &gt;&gt; 3].elcr, s-&gt;pics[irq &gt;&gt; 3].imr, ret == 0); pic_unlock(s); return ret;&#125; 可以看到，前面申请的kvm_pic结构作为参数被引入。然后设置irq到这个结构的pic成员。12345678910111213141516arch/x86/kvm/i8259.c !!static void pic_update_irq(struct kvm_pic *s)&#123; int irq2, irq; irq2 = pic_get_irq(&amp;s-&gt;pics[1]); if (irq2 &gt;= 0) &#123; /* * if irq request by slave pic, signal master PIC */ pic_set_irq1(&amp;s-&gt;pics[0], 2, 1); pic_set_irq1(&amp;s-&gt;pics[0], 2, 0); &#125; irq = pic_get_irq(&amp;s-&gt;pics[0]); pic_irq_request(s-&gt;kvm, irq &gt;= 0);&#125; 此时调用irq_request，就是初始化中断芯片时候绑定的函数pic_irq_request。1234567891011121314151617181920212223242526272829arch/x86/kvm/i8259.c:void kvm_pic_update_irq(struct kvm_pic *s)&#123; pic_lock(s); pic_update_irq(s); pic_unlock(s);&#125;static void pic_unlock(struct kvm_pic *s) __releases(&amp;s-&gt;lock)&#123; bool wakeup = s-&gt;wakeup_needed; struct kvm_vcpu *vcpu; int i; s-&gt;wakeup_needed = false; spin_unlock(&amp;s-&gt;lock); if (wakeup) &#123; kvm_for_each_vcpu(i, vcpu, s-&gt;kvm) &#123; if (kvm_apic_accept_pic_intr(vcpu)) &#123; kvm_make_request(KVM_REQ_EVENT, vcpu);----&gt; kvm_vcpu_kick(vcpu); return; &#125; &#125; &#125;&#125; 可以看到irq_request之后会调用kvm_vcpu_kick。我们知道，对一个注入的中断来说，需要vcpu立即响应，但是在多核的架构下（smp），目的cpu可能正在运行，所以要提供一种机制停止目的cpu的运行，让它立即处理注入的中断。kvm_vcpu_kick就是给目的cpu发送一个处理器间中断(IPI)，让目的cpu停止运行。 1234567arch/alpha/kernel/smp.c:voidsmp_send_reschedule(int cpu)&#123; send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);&#125; 等VM-exit退出后，就接上了前文分析过的部分。VCPU再次进入虚拟机的时候，通过inject_pengding_event检查中断。这个检查的过程就发现了通过KVM_IRQ_LINE注入的中断，然后就是写vmcs结构了注入中断，已经分析过了。 VCPU的内存虚拟化在KMV初始化的时候，要检查是否支持vt里面的EPT扩展技术。如果支持，enable_ept这个变量置为1，然后设置tdp_enabled为1。TDP就是两维页表。为表述方便，给出kvm中下列名字的定义： GPA：guest机物理地址 GVA：guest机虚拟地址 HVA：host机虚拟地址 HPA：host机物理地址 虚拟机页表初始化在vcpu初始化的时候，要调用kvm_init_mmu来设置不同的内存虚拟化方式。1234567891011void kvm_init_mmu(struct kvm_vcpu *vcpu, bool reset_roots)&#123; ...... /*嵌套虚拟化，我们暂不考虑吧 */ if (mmu_is_nested(vcpu)) init_kvm_nested_mmu(vcpu); else if (tdp_enabled) init_kvm_tdp_mmu(vcpu); else init_kvm_softmmu(vcpu);&#125; 设置两种方式，一种是支持EPT的方式，另种是soft mmu，也就是影子页表的方式。在支持EPT的情况下，会调用init_kvm_tdp_mmu函数初始化MMU。在该函数中1234567891011121314151617181920212223242526272829303132333435363738394041424344arch/x86/kvm/mmu.c:static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)&#123; struct kvm_mmu *context = vcpu-&gt;arch.mmu; union kvm_mmu_role new_role = kvm_calc_tdp_mmu_root_page_role(vcpu, false); new_role.base.word &amp;= mmu_base_role_mask.word; if (new_role.as_u64 == context-&gt;mmu_role.as_u64) return; context-&gt;mmu_role.as_u64 = new_role.as_u64;---&gt; context-&gt;page_fault = tdp_page_fault; context-&gt;sync_page = nonpaging_sync_page; context-&gt;invlpg = nonpaging_invlpg; context-&gt;update_pte = nonpaging_update_pte;---&gt; context-&gt;shadow_root_level = kvm_x86_ops-&gt;get_tdp_level(vcpu); context-&gt;direct_map = true; context-&gt;set_cr3 = kvm_x86_ops-&gt;set_tdp_cr3; context-&gt;get_cr3 = get_cr3; context-&gt;get_pdptr = kvm_pdptr_read; context-&gt;inject_page_fault = kvm_inject_page_fault; if (!is_paging(vcpu)) &#123; context-&gt;nx = false; context-&gt;gva_to_gpa = nonpaging_gva_to_gpa; context-&gt;root_level = 0; &#125; else if (is_long_mode(vcpu)) &#123; context-&gt;nx = is_nx(vcpu); context-&gt;root_level = is_la57_mode(vcpu) ? PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL; reset_rsvds_bits_mask(vcpu, context); context-&gt;gva_to_gpa = paging64_gva_to_gpa; &#125; else if (is_pae(vcpu)) &#123; context-&gt;nx = is_nx(vcpu); context-&gt;root_level = PT32E_ROOT_LEVEL; reset_rsvds_bits_mask(vcpu, context); context-&gt;gva_to_gpa = paging64_gva_to_gpa; &#125; else &#123; context-&gt;nx = false; context-&gt;root_level = PT32_ROOT_LEVEL; reset_rsvds_bits_mask(vcpu, context); context-&gt;gva_to_gpa = paging32_gva_to_gpa; &#125; EPT初始化的内容挺多，还是挑几个喜闻乐见的聊下吧。kvm_x86_ops-&gt;get_tdp_level(vcpu)可以看出来EPT目前用的默认是4级页表，满足条件的会使用5级页表。vcpu-&gt;arch.walk_mmu.pagefault被初始化成tdp_page_fault。下面看下tdp_page_fault。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354arch/x86/kvm/mmu.c:static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code, bool prefault)&#123; kvm_pfn_t pfn; int r; int level; bool force_pt_level; /* 物理地址右移12位得到物理页框号(相对于虚拟机而言)*/ gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT; unsigned long mmu_seq; int write = error_code &amp; PFERR_WRITE_MASK; bool map_writable; if (page_fault_handle_page_track(vcpu, error_code, gfn)) return RET_PF_EMULATE; /*分配缓存池*/----&gt; r = mmu_topup_memory_caches(vcpu); if (r) return r; force_pt_level = !check_hugepage_cache_consistency(vcpu, gfn, PT_DIRECTORY_LEVEL);----&gt; level = mapping_level(vcpu, gfn, &amp;force_pt_level); if (likely(!force_pt_level)) &#123; if (level &gt; PT_DIRECTORY_LEVEL &amp;&amp; !check_hugepage_cache_consistency(vcpu, gfn, level)) level = PT_DIRECTORY_LEVEL; gfn &amp;= ~(KVM_PAGES_PER_HPAGE(level) - 1); &#125;----&gt; if (fast_page_fault(vcpu, gpa, level, error_code)) return RET_PF_RETRY; mmu_seq = vcpu-&gt;kvm-&gt;mmu_notifier_seq; smp_rmb();----&gt; if (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable)) return RET_PF_RETRY; if (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &amp;r)) return r; spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock); if (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq)) goto out_unlock; if (make_mmu_pages_available(vcpu) &lt; 0) goto out_unlock; if (likely(!force_pt_level)) transparent_hugepage_adjust(vcpu, &amp;gfn, &amp;pfn, &amp;level);----&gt; r = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault); spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);&#125; 该函调用mmu_topup_memory_caches函数进行缓存池的分配，解释是为了避免在运行时分配空间失败，这里提前分配足额的空间，便于运行时使用。然后调用mapping_level函数判断当前gfn对应的slot是否可用。为什么要进行这样的判断呢？在if内部可以看到是获取level，如果当前GPN对应的slot可用，我们就可以获取分配slot的pagesize，然后得到最低级的level，比如如果是2M的页，那么level就为2，为4K的页，level就为1.接着调用了fast_page_fault尝试快速处理violation，只有当GFN对应的物理页存在且violation是由读写操作引起的，才可以使用快速处理。 假设这里不能快速处理，那么到后面就调用try_async_pf函数根据GFN获取对应的PFN，这个过程具体来说需要首先获取GFN对应的slot，转化成HVA，接着就是正常的HOST地址翻译的过程了，如果HVA对应的地址并不在内存中，还需要HOST自己处理缺页中断。 接着调用transparent_hugepage_adjust对level和gfn、pfn做出调整。紧着着就调用了__direct_map函数，该函数是构建页表的核心函数： 1234567891011121314151617181920212223242526272829303132333435363738arch/x86/kvm/mmu.c:static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write, int map_writable, int level, gfn_t gfn, pfn_t pfn, bool prefault)&#123; struct kvm_shadow_walk_iterator iterator; struct kvm_mmu_page *sp; int emulate = 0; gfn_t pseudo_gfn; for_each_shadow_entry(vcpu, (u64)gfn &lt;&lt; PAGE_SHIFT, iterator) &#123; /*如果需要映射的level正是iterator.level，那么*/ if (iterator.level == level) &#123; mmu_set_spte(vcpu, iterator.sptep, ACC_ALL, write, &amp;emulate, level, gfn, pfn, prefault, map_writable); direct_pte_prefetch(vcpu, iterator.sptep); ++vcpu-&gt;stat.pf_fixed; break; &#125; /*判断当前entry指向的页表是否存在，不存在的话需要建立*/ if (!is_shadow_present_pte(*iterator.sptep)) &#123; /*iterator.addr是客户物理地址的物理页帧*/ u64 base_addr = iterator.addr; /*确保对应层级的偏移部分为0，如level=1，则baseaddr的低12位就清零*/ base_addr &amp;= PT64_LVL_ADDR_MASK(iterator.level);// /*得到物理页框号*/ pseudo_gfn = base_addr &gt;&gt; PAGE_SHIFT; /* 获得一个page */----&gt; sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr, iterator.level - 1, 1, ACC_ALL, iterator.sptep); /*设置页表项的sptep指针指向sp*/ link_shadow_page(iterator.sptep, sp); &#125; &#125; return emulate;&#125; 首先进入的便是for_each_shadow_entry，用于根据GFN遍历EPT页表的对应项，这点后面会详细解释。循环中首先判断entry的level和请求的level是否相等，相等说明该entry处引起的violation，即该entry对应的下级页或者页表不在内存中，或者直接为NULL。 如果level不相等，就进入后面的if判断，这是判断该entry对应的下一级页是否存在，如果不存在需要重新构建，存在就直接向后遍历，即对比二级页表中的entry。整个处理流程就是这样，根据GPA组逐层查找EPT，最终level相等的时候，就根据最后一层的索引定位一个PTE，该PTE应该指向的就是GFN对应的PFN，那么这时候set spite就可以了。最好的情况就是最后一级页表中的entry指向的物理页被换出外磁盘，这样只需要处理一次EPT violation，而如果在初始全部为空的状态下访问，每一级的页表都需要重新构建，则需要处理四次EPTviolation，发生4次VM-exit。 构建页表的过程即在level相等之前，发现需要的某一级的页表项为NULL，就调用kvm_mmu_get_page获取一个page，然后调用link_shadow_page设置页表项指向page， 看下kvm_mmu_get_page函数:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778arch/x86/kvm/mmu.c:static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu, gfn_t gfn, gva_t gaddr, unsigned level, int direct, unsigned access, u64 *parent_pte)&#123; union kvm_mmu_page_role role; unsigned quadrant; struct kvm_mmu_page *sp; bool need_sync = false; role = vcpu-&gt;arch.mmu.base_role; role.level = level; role.direct = direct; if (role.direct) role.cr4_pae = 0; role.access = access; /*quadrant 对应页表项的索引，来自于GPA*/ if (!vcpu-&gt;arch.mmu.direct_map &amp;&amp; vcpu-&gt;arch.mmu.root_level &lt;= PT32_ROOT_LEVEL) &#123; quadrant = gaddr &gt;&gt; (PAGE_SHIFT + (PT64_PT_BITS * level)); quadrant &amp;= (1 &lt;&lt; ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1; role.quadrant = quadrant; &#125; /*根据gfn遍历KVM维护的mmu_page_hash哈希链表*/---&gt; for_each_gfn_sp(vcpu-&gt;kvm, sp, gfn) &#123; /**/ if (is_obsolete_sp(vcpu-&gt;kvm, sp)) continue; if (!need_sync &amp;&amp; sp-&gt;unsync) need_sync = true; if (sp-&gt;role.word != role.word) continue; if (sp-&gt;unsync &amp;&amp; kvm_sync_page_transient(vcpu, sp)) break; /*设置sp-&gt;parent_pte=parent_pte*/ mmu_page_add_parent_pte(vcpu, sp, parent_pte); if (sp-&gt;unsync_children) &#123; kvm_make_request(KVM_REQ_MMU_SYNC, vcpu); kvm_mmu_mark_parents_unsync(sp); &#125; else if (sp-&gt;unsync) kvm_mmu_mark_parents_unsync(sp); __clear_sp_write_flooding_count(sp); trace_kvm_mmu_get_page(sp, false); return sp; &#125; /*如果根据页框号没有遍历到合适的page，就需要重新创建一个页*/ ++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;--&gt; sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct); if (!sp) return sp; /*设置其对应的客户机物理页框号*/ sp-&gt;gfn = gfn; sp-&gt;role = role; /*把该也作为一个节点加入到哈希表相应的链表汇总*/ hlist_add_head(&amp;sp-&gt;hash_link, &amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]); if (!direct) &#123; if (rmap_write_protect(vcpu-&gt;kvm, gfn)) kvm_flush_remote_tlbs(vcpu-&gt;kvm); if (level &gt; PT_PAGE_TABLE_LEVEL &amp;&amp; need_sync) kvm_sync_pages(vcpu, gfn); account_shadowed(vcpu-&gt;kvm, gfn); &#125; sp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen; /*暂时对所有表项清零*/ init_shadow_page_table(sp); trace_kvm_mmu_get_page(sp, true); return sp;&#125; 一个kvm_mmu_page对应于一个kvm_mmu_page_role，kvm_mmu_page_role记录对应page的各种属性。下面for_each_gfn_sp是一个遍历链表的宏定义，KVM为了根据GFN查找对应的kvm_mmu_page，用一个HASH数组记录所有的kvm_mmu_page，每一个表项都是一个链表头，即根据GFN获取到的HASH值相同的，位于一个链表中。这也是HASH表处理冲突常见方法。 如果在对应链表中找到一个合适的页（怎么算是合适暂且不清楚），就直接利用该页，否则需要调用kvm_mmu_alloc_page函数重新申请一个页，主要是申请一个kvm_mmu_page结构和一个存放表项的page，这就用到了之前我们说过的三种缓存，不过这里只用到了两个，分别是mmu_page_header_cache和mmu_page_cache。这样分配好后，把对应的kvm_mmu_page作为一个节点加入到全局的HASH链表中，然后对数组项清零，最后返回sp. linux为不同的cpu提供不同的页表层级。64位cpu使用了四级页表PT64_ROOT_4LEVEL，同时设定页表根地址为无效,此时页表尚未分配。何时真正分配vcpu的页表？是在vcpu_enter_guest的开始位置，通过调用kvm_mmu_reload实现。1234567arch/x86/kvm/mmu.h:static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)&#123; /*页表根地址不是无效的，则退出，不用分配。*/ if (likely(vcpu-&gt;arch.mmu.root_hpa != INVALID_PAGE)) return 0; return kvm_mmu_load(vcpu);&#125; 首先检查页表根地址是否无效，如果无效，则调用kvm_mmu_load。 123456789101112arch/x86/kvm/mmu.c:int kvm_mmu_load(struct kvm_vcpu *vcpu)&#123; int r; r = mmu_alloc_roots(vcpu); /*同步页表*/ mmu_sync_roots(vcpu); /* set_cr3() should ensure TLB has been flushed */ kvm_x86_ops-&gt;set_cr3(vcpu, vcpu-&gt;arch.mmu.root_hpa); kvm_x86_ops-&gt;tlb_flush(vcpu, true);&#125; mmu_alloc_roots这个函数要申请内存，作为根页表使用，同时root_hpa指向根页表的物理地址。然后可以看到，vcpu中cr3寄存器的地址要指向这个根页表的物理地址。 虚拟机物理地址我们已经分析过，kvm的虚拟机实际上运行在Qemu的进程上下文中。于是，虚拟机的物理内存实际上是Qemu进程的虚拟地址。Kvm要把虚拟机的物理内存分成几个slot。这是因为，对计算机系统来说，物理地址是不连续的，除了bios和显存要编入内存地址，IO设备的内存也可能映射到内存，所以内存实际上是分为一段段的。Qemu通过KVM_SET_USER_MEMORY_REGION来为虚拟机设置内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172virt/kvm/kvm_main.c:int __kvm_set_memory_region(struct kvm *kvm, struct kvm_userspace_memory_region *mem, int user_alloc)&#123; /*找到现在的memslot*/ slot = id_to_memslot(__kvm_memslots(kvm, as_id), id); base_gfn = mem-&gt;guest_phys_addr &gt;&gt; PAGE_SHIFT; npages = mem-&gt;memory_size &gt;&gt; PAGE_SHIFT; new = old = *slot; /*new是新的slots,old保持老的数值不变*/ new.id = id; new.base_gfn = base_gfn; new.npages = npages; new.flags = mem-&gt;flags; /*用户已经分配了内存，slot的用户空间地址就等于用户分配的地址*/ if (change == KVM_MR_CREATE) &#123;----&gt; new.userspace_addr = mem-&gt;userspace_addr; if (kvm_arch_create_memslot(kvm, &amp;new, npages)) goto out_free; &#125; /* Allocate page dirty bitmap if needed */ if ((new.flags &amp; KVM_MEM_LOG_DIRTY_PAGES) &amp;&amp; !new.dirty_bitmap) &#123; if (kvm_create_dirty_bitmap(&amp;new) &lt; 0) goto out_free; &#125;----&gt; slots = kvzalloc(sizeof(struct kvm_memslots), GFP_KERNEL); memcpy(slots, __kvm_memslots(kvm, as_id), sizeof(struct kvm_memslots)); /*内存地址页的检查和内存overlap的检查*/ if ((change == KVM_MR_DELETE) || (change == KVM_MR_MOVE)) &#123; slot = id_to_memslot(slots, id); slot-&gt;flags |= KVM_MEMSLOT_INVALID; old_memslots = install_new_memslots(kvm, as_id, slots); /* From this point no new shadow pages pointing to a deleted, * or moved, memslot will be created. * * validation of sp-&gt;gfn happens in: * - gfn_to_hva (kvm_read_guest, gfn_to_pfn) * - kvm_is_visible_gfn (mmu_check_roots) */ kvm_arch_flush_shadow_memslot(kvm, slot); /* * We can re-use the old_memslots from above, the only difference * from the currently installed memslots is the invalid flag. This * will get overwritten by update_memslots anyway. */ slots = old_memslots; &#125; r = kvm_arch_prepare_memory_region(kvm, &amp;new, mem, change); if (r) goto out_slots; /* actual memory is freed via old in kvm_free_memslot below */ if (change == KVM_MR_DELETE) &#123; new.dirty_bitmap = NULL; memset(&amp;new.arch, 0, sizeof(new.arch)); &#125; update_memslots(slots, &amp;new, change); old_memslots = install_new_memslots(kvm, as_id, slots); kvm_arch_commit_memory_region(kvm, mem, &amp;old, &amp;new, change);&#125; 就是创建一个新的memslot，代替原来的memslot。一个内存slot，最重要部分是指定了vm的物理地址，使用函数gfn_to_hva可以把gfn转换为hva。可见，一个memslot就是建立了GPA到HVA的映射关系。 内存虚拟化过程这里，有必要描述一下内存虚拟化的过程：VM要访问GVA地址x，那么首先查询VM的页表得到PTE（页表项），通过PTE将GVA x映射到物理地址GPA y. GPA y此时不存在，发生页缺失。KVM接管。从memslot，可以知道GPA对应的其实是HVA x’，然后从HVA x’，可以查找得到HPA y’，然后将HPA y’这个映射写入到页表。VM再次存取GVA x，这是从页表项已经可以查到HPA y’了，内存可正常访问。 首先，从page_fault处理开始。从前文的分析，知道VM里面的异常产生VM-Exit，然后由各自cpu提供的处理函数处理。对intel的vt技术，就是handle_exception这个函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263arch/x86/kvm/vmx.c:static int handle_exception(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)&#123; u32 intr_info, ex_no, error_code; /*读vmcs，获得VM-exit的信息*/ intr_info = vmx-&gt;exit_intr_info; /*发现是page_fault引起*/ if (is_page_fault(intr_info)) &#123; cr2 = vmcs_readl(EXIT_QUALIFICATION); /* EPT won&apos;t cause page fault directly */ /*如果支持EPT，不会因为page_fault退出，所以是bug*/ WARN_ON_ONCE(!vcpu-&gt;arch.apf.host_apf_reason &amp;&amp; enable_ept); return kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0); &#125; ex_no = intr_info &amp; INTR_INFO_VECTOR_MASK; if (vmx-&gt;rmode.vm86_active &amp;&amp; rmode_exception(vcpu, ex_no)) return handle_rmode_exception(vcpu, ex_no, error_code); switch (ex_no) &#123; case AC_VECTOR: kvm_queue_exception_e(vcpu, AC_VECTOR, error_code); return 1; case DB_VECTOR: dr6 = vmcs_readl(EXIT_QUALIFICATION); if (!(vcpu-&gt;guest_debug &amp; (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) &#123; vcpu-&gt;arch.dr6 &amp;= ~15; vcpu-&gt;arch.dr6 |= dr6 | DR6_RTM; if (is_icebp(intr_info)) skip_emulated_instruction(vcpu); kvm_queue_exception(vcpu, DB_VECTOR); return 1; &#125; kvm_run-&gt;debug.arch.dr6 = dr6 | DR6_FIXED_1; kvm_run-&gt;debug.arch.dr7 = vmcs_readl(GUEST_DR7); /* fall through */ case BP_VECTOR: /* * Update instruction length as we may reinject #BP from * user space while in guest debugging mode. Reading it for * #DB as well causes no harm, it is not used in that case. */ vmx-&gt;vcpu.arch.event_exit_inst_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN); kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG; rip = kvm_rip_read(vcpu); kvm_run-&gt;debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip; kvm_run-&gt;debug.arch.exception = ex_no; break; default: kvm_run-&gt;exit_reason = KVM_EXIT_EXCEPTION; kvm_run-&gt;ex.exception = ex_no; kvm_run-&gt;ex.error_code = error_code; break; &#125; return 0;&#125; 从这个函数，可以看到对vmcs的使用。通过读vmcs的域，可以获得退出vm的原因。如果是page_fault引起，则调用kvm_mmu_page_fault去处理。 123456789101112131415161718192021222324252627282930313233343536373839404142arch/x86/kvm/mmu.c:int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code)&#123; int r, emulation_type = 0; enum emulation_result er; bool direct = vcpu-&gt;arch.mmu-&gt;direct_map; /* With shadow page tables, fault_address contains a GVA or nGPA. */ if (vcpu-&gt;arch.mmu-&gt;direct_map) &#123; vcpu-&gt;arch.gpa_available = true; vcpu-&gt;arch.gpa_val = cr2; &#125; r = RET_PF_INVALID; if (unlikely(error_code &amp; PFERR_RSVD_MASK)) &#123; r = handle_mmio_page_fault(vcpu, cr2, direct); if (r == RET_PF_EMULATE) goto emulate; &#125; /*调用mmu的page_fault*/ if (r == RET_PF_INVALID) &#123; r = vcpu-&gt;arch.mmu-&gt;page_fault(vcpu, cr2, lower_32_bits(error_code), false); WARN_ON(r == RET_PF_INVALID); &#125; er = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len); switch (er) &#123; case EMULATE_DONE: return 1; case EMULATE_USER_EXIT: ++vcpu-&gt;stat.mmio_exits; /* fall through */ case EMULATE_FAIL: return 0; default: BUG(); &#125;&#125; 这里调用了MMU的page_fault处理函数。这个函数就是前面初始化时候设置的paging64_page_fault。也就是通过FNAME宏展开的FNAME(page_fault)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162arch/x86/kvm/paging_tmpl.h:static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code)&#123; /*查guest页表，物理地址是否存在 */ r = FNAME(walk_addr)(&amp;walker, vcpu, addr, write_fault, user_fault, fetch_fault); /*页还没映射，交Guest OS处理 */ if (!r) &#123; pgprintk(&quot;%s: guest page fault\n&quot;, __func__);----&gt; inject_page_fault(vcpu, addr, walker.error_code); vcpu-&gt;arch.last_pt_write_count = 0; /* reset fork detector */ return 0; &#125; if (walker.level &gt;= PT_DIRECTORY_LEVEL) &#123; level = min(walker.level, mapping_level(vcpu, walker.gfn)); walker.gfn = walker.gfn &amp; ~(KVM_PAGES_PER_HPAGE(level) - 1); &#125;----&gt; if (try_async_pf(vcpu, prefault, walker.gfn, addr, &amp;pfn, write_fault, &amp;map_writable)) return RET_PF_RETRY; if (handle_abnormal_pfn(vcpu, addr, walker.gfn, pfn, walker.pte_access, &amp;r)) return r; /* * Do not change pte_access if the pfn is a mmio page, otherwise * we will cache the incorrect access into mmio spte. */ if (write_fault &amp;&amp; !(walker.pte_access &amp; ACC_WRITE_MASK) &amp;&amp; !is_write_protection(vcpu) &amp;&amp; !user_fault &amp;&amp; !is_noslot_pfn(pfn)) &#123; walker.pte_access |= ACC_WRITE_MASK; walker.pte_access &amp;= ~ACC_USER_MASK; /* * If we converted a user page to a kernel page, * so that the kernel can write to it when cr0.wp=0, * then we should prevent the kernel from executing it * if SMEP is enabled. */ if (kvm_read_cr4_bits(vcpu, X86_CR4_SMEP)) walker.pte_access &amp;= ~ACC_EXEC_MASK; &#125; spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock); if (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq)) goto out_unlock; kvm_mmu_audit(vcpu, AUDIT_PRE_PAGE_FAULT); if (make_mmu_pages_available(vcpu) &lt; 0) goto out_unlock; if (!force_pt_level) transparent_hugepage_adjust(vcpu, &amp;walker.gfn, &amp;pfn, &amp;level); /*写入HVA到页表*/ r = FNAME(fetch)(vcpu, addr, &amp;walker, write_fault, level, pfn, map_writable, prefault); ++vcpu-&gt;stat.pf_fixed; kvm_mmu_audit(vcpu, AUDIT_POST_PAGE_FAULT);&#125; 对照前面的分析，比较容易理解这个函数了。首先是查guest的页表，如果从GVA到GPA的映射都没建立，那么返回，让Guest OS做这个工作。然后，如果映射已经建立，GPA存在，那么从Guest的页面号，查找Host的页面号,try_async_pf函数根据GFN获取对应的PFN。从memslot可以知道user space首地址，就可以把物理地址GPA转为HVA，通过HVA就可以查到HPA，然后找到所在页的页号。最后，写HVA到页表里面。页表在那里？回顾一下前面kvm_mmu_load的过程，页表是host申请的，host知道页表的真实物理地址。通过页表一层层的搜索，就可以找到要写入的页表项。已知虚拟地址，一级级查找页表找到要写的页表项位置，是经常用的一种操作，这个函数可以认真分析一下实现过程。 IO虚拟化IO虚拟化有两种方案，一种是半虚拟化方案，一种是全虚拟化方案。全虚拟化方案不需要修改Guest的代码，那么Guest里面的io操作最终都变成io指令。在前面的分析中，其实已经涉及了io虚拟化的流程。在VM-exit的时候，前文分析过page fault导致的退出。那么io指令，同样会导致VM-exit退出，然后kvm会把io交给Qemu进程处理。而半虚拟化方案，基本都是把io变成了消息处理，从guest机器发消息出来，然后由host机器处理。此时，在guest机器的驱动都被接管。 Vmm对io的处理当guest因为执行io执行退出后，由handle_io函数处理.123456789101112131415161718192021arch/x86/kvm/vmx.c:static int handle_io(struct kvm_vcpu *vcpu)&#123; unsigned long exit_qualification; int size, in, string; unsigned port; exit_qualification = vmcs_readl(EXIT_QUALIFICATION); string = (exit_qualification &amp; 16) != 0; ++vcpu-&gt;stat.io_exits; if (string) return kvm_emulate_instruction(vcpu, 0) == EMULATE_DONE; port = exit_qualification &gt;&gt; 16; size = (exit_qualification &amp; 7) + 1; in = (exit_qualification &amp; 8) != 0; return kvm_fast_pio(vcpu, size, port, in);&#125; 要从vmcs读退出的信息，然后调用kvm_fast_pio处理,最终走到真正的处理函数emulator_pio_in_out。12345678910111213141516171819202122232425arch/x86/kvm/x86.c:tatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size, unsigned short port, void *val, unsigned int count, bool in)&#123; vcpu-&gt;arch.pio.port = port; vcpu-&gt;arch.pio.in = in; vcpu-&gt;arch.pio.count = count; vcpu-&gt;arch.pio.size = size; if (!kernel_pio(vcpu, vcpu-&gt;arch.pio_data)) &#123; vcpu-&gt;arch.pio.count = 0; return 1; &#125; /*要赋值退出的种种参数*/ vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_IO; vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT; vcpu-&gt;run-&gt;io.size = size; vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE; vcpu-&gt;run-&gt;io.count = count; vcpu-&gt;run-&gt;io.port = port; return 0;&#125; 这里要为io处理赋值各种参数，然后看内核能否处理这个io，如果内核能处理，就不用Qemu进程处理，否则退出内核态，返回用户态。 虚拟化io流程从前文的分析中，我们知道返回是到Qemu的线程上下文中。实际上就是kvm_handle_io这个函数里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105kvm-all.c:static void kvm_handle_io(uint16_t port, MemTxAttrs attrs, void *data, int direction, int size, uint32_t count)&#123; int i; uint8_t *ptr = data; for (i = 0; i &lt; count; i++) &#123; address_space_rw(&amp;address_space_io, port, attrs, ptr, size, direction == KVM_EXIT_IO_OUT); ptr += size; &#125;&#125;exec.c:MemTxResult address_space_rw(AddressSpace *as, hwaddr addr, MemTxAttrs attrs, uint8_t *buf, int len, bool is_write)&#123; hwaddr l; uint8_t *ptr; uint64_t val; hwaddr addr1; MemoryRegion *mr; MemTxResult result = MEMTX_OK; bool release_lock = false; while (len &gt; 0) &#123; l = len; mr = address_space_translate(as, addr, &amp;addr1, &amp;l, is_write); if (is_write) &#123; if (!memory_access_is_direct(mr, is_write)) &#123; release_lock |= prepare_mmio_access(mr); l = memory_access_size(mr, l, addr1); /* XXX: could force current_cpu to NULL to avoid potential bugs */ switch (l) &#123; case 8: /* 64 bit write access */ val = ldq_p(buf); result |= memory_region_dispatch_write(mr, addr1, val, 8, attrs); break; case 4: /* 32 bit write access */ break; case 2: /* 16 bit write access */ break; case 1: /* 8 bit write access */ break; default: abort(); &#125; &#125; else &#123; addr1 += memory_region_get_ram_addr(mr); /* RAM case */ ptr = qemu_get_ram_ptr(addr1); memcpy(ptr, buf, l); invalidate_and_set_dirty(mr, addr1, l); &#125; &#125; else &#123; if (!memory_access_is_direct(mr, is_write)) &#123; /* I/O case */ release_lock |= prepare_mmio_access(mr); l = memory_access_size(mr, l, addr1); switch (l) &#123; case 8: /* 64 bit read access */ result |= memory_region_dispatch_read(mr, addr1, &amp;val, 8, attrs); stq_p(buf, val); break; case 4: /* 32 bit read access */ break; case 2: /* 16 bit read access */ break; case 1: /* 8 bit read access */ break; default: abort(); &#125; &#125; else &#123; /* RAM case */ ptr = qemu_get_ram_ptr(mr-&gt;ram_addr + addr1); memcpy(buf, ptr, l); &#125; &#125; if (release_lock) &#123; qemu_mutex_unlock_iothread(); release_lock = false; &#125; len -= l; buf += l; addr += l; &#125;&#125; 然后调用每种设备所登记的指令处理函数处理，完成io。各种设备都有自己的处理函数，所以Qemu需要支持各种不同的设备，Qemu的大部分代码都是各种各样设备的驱动代码（注意这里驱动的意义和传统驱动程序的含义有所不同）。 设备注册和设备模拟QEMU设备注册可以移步qemu-qom详解 虚拟化概述脑图脑图有待进一步完善 查看大图请点击这里]]></content>
      <categories>
        <category>kvm</category>
      </categories>
      <tags>
        <tag>kvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英特尔®64和IA-32架构软件开发人员手册(Intel SDM)]]></title>
    <url>%2F2019%2F01%2F29%2FIntel-SDM%2F</url>
    <content type="text"><![CDATA[23.1 概述本章介绍虚拟机体系结构的基础知识和虚拟机扩展的概述(VMX),支持多个软件环境的处理器硬件虚拟化。关于VMX指令的信息参考英特尔®64和IA-32架构软件开发人员手册中的第2B卷。其他关于VMX和系统编程参考SDM 第3B卷 23.2虚拟机器结构虚拟机扩展为IA-32处理器上的虚拟机定义了处理器级支持。两个重要支持的软件类别： 虚拟机监视器(VMM)VMM充当主机，可以完全控制处理器和其他处理器平台硬件。 VMM使用虚拟的抽象来呈现客户软件(参见下一段)处理器并允许它直接在逻辑处理器上执行。 VMM能够保留选择性控制处理器资源，物理内存，中断管理和I / O。 Guest- 每个虚拟机(VM)是一个支持堆栈组成的客户软件环境,操作系统(OS)和应用程序软件。每个都独立于其他虚拟机运行在物理的处理器上，内存，存储器，图形和I / O的相同接口上使用平台。软件堆栈就像在没有VMM的平台上运行一样。软件执行中虚拟机必须以降低的权限运行，以便VMM可以保留对平台资源的控制。 23.3 VMX操作简介虚拟化的处理器支持由称为VMX操作的处理器操作形式提供。有两种VMX操作：VMX root和VMX non-root操作。通常，VMM运行在VMX root模式下，同时将guest 软件运行在non-root模式下。VMX root操作和VMX non-root操作的转换称为VMX转换。有两种VMX转换: 从VMX root过渡到VMX non-root模式称为VM entry； 从VMX not-root操作到VMX root的转换成为VM exit。VMX root操作中的处理器行为与VMX操作之外的处理器行为非常相似。主要区别是一组新指令(VMX指令)（见第23.8节）。VMX non-root操作中的处理器行为受到限制和修改，以便于虚拟化。那些指令（包括新的VMCALL指令）和事件会导致VM EXIT的发生，而不仅仅是他们原来的操作。由于这些VM Exit取代了普通行为，因此VMX non-root操作中的软件功能是有限制的。正是这种限制允许VMM保持对处理器资源的控制。并不存在用于通知guest“是否处于VMX non-root”的寄存器。这一事实可以防止guest软件察觉它正在虚拟机中运行。因为VMX操作对(CPL)Level 0做了限制，guest的软件可以在最初设计的权限级别运行。这样就可以简化VMM的开发。 23.4 VMM软件的生命周期图23-1说明了VMM及其客户软件的生命周期以及它们之间的交互。以下项目总结了生命周期： 软件通过执行VMXON指令进入VMX操作 使用VM entry，VMM可以执行guest，一次一个。 VMM通过使用VMLAUNCH和VMRESUME指令干预虚拟机。通过VM EXIT，VMM重新获得控制权。 VM移交控制权到VMM指定的入口点。VMM可以采取适当的措施使得VM exit发生，然后可以使用VM entry返回到虚拟机。 最终，VMM可以通过执行VMXOFF自行决定关闭并离开VMX操作。 23.5虚拟机控制结构VMX non-root的操作以及VMX转换由名为“虚拟机控制”(VMCS)的数据结构控制。通过VMCS指针(每个逻辑CPU一个)来管理对VMCS的访问。VMCS指针的值是64位地址。读取和写入VMCS指针使用指令VMPTRST和VMPTRLD。并且VMM使用VMREAD，VMWRITE和VMCLEAR指令来配置VMCS。VMM可以为其支持的每个虚拟机使用不同的VMCS。对于具有多个的虚拟机在逻辑处理器（虚拟处理器）中，VMM可以为每个虚拟处理器使用不同的VMCS。 23.6 发现对VMX的支持在系统软件进入VMX操作之前，它必须检查处理器中是否存在VMX支持。系统软件可以使用CPUID确定处理器是否支持VMX操作。如果CPUID.1：ECX.VMX [bit 5] = 1那么当前平台支持VMX操作。请参见第3章“指令集参考，A-L”英特尔®64和IA-32架构软件开发人员手册，第2A卷。VMX体系结构旨在实现可扩展性，以便VMX操作中的未来处理器可以支持VMX体系结构的第一代实现中不存在的其他功能。使用一组VMX功能MSR向软件报告可扩展VMX功能的可用性（参见附录A，“VMX功能”)。 23.7启用和进入VMX操作在系统软件进入VMX操作之前，它通过设置CR4.VMXE [bit 13] = 1 VMX操作来启用VMX。然后通过执行VMXON指令进入。当’CR4.VMXE = 0’时，如果执行指令VMXON会导致无效操作码异常（#UD)；一旦执行过VMX操作，就无法清除CR4.VMXE（参见第23.8节）。系统软件通过执行VMXOFF指令离开VMX操作。执行VMXOFF后，可以在VMX操作之外清除CR4.VMXE。VMXON也由IA32_FEATURE_CONTROL MSR（MSR地址3AH）控制。该MSR清零重置逻辑处理器时MSR的相关位是： 位0是锁定位。如果该位清零，则VMXON会导致general-protection异常。如果设置了锁定位，WRMSR到此MSR会导致general-protection异常;在上电复位之前，不能修改MSR。系统BIOS可以使用此位为BIOS提供设置选项以禁用对VMX的支持。在平台中启用VMX支持，BIOS必须设置位1或者位2或两者（见下文）以及锁定位。 位1在SMX操作中启用VMXON。如果该位清零，则在SMX操作中执行VMXON会导致general-protection expection。尝试在不支持两个VMX的逻辑处理器上设置此位操作（参见第23.6节）和SMX操作（参见英特尔®中的第6章“安全模式扩展参考”第2D卷）导致general-proction异常。 位2在SMX操作之外启用VMXON。如果该位清零，则在SMX外部执行VMXON操作会导致general-proction异常。尝试在没有的逻辑处理器上设置此位支持VMX操作（参见第23.6节）导致general-proction异常。 在执行VMXON之前，软件应该分配一个逻辑上自然对齐的4 KB内存区域,处理器可用于支持VMX操作.1该区域称为VMXON region。VMXON zone的地址区域（VMXON指针）在VMXON的操作数中提供。第24节 23.8 VMX操作限制（作者：限制还有很有一些的，暂且不一一列举了吧，这里挑1-2点） 当逻辑处理器在VMX root操作时，中断信号是被block的。但当在VMX non-root模式的时候，不会被block，相反中断信号会触发VM exit。 24.1 虚拟机控制结构(VMCS)逻辑处理器在VMX操作中使用”虚拟机控制结构”（VMCS）。这些管理VMX进出非root与root操作（VM entry和VM exit）以及处理器在VMX non-root时的行为。这个结构由新指令VMCLEAR，VMPTRLD，VMREAD, VMWRITE操纵。VMM可以为其支持的每个虚拟机使用不同的VMCS。对于具有多个的虚拟机在逻辑处理器（虚拟处理器）中，VMM可以为每个虚拟处理器使用不同的VMCS。逻辑处理器将存储器中的区域与每个VMCS相关联。该区域称为VMCS region。软件使用区域的64位物理地址（VMCS指针）引用特定VMCS。 VMCS指针必须在4 KB边界上对齐（位11：0必须为零）。这些指针不能设置超出理器的物理地址宽度。逻辑处理器可以维护多个活动的VMCS。处理器通过维护内存中活跃VMCS的状态来优化VMX操作。在任何给定时间，最多一个活动VMCS的数量是当前VMCS。 （本文档经常使用术语“VMCS”来指代当前VMCS。）VMLAUNCH，VMREAD，VMRESUME和VMWRITE指令仅对当前操作VMCS。以下各项描述了逻辑处理器如何确定哪些VMCS处于活动状态以及哪些VMCS处于当前状态： VMPTRLD指令的内存操作数是VMCS的地址。执行完指令后VMCS在逻辑处理器上既是活动的和也是当前的。任何其他活动的VMCS都不是当前VMCS。 VMCS中的VMCS链接指针字段（参见第24.4.2节）本身就是VMCS的地址。如果VM entry正确执行了，并且“VMCS shadow”VM执行控制（VMCS）的1设置成功，那么VMCS链接指针字段引用的字符在逻辑处理器上变为活动状态。当前VMCS不会改变。 VMCLEAR指令的内存操作数也是VMCS的地址。执行完毕后指令，VMCS在逻辑处理器上既不是活动的也不是当前的。如果VMCS已经开启逻辑处理器，逻辑处理器不再具有当前的VMCS。 VMPTRST指令将逻辑处理器的当前VMCS的地址存储到指定的存储器位置（如果没有当前的VMCS，则存储值FFFFFFFF_FFFFFFFFH）。VMCS的启动状态确定哪个VM-entry指令应该与该VMCS一起使用：VMLAUNCH指令需要VMCS，其启动状态为“清除”; VMRESUME指令需要VMCS，其发射状态是“发射”。逻辑处理器在相应的VMCS中维护VMCS的启动状态区域。以下各项描述了逻辑处理器如何管理VMCS的启动状态： 如果当前VMCS的启动状态为“clear”，则VMLAUNCH指令的成功执行会发生变化发射状态为“launched”。 VMCLEAR指令的内存操作数是VMCS的地址。执行完指令后VMCS的启动状态是“clear”。 没有其他方法可以修改VMCS的启动状态（无法使用VMWRITE进行修改）也没有直接的方法来发现它（它无法使用VMREAD读取） 图24-1说明了VMCS的不同状态。它使用“X”表示VMCS，使用“Y”表示任何其他VMCS。因此：“VMPTRLD X”总是使得VMCS变为当前和活动状态; “VMPTRLD Y”让X不再是当前状态（因为它使Y变为当前状态）;如果X是当前的并且其启动状态时，则VMLAUNCH的会将X变为“launched”; VMCLEAR X总是使X处于非活动状态而不是当前状态，并使其启动状态“clear”。该图未示出相对于这些参数不修改VMCS状态的操作（例如，当X已经是当前时执行VMPTRLD X）。请注意，VMCLEAR X使X“处于非活动状态，非当前状态，并且clear。即使X的当前状态未定义（例如，即使X尚未初始化）。见24.11.3节。由于影子VMCS（请参阅第24.10节）不能用于VM条目，因此影子VMCS的启动状态为没有意义。图24-1未说明可以使影子VMCS处于活动状态的所有方式。 24.2 VMCS Region的格式VMCS的格式包含了4K，VMCS的格式如表24-1 byte offside 内容 0 0~30位 VMCS保留，识别符31位: shadow-VMCS标识位 4 VMCS终止位 8 VMCS 数据 VMCS区域的前4个字节包含位30：0的VMCS修订标识符。维护的处理器不同格式的VMCS数据（见下文）使用不同的VMCS修订标识符。位31：shadow-VMCS指标（参见第24.10节） 在将该区域用于VMCS之前，软件应将VMCS标识符写入VMCS区域。该VMCS标识符永远不会被处理器写入;如果VMPTRLD的操作数引用VMCS区域的标识符与处理器正在使用的VMCS不同，则VMPTRLD会失败。 （如果是影子VMCS，并且处理器不支持shadow-VMCS，那么VMPTRLD也会失败）软件可以通过读取VMX相关MSR IA32_VMX_BASIC来检查处理器VMCS标识符。软件应根据VMCS是否为普通还是shadow-vmcs来设置或者清楚shadow-VMCS标识符.不支持“VMCS阴影”VM执行控件的1设置。软件可以通过读取VMX功能MSR IA32_VMX_PROCBASED_CTLS2来检查是否支持。VMCS区域的接下来的4个字节用于VMX中止指示符。这些位的内容没有控制处理器。当VMX中止发生时，逻辑处理器将非零值写入这些位。软件也可以写入此字段。VMCS区域的其余部分用于VMCS数据（控制VMX non-root操作以及VMX转换）。这些数据的格式是特定的。写回可缓存内存中的VMCS区域和相关结构（在第24.11.4节中列举）。未来实现可以允许或要求不同的存储器类型。软件应参考VMX功能MSRIA32_VMX_BASIC（见附录A.1） 未完待续……]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用QOM(Qemu Object Model)创建虚拟设备]]></title>
    <url>%2F2018%2F12%2F26%2Fqemu-qom%2F</url>
    <content type="text"><![CDATA[什么是QOMQOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。 QOM 的初始化对象的初始化分为四步： 将 TypeInfo 注册 TypeImpl 实例化 ObjectClass 实例化 Object 添加 Property 根据QEMU的wiki ，QOM没有构造和析构的概念。但矛盾的是根据代码，TypeInfo 中定义的 class_init 和 instance_init 无论从名字还是实现上都做了对象的初始化工作，比如设置对象成员的值。但为什么说它们最多只能算是初始化函数呢？Everything in QOM is a device根据实现，经过 class_init 和 instance_init 产生设备对应Object后，这个Object是不能直接使用的。其真正初始化逻辑的大头都放在 realize 中做，比如创建对应的memory region，挂载到对应bus上等等。只有在 realize 后，设备才算真正构造完成，可以拿来用了。因此QEMU认为，类似构造和析构的是realize和unrealize。而在设备的生命周期中，可以被realize和unrealize多次。为了保持习惯，本文会依然将 class_init 和 instance_init 当做构造函数，称前者为类构造函数，后者为类实例构造函数。 使用QOM添加设备源码分析下面我们就利用一个真实的案例，讲解一下利用QOM添加设备的具体实现步骤 TypeInfo =&gt; ModuleEntry设备相关代码的入口就是这里了, TypeInfo 定义了一种类型，并且使用函数type_register_static注册： 1234567891011121314static const TypeInfo caffee_agent_info = &#123; .name = &quot;caffee-agent&quot;, .parent = TYPE_ISA_DEVICE, .class_init = caffee_agent_class_init, .instance_size = sizeof(CaffeeAgentState), .instance_init = caffee_agent_initfn,&#125;; static void caffee_agent_register_types (void)&#123; type_register_static (&amp;caffee_agent_info);&#125;type_init(cafe_agent_register_types) 包含 类型的名称(name)、父类名称(parent)、Object实例的大小(instance_size)、是否抽象类(abstract)、初始化函数(class_init)。代码底部有 type_init ，由 C run-time(CRT)负责执行： 12345678910111213void register_module_init(void (*fn)(void), module_init_type type)&#123; ModuleEntry *e; ModuleTypeList *l; e = g_malloc0(sizeof(*e)); e-&gt;init = fn; e-&gt;type = type; l = find_type(type); QTAILQ_INSERT_TAIL(l, e, node);&#125; 创建了 type 为 MODULE_INIT_QOM ，init为 kvm_type_init 的 ModuleEntry ，并加入到 MODULE_INIT_QOM 的 ModuleTypeList 中。 ModuleEntry =&gt; TypeImpl在 main.c(vl.c) 的一开始执行了 module_call_init(MODULE_INIT_QOM) ，它从 init_type_list 中取出对应的 ModuleTypeList ，然后对里面的 ModuleEntry 成员都调用 init 函数。对于上文提到的 ModuleEntry ，调用的是： 12345678static TypeImpl *type_register_internal(const TypeInfo *info)&#123; TypeImpl *ti; ti = type_new(info); type_table_add(ti); return ti;&#125; 它根据 kvm_accel_type(TypeInfo) 创建一个名为TYPE_KVM_ACCEL的 TypeImpl 类型的结构。同时将该 TypeImpl 注册到全局 type_table 中，key为类型名称，即 TYPE_KVM_ACCEL ObjectClass12345678910111213struct ObjectClass&#123; /*&lt; private &gt;*/ Type type; // 用typedef定义的 TypeImpl 指针 GSList *interfaces; const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE]; const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE]; ObjectUnparent *unparent; GHashTable *properties;&#125;; ObjectClass 属于类对象，它是所有类对象的基类。 TypeImpl =&gt; ObjectClass有两种路径，一种是主动地调用： 比如 object_class_get_list(TYPE_DEVICE, false) 创建 TYPE_DEVICE 类型的 ObjectClass该过程用到glic的函数 g_hash_table_foreach ，见 https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#g-hash-table-foreach另一种是被动调用，如: object_class_by_name object_class_get_parent object_new_with_type object_initialize_with_type 在获取 class、class的parent、创建type的object、初始化TypeImpl的object时，调用 type_initialize12345678910type_initialize=&gt; 如果 TypeImpl 已创建(class成员有值)，返回=&gt; ti-&gt;class = g_malloc0(ti-&gt;class_size) 根据class_size分配内存空间=&gt; type_get_parent(ti) 获取父类的TypeImpl=&gt; memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size) 将parent的class拷贝到自己class的最前面=&gt; ti-&gt;class-&gt;properties = g_hash_table_new_full 创建存放property的hash table=&gt; type_initialize_interface 初始化class的接口，包括父类和自己的=&gt; ti-&gt;class-&gt;type = ti 设置class的type为对应TypeImpl=&gt; parent-&gt;class_base_init 如果parent定义了 class_base_init ，调用之=&gt; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data) 调用class的 class_init 对于 kvm_accel_type 这个 TypeInfo 的 TypeImpl ，调用的class_init是 kvm_accel_class_init ，它将传入的 ObjectClass 强转为子类 AccelClass ，设置 init_machine 成员为 kvm_init这里的class是该类型的类实例，它的基类是 ObjectClass 。 继承从创建流程可以看出，在创建类对象时，会调用 type_initialize ，其会递归地对 TypeImpl 中的 parent 成员(TypeImpl)递归调用 type_initialize ，然后将创建出来的相应 ObjectClass 拷贝到自己class的最前面。类对象的第一个成员是 parent_class ，由于父类对象会拷到子类对象的最前面，因此可以认为其指向父类的对象，如此构成链状的继承链，最终指向基类对象 ObjectClass比如 kvm_accel_type 对应的类对象，该类对象作为叶子类型并没有定义，但其父类 AccelClass 在代码中有定义，其的第一个成员为 ObjectClass ，表示其继承自 ObjectClass 。为了能表示该叶子类型继承 AccelClass ，它修改了 AccelClass的一些对象成员，这样在某种程度上表示了继承关系。比如修改了函数指针成员的指向，相当于实现了虚函数。又如： register_info 对应的类对象 =&gt; PCIDeviceClass =&gt; DeviceClass =&gt; ObjectClass 构成继承链，最前端的叶子类型通过修改 PCIDeviceClass 成员进行定义。 强制类型转换将一个父类的指针转换为子类的指针是不安全的，为了实现这种转换，各类需要提供强制类型转换的宏，如：123456#define ACCEL_CLASS(klass) \ OBJECT_CLASS_CHECK(AccelClass, (klass), TYPE_ACCEL)#define OBJECT_CLASS_CHECK(class_type, class, name) \ ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \ __FILE__, __LINE__, __func__)) 如果类对象指针的name和目标子类的name一致，或类对象指针是目标子类的祖先，则执行转换，否则 abort反过来，从子类指针转换为父类指针是安全的，因为类的第一项就指向父类，访问时不会存在越界等问题。 ObjectObject 属于类实例对象，它是所有类实例对象的基类。123456789struct Object&#123; /*&lt; private &gt;*/ ObjectClass *class; // 指向类对象 ObjectFree *free; GHashTable *properties; // 维护属性的哈希表 uint32_t ref; // 引用计数 Object *parent; // 指向父类实例对象，实现继承&#125;; 可以看到其第一个成员指向类对象，同时维护有区别于类属性的类实例属性。 创建流程就流程而言，在C runtime 根据 TypeInfo 创建了 TypeImpl 后，此后主要根据 TypeImpl 创建 ObjectClass 和 Object以 TypeInfo(kvm_accel_type) 为例，其创建的 TypeImpl 在以下流程发挥作用：12345678910111213141516main =&gt; configure_accelerator =&gt; accel_init_machine(acc, ms)=&gt; ObjectClass *oc = OBJECT_CLASS(acc) 将AccelClass指针转换成父类(ObjectClass)指针=&gt; object_class_get_name 获取 ObjectClass-&gt;TypeImpl 的类名，如 kvm-accel=&gt; ACCEL(object_new(cname)) 利用名称创建 AccelState 对象=&gt; acc-&gt;init_machine(ms) 初始化machine，实际上是调用 kvm_initobject_new=&gt; type_get_by_name(typename) 根据类名查type_table获取 TypeImpl=&gt; object_new_with_type =&gt; type_initialize 创建 TypeImpl 对应的类对象，设置到对应 TypeImpl-&gt;class 中 =&gt; g_malloc(type-&gt;instance_size) 分配类实例对象的内存 =&gt; object_initialize_with_type 创建类实例对象 =&gt; type_initialize 会再次尝试实例化类对象 =&gt; obj-&gt;class = type-&gt;class 设置类实例对象的类对象为 TypeImpl-&gt;class =&gt; obj-&gt;properties = g_hash_table_new_full 创建存放类实例对象property的hash table =&gt; object_init_with_type =&gt; object_init_with_type 如果 TypeImpl 有父类，递归调用object_init_with_type =&gt; ti-&gt;instance_init(obj) 如果定义了类实例的构造函数，调用之 继承定义上的继承主要指类的继承，既然类对象已经通过包含的方式实现了继承，那么类实例对象就可以通过调用自己的class成员调用父类的函数，访问父类的class property。但在QEMU实现的这套面向对象模型中，类实例对象也拥有自己的构造函数，因此根据继承关系，需要对父类实例对象的构造函数进行调用。从创建流程可以看出，在创建类实例对象时，会调用 object_init_with_type ，其会递归地对 TypeImpl 中的 parent 成员递归调用 object_init_with_type ，从而让所有父类的 instance_init 都得到调用，在调用时传入的是当前对象的地址，相当于在当前对象上对父类实例对象进行构造。同理，类实例对象的第一个成员是 parent_obj ，指向父类的实例对象，如此构成链状的继承链，最终指向基类实例对象 Object如： kvm_accel_type的类实例Object =&gt; AccelState =&gt; Object又如： register_info的类实例Object =&gt; PCIDevice =&gt; DeviceState =&gt; Object 强制类型转换同理，将一个父类实例的指针转换为子类实例指针是不安全的。为了实现这种转换，各类需要提供强制类型转换的宏，如：123456#define ACCEL(obj) \ OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)#define OBJECT_CHECK(type, obj, name) \ ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \ __FILE__, __LINE__, __func__)) 如果类实例对象指针的name和目标子类实例的name一致，或类实例对象指针是目标子类的祖先，则执行转换，否则 abort。反过来，从子类实例指针转换为父类实例指针是安全的，因为类实例的第一项就指向父类实例，访问时不会存在越界等问题。 属性属性分为类对象(ObjectClass)属性和类实例对象(Object)属性，存储于 properties 成员中。properties 是一个 GHashTable ，存储了属性名到ObjectProperty的映射。 属性模版用于创建属性对象 ObjectProperty1234567891011struct Property &#123; const char *name; PropertyInfo *info; ptrdiff_t offset; uint8_t bitnr; QType qtype; int64_t defval; int arrayoffset; PropertyInfo *arrayinfo; int arrayfieldsize;&#125;; 属性对象属性对象包含属性名称、类型、描述，类型对应的属性结构，以及相应访问函数。1234567891011typedef struct ObjectProperty&#123; gchar *name; gchar *type; gchar *description; ObjectPropertyAccessor *get; ObjectPropertyAccessor *set; ObjectPropertyResolve *resolve; ObjectPropertyRelease *release; void *opaque;&#125; ObjectProperty; 如对于bool类型的属性，opaque为 BoolProperty ，set为 property_set_bool ，get为 property_get_bool 。12345typedef struct BoolProperty&#123; bool (*get)(Object *, Error **); void (*set)(Object *, bool, Error **);&#125; BoolProperty; 用于保存用户传入的 getter 和 setter 。 getter / setter (callback hook)定义了在设置/读取属性时触发的函数。比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：1object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL) 则 getter 为 device_get_realized ， setter 为 device_set_realized 静态属性凡是在代码中就已经定义好名称和类型的属性，都是静态属性。包括在初始化过程中添加 和 props 。 初始化过程中添加比如对于 TypeInfo x86_cpu_type_info ，类实例初始化函数 x86_cpu_initfn 定义好了属性：12345object_property_add(obj, &quot;family&quot;, &quot;int&quot;, x86_cpuid_version_get_family, x86_cpuid_version_set_family, NULL, NULL, NULL);object_property_add_alias(obj, &quot;kvm_steal_time&quot;, obj, &quot;kvm-steal-time&quot;, &amp;error_abort); 该属性会直接加到类实例对象的properties中。 props一些类对象会在 class_init 中设置 props 成员，比如 TypeInfo host_x86_cpu_type_info 在 host_x86_cpu_class_init 设置为 host_x86_cpu_properties：123456789101112131415161718192021static Property host_x86_cpu_properties[] = &#123; DEFINE_PROP_BOOL(&quot;migratable&quot;, X86CPU, migratable, true), DEFINE_PROP_BOOL(&quot;host-cache-info&quot;, X86CPU, cache_info_passthrough, false), DEFINE_PROP_END_OF_LIST()&#125;;#define DEFINE_PROP_BOOL(_name, _state, _field, _defval) &#123; \ .name = (_name), \ .info = &amp;(qdev_prop_bool), \ .offset = offsetof(_state, _field) \ + type_check(bool, typeof_field(_state, _field)), \ .qtype = QTYPE_QBOOL, \ .defval = (bool)_defval, \ &#125;// 闭包PropertyInfo qdev_prop_bool = &#123; .name = &quot;bool&quot;, .get = get_bool, .set = set_bool,&#125;; 而类实例 X86CPU 中定义了这些属性：123456struct X86CPU &#123; bool migratable; ... bool cache_info_passthrough; ...&#125;; 于是 X86CPU.migratable 和 X86CPU.cache_info_passthrough 两个成员被定义成属性。 在父类 device_type_info 的类实例初始化函数 device_initfn 中，对所有的props，有：1234567do &#123; for (prop = DEVICE_CLASS(class)-&gt;props; prop &amp;&amp; prop-&gt;name; prop++) &#123; qdev_property_add_legacy(dev, prop, &amp;error_abort); qdev_property_add_static(dev, prop, &amp;error_abort); &#125; class = object_class_get_parent(class);&#125; while (class != object_class_by_name(TYPE_DEVICE)); 而 qdev_property_add_static ： =&gt; object_property_add(obj, prop-&gt;name, prop-&gt;info-&gt;name, prop-&gt;info-&gt;get, prop-&gt;info-&gt;set, prop-&gt;info-&gt;release, prop, &amp;local_err) 根据Property中的数据，创建ObjectProperty，并将其加到类实例对象的 properties 中 关键是将闭包中的get和set取出，作为ObjectProperty的get和set=&gt; object_property_set_description 设置属性的描述字符串=&gt; 设置属性的默认值 查看可通过命令查看设备的静态属性，参数为设备 TypeInfo 的 name：1/home/binss/work/qemu/qemu-2.8.1.1/x86_64-softmmu/qemu-system-x86_64 -device Broadwell-x86_64-cpu,? 但是， x86_64-cpu 抽象设备无法打。 host-x86_64-cpu 无法列出。 动态属性指在运行时动态进行添加的属性。比如用户通过参数传入了一个设备，需要作为属性和其它设备关联起来。典型的动态属性就是 child&lt;&gt; 和 link&lt;&gt; (因为其类型就是这样构造的，后文简称child和link) 。 childchild实现了composition关系，表示一个设备(parent)创建了另外一个设备(child)，parent掌控child的生命周期，负责向其发送事件。一个device只能有一个parent，但能有多个child。这样就构成一棵组合树。通过 object_property_add_child 添加child：12=&gt; object_property_add 将 child 作为 obj 的属性，属性名name，类型为 &quot;child&lt;child的类名&gt;&quot;，同时getter为object_get_child_property，没有setter=&gt; child-&gt;parent = obj 例如 x86_cpu_realizefn =&gt; x86_cpu_apic_create =&gt; object_property_add_child(OBJECT(cpu), “lapic”, OBJECT(cpu-&gt;apic_state), &amp;error_abort) 将创建 APICCommonState ，并设置为 X86CPU 的child。可以在qemu hmp查询到：1234(qemu) info qom-tree/machine (pc-q35-2.8-machine) /unattached (container) /device[0] (host-x86_64-cpu) linklink实现了backlink关系，表示一个设备引用了另外一个设备，是一种松散的联系。两个设备之间能有多个link关系，可以进行修改。它完善了组合树，使其构成构成了一幅有向图。通过 object_property_add_link 添加link：12=&gt; 创建 LinkProperty ，填充目标(child)的信息=&gt; object_property_add 将 LinkProperty 作为 obj 的属性，属性名name，类型为 &quot;link&lt;child的类名&gt;&quot;，同时getter为 object_get_link_property 。如果传入了check函数，则需要回调，设置setter为 object_set_link_property 例如 q35 有以下link：123456789101112131415161718static void q35_host_initfn(Object *obj)&#123; object_property_add_link(obj, MCH_HOST_PROP_RAM_MEM, TYPE_MEMORY_REGION, (Object **) &amp;s-&gt;mch.ram_memory, qdev_prop_allow_set_link_before_realize, 0, NULL); object_property_add_link(obj, MCH_HOST_PROP_PCI_MEM, TYPE_MEMORY_REGION, (Object **) &amp;s-&gt;mch.pci_address_space, qdev_prop_allow_set_link_before_realize, 0, NULL); object_property_add_link(obj, MCH_HOST_PROP_SYSTEM_MEM, TYPE_MEMORY_REGION, (Object **) &amp;s-&gt;mch.system_memory, qdev_prop_allow_set_link_before_realize, 0, NULL); object_property_add_link(obj, MCH_HOST_PROP_IO_MEM, TYPE_MEMORY_REGION, (Object **) &amp;s-&gt;mch.address_space_io, qdev_prop_allow_set_link_before_realize, 0, NULL);&#125; 将 Q35PCIHost 和 ram_memory / pci_address_space / system_memory / address_space_io 链接起来。 API根据前面所述，属性有两种定义方式，一种是通过 DEFINE_PROP_* 定义，另一种是通过 object_property_add_&lt;type&gt; 进行定义。根据不同的定义方式，set会不同，设置值的方式也有所不同。 object_property_set_&lt;type&gt;用于设置某个属性的值。比如 object_property_set_bool ：12345=&gt; qbool_from_bool 将要设置的值包装成相应的 QObject ，这里是QBool=&gt; object_property_set_qobject =&gt; qobject_input_visitor_new 将传入的QObject包装成Visitor，其中含各类型的处理函数 =&gt; object_property_set =&gt; object_property_find 从props的hash table中找到对应的 ObjectProperty =&gt; prop-&gt;set 对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 set 被设置为 set_bool1234set_bool=&gt; qdev_get_prop_ptr 将设备指针加上属性值在其中的偏移量，得到属性值的地址=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object 从Visitor中取出QObject =&gt; qbool_get_bool 从QObject中取出值，设置到属性值的地址 对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 set 为 property_set_bool123property_set_bool=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object 找到QObject=&gt; (BoolProperty)prop-&gt;set 调用setter 比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：1object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL) 于是 setter 为 device_set_realized12=&gt; dc-&gt;realize 调用realize函数，其在 class_init 中定义=&gt; dev-&gt;realized = value 设置类实例对象的成员 一句话总结，前者的属性值的设置由 type_bool 负责设置，而后者由 setter 负责设置。 object_property_get_&lt;type&gt;用于读取某个属性的值。比如 object_property_get_bool ：1234567=&gt; object_property_get_qobject =&gt; 创建空的QObject指针 =&gt; qobject_output_visitor_new 将传入的QObject包装成Visitor，其中含各类型的处理函数 =&gt; object_property_get =&gt; object_property_find 从props的hash table中找到对应的 ObjectProperty =&gt; prop-&gt;get 调用get函数，设置QObject=&gt; qobject_to_qbool 将QObject转成QBool=&gt; qbool_get_bool 从QBool中取出值，返回 对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 get 被设置为 get_bool123get_bool=&gt; qdev_get_prop_ptr(dev, prop) 将设备指针加上属性值在其中的偏移量，得到属性值的地址=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object 将属性值包装成QObject 对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 get 为 property_get_bool ：123property_get_bool=&gt; prop-&gt;get 调用getter，得到属性值=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object 将属性值包装成QObject 个人的理解是，set 和 get 都需要通过 QObject 和 Visitor 两层包装。前者把要设置属性值包装成QObject再到Visitor，然后再取出设置到相应地址。后者根据属性值地址将属性值包装成QObject，设置为Visitor中QObject指针指向，然后再从QObject中取出值。 object_property_parse在用一个string设置不知道类型的属性的值时，使用 object_property_parse：1234567void object_property_parse(Object *obj, const char *string, const char *name, Error **errp)&#123; Visitor *v = string_input_visitor_new(string); object_property_set(obj, v, name, errp); visit_free(v);&#125; 它会创建一个 Visitor 并将值设置到里面，这里定义了string转其他类型属性的函数：1234567v-&gt;visitor.type = VISITOR_INPUT;v-&gt;visitor.type_int64 = parse_type_int64;v-&gt;visitor.type_uint64 = parse_type_uint64;v-&gt;visitor.type_size = parse_type_size;v-&gt;visitor.type_bool = parse_type_bool;v-&gt;visitor.type_str = parse_type_str;v-&gt;visitor.type_number = parse_type_number; 总结如此一来，根据 TypeInfo 创建了 TypeImpl ，然后根据 TypeImpl 创建了对应的 ObjectClass ，再根据 TypeImpl 创建了对应的 Object ， ObjectClass 和 Object 都有自己的 Property，关系如下：1234 TypeImpl class -&gt; ObjectClass(AccelClass) Object(AccelState) &lt;- type &lt;- classTypeImpl &lt;- parent_type properties(GHashTable) properties(GHashTable) op1=>operation: type_init(kvm_type_init) op2=>operation: module_init(function, MODULE_INIT_QOM) op3=>operation: register_module_init(function, type) op1(right)->op2(right)->op3{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);op1=>operation: kvm_type_init op2=>operation: type_register_static(&kvm_accel_type) op3=>operation: type_register op4=>operation: type_register_internal op1(right)->op2(right)->op3(right)->op4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);op1=>operation: object_class_get_list op2=>operation: object_class_foreach op3=>operation: g_hash_table_foreach(object_class_foreach_tramp) op4=>operation: object_class_foreach_tramp op5=>operation: type_initialize op1(right)->op2(right)->op3(right)->op4(right)->op5{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);]]></content>
      <categories>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>QEMU QOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug QEMU with GDB]]></title>
    <url>%2F2018%2F12%2F24%2Fqemu-debug%2F</url>
    <content type="text"><![CDATA[学习Qemu-KVM虚拟机最重要的一步——调试QEMU，我们这里提前帮大家简单的总结归纳一下。Qemu的调试稍微有点特殊的地方就是，除了Qemu程序自身源代码的调试以外，我们可以通过Qemu+GDB来调试我们虚拟机程序。下面将两个不同方面的调试方法介绍一下。 1. 调试QEMU源码1gdb --args x86_64-softmmu/qemu-system-x86_64 --enable-kvm -m 1024 -drive file=test.qcow2 -append console=ttyS0 -kernel /boot/vmlinuz -initrd /boot/initrd.gz 当然以上参数中从–enable-kvm开始之后的参数因人而异，不尽相同。执行过之后，就会进入gdb界面，就可以跟其他普通应用程序一样，进行单步调试、设置断点、查看栈、寄存器内容等 2. 调试虚拟机这部分是本文的重点。跟调试应用程序不同，调试虚拟机时gdb和qemu分开执行，似乎并不能用gdb来调用qemu。长话短说，先来看如何启动qemu：1./x86_64-softmmu/qemu-system-x86_64 -s -S --enable-kvm -m 1024 -hda test.qcow2 同样，参数从–enable-kvm开始之后的参数也都不是必须的。着重了解下两个必须的参数：12-s shorthand for -gdb tcp::1234-S freeze CPU at startup (use &apos;c&apos; to start execution) 然后新开一个终端执行gdb，这样就跟调试应用程序一样，会看到同样的’(gdb)’ 提示符。在提示符中输入1target remote localhost:1234 1234是默认用于远程调试连接的端口号。然后设置断点”break *0x7c00”，这样就将一个断点设置在了bootloader被加载到的内存地址，接下来就任你玩了。 [root@ccd-sdv6 ~]# gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-100.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-redhat-linux-gnu". For bug reporting instructions, please see: . (gdb) target remote localhost:1234 Remote debugging using localhost:1234 0x0000fff0 in ?? () (gdb) c Continuing. Program received signal SIGINT, Interrupt. 0x00002bcb in ?? () (gdb) b *0x7c00 Breakpoint 1 at 0x7c00. (gdb) info breakpoints Num Type Disp Enb Address What 1 breakpoint keep y 0x00007c00 (gdb) 顺便附上一些用到的gdb的快捷键以及命令TUI 窗口123Ctrl + x, Ctrl + a好像等效Ctrl + x, a 一般也就按着Ctrl键，依次按下字母x 和a就可以再TUI和非TUI间切换 TUI 窗口概述在TUI模式中，可以显示以下几个窗口： 命令窗口用于GDB调试时的命令输入和命令结果输出显示，与普通GDB窗口无异。 源代码窗口用于显示程序源代码，包括当前运行行、中断以中断标识等。 汇编窗口显示当前程序的汇编代码。 寄存器窗口显示处理器的寄存器内容，当寄存器内容发生改变时会高亮显示。源代码窗口和汇编窗口会高亮显示程序运行位置并以’&gt;’符号标记。有两个特殊标记用于标识断点，第一个标记用于标识断点类型： B : 程序至少有一次运行到了该断点 b : 程序没有运行到过该断点 H : 程序至少有一次运行到了该硬件断点 h : 程序没有运行到过该硬件断点第二个标记用于标识断点使能与否: + : 断点使能Breakpointis enabled. - : 断点被禁用Breakpointis disabled. 三窗口模式1Ctrl + 2 使TUI的上半部分分割成两个窗口，连接按此快捷键可在三种组合中切换。寄存器窗口、代码窗口、汇编窗口 三个窗口只能同时显示两个，共3种组合。 更换激活窗口1Ctrl + o 之所以需要切换激活窗口，是因为有些快捷键，比如箭头上下左右，page up/down只有在当前窗口起作用 GDB commandc : continuer : runn : nexts : step TUI 特有命令info win ：显示正在显示的窗口大小信息layout next ：显示下一个窗口layout prev ：显示上一个窗口layout src ：显示源代码窗口layout asm ：显示汇编窗口layout split ：显示源代码和汇编窗口layout regs ：显示寄存器窗口focus next ： 将一个窗口置为激活状态focus prev ：将上一个窗口置为激活状态focus src : 将源代码窗口置为激活状态focus asm ：将汇编窗口置为激活状态focus regs ： 将寄存器窗口置为激活状态focus cmd ：将命令行窗口置为激活状态refresh ： 更新窗口，与C-L快捷键同 tuireg float ：寄存器窗口显示内容为浮点寄存器tuireg general ：寄存器窗口显示内容为普通寄存器tuireg next ：显示下一组寄存器，预定义的寄存器组: general, float,system, vector,all, save,restore.tuireg system ：显示上一组寄存器update ：更新源代码窗口到当前运行点winname + count ：增加指定窗口的高度winname + count ：减小指定窗口的高度tabset nchars : Set the width of tab stops to be nchars characters 条件断点：在gdb中可以watch一个寄存器，命令： 1watch $eax == 0x0000ffaa 另外，当我们想有条件的设置某一个断点的时候，命令如下：1break test.c:120 if $eax == 0x0000ffaa]]></content>
      <categories>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM 虚拟化原理4--内存]]></title>
    <url>%2F2018%2F12%2F10%2Fkvm-memory%2F</url>
    <content type="text"><![CDATA[内存虚拟化简介前一章介绍了CPU虚拟化的内容，这一章介绍一下KVM的内存虚拟化原理。可以说内存是除了CPU外最重要的组件，Guest最终使用的还是宿主机的内存，所以内存虚拟化其实就是关于如何做Guest到宿主机物理内存之间的各种地址转换，如何转换会让转换效率更高呢，KVM经历了三代的内存虚拟化技术，大大加快了内存的访问速率。 传统的地址转换在保护模式下，普通的应用进程使用的都是自己的虚拟地址空间，一个64位的机器上的每一个进程都可以访问0到2^64的地址范围，实际上内存并没有这么多，也不会给你这么多。对于进程而言，他拥有所有的内存，对内核而言，只分配了一小段内存给进程，待进程需要更多的进程的时候再分配给进程。通常应用进程所使用的内存叫做虚拟地址，而内核所使用的是物理内存。内核负责为每个进程维护虚拟地址到物理内存的转换关系映射。首先，逻辑地址需要转换为线性地址，然后由线性地址转换为物理地址。 1逻辑地址 ==&gt; 线性地址 ==&gt; 物理地址 逻辑地址和线性地址之间通过简单的偏移来完成。 一个完整的逻辑地址 = [段选择符：段内偏移地址]，查找GDT或者LDT（通过寄存器gdtr，ldtr）找到描述符，通过段选择符(selector)前13位在段描述符做index，找到Base地址，Base+offset就是线性地址。 为什么要这么做？据说是Intel为了保证兼容性。 逻辑地址到线性地址的转换在虚拟化中没有太多的需要介绍的，这一层不存在实际的虚拟化操作，和传统方式一样，最重要的是线性地址到物理地址这一层的转换。 传统的线性地址到物理地址的转换由CPU的页式内存管理，页式内存管理。页式内存管理负责将线性地址转换到物理地址，一个线性地址被分五段描述，第一段为基地址，通过与当前CR3寄存器（CR3寄存器每个进程有一个，线程共享，当发生进程切换的时候，CR3被载入到对应的寄存器中，这也是各个进程的内存隔离的基础）做运算，得到页表的地址index，通过四次运算，最终得到一个大小为4K的页（有可能更大，比如设置了hugepages以后）。整个过程都是CPU完成，进程不需要参与其中，如果在查询中发现页已经存在，直接返回物理地址，如果页不存在，那么将产生一个缺页中断，内核负责处理缺页中断，并把页加载到页表中，中断返回后，CPU获取到页地址后继续进行运算。 KVM中的内存结构由于qemu-kvm进程在宿主机上作为一个普通进程，那对于Guest而言，需要的转换过程就是这样。 12345678910111213Guest虚拟内存地址(GVA) | Guest线性地址 | Guest物理地址(GPA) | Guest ------------------ | HV HV虚拟地址(HVA) | HV线性地址 | HV物理地址(HPA) What’s the fu*k ？这么多…别着急，Guest虚拟地址到HV线性地址之间的转换和HV虚拟地址到线性地址的转换过程可以省略，这样看起来就更清晰一点。 123456789Guest虚拟内存地址(GVA) | Guest物理地址(GPA) | Guest ------------------ | HV HV虚拟地址(HVA) | HV物理地址(HPA) 前面也说到KVM通过不断的改进转换过程，让KVM的内存虚拟化更加的高效，我们从最初的软件虚拟化的方式介绍。 软件虚拟化方式实现第一层转换，由GVA-&gt;GPA的转换和传统的转换关系一样，通过查找CR3然后进行页表查询，找到对应的GPA，GPA到HVA的关系由qemu-kvm负责维护，我们在第二章KVM启动过程的demo里面就有介绍到怎样给KVM映射内存，通过mmap的方式把HV的内存映射给Guest。 123456struct kvm_userspace_memory_region region = &#123; .slot = 0, .guest_phys_addr = 0x1000, .memory_size = 0x1000, .userspace_addr = (uint64_t)mem,&#125;; 可以看到，qemu-kvm的kvm_userspace_memory_region结构体描述了guest的物理地址起始位置和内存大小，然后描述了Guest的物理内存在HV的映射userspace_addr，通过多个slot，可以把不连续的HV的虚拟地址空间映射给Guest的连续的物理地址空间。 软件模拟的虚拟化方式由qemu-kvm来负责维护GPA-&gt;HVA的转换，然后再经过一次HVA-&gt;HPA的方式，从过程上来看，这样的访问是很低效的，特别是在当GVA到GPA转换时候产生缺页中断，这时候产生一个异常Guest退出，HV捕获异常后计算出物理地址（分配新的内存给Guest），然后重新Entry。这个过程会可能导致频繁的Guest退出，且转换过程过长。于是KVM使用了一种叫做影子页表的技术。 影子页表的虚拟化方式影子页表的出现，就是为了减少地址转换带来的开销，直接把GVA转换到HVP的技术。在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3保存了Guest中的页表基地址，然后载入MMU来做地址转换。在加入了影子页表的技术后，当访问到CR3寄存器的时候（可能是由于Guest进程后导致的），KVM捕获到这个操作，CPU虚拟化章节 EXIT_REASON_CR_ACCESS，qemu-kvm通过载入特俗的CR3和影子页表来欺骗Guest这个就是真实的CR3，后面的操作就和传统的访问内存的方式一致，当需要访问物理内存的时候，只会经过一层的影子页表的转换。 影子页表由qemu-kvm进程维护，实际上就是一个Guest的页表到宿主机页表的映射，每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录。在初次GVA-&gt;HPA的转换时候，影子页表没有建立，此时Guest产生缺页中断，和传统的转换过程一样，经过两次转换(VA-&gt;PA)，然后影子页表记录GVA-&gt;GPA-&gt;HVA-&gt;HPA。这样产生GVA-&gt;GPA的直接关系，保存到影子页表中。 影子页表的引入，减少了GVA-&gt;HPA的转换过程，但是坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表，这将带来很大的内存开销，同时影子页表的建立是很耗时的，如果Guest进程过多，将导致频繁的影子页表的导入与导出，虽然用了cache技术，但是还是软件层面的，效率并不是最好，所以Intel和AMD在此基础上提供了硬件虚拟化技术。 EPT硬件加速的虚拟化方式EPT(extended page table)可以看做一个硬件的影子页表，在Guest中通过增加EPT寄存器，当Guest产生了CR3和页表的访问的时候，由于对CR3中的页表地址的访问是GPA，当地址为空时候，也就是Page fault后，产生缺页异常，如果在软件模拟或者影子页表的虚拟化方式中，此时会有VM退出，qemu-kvm进程接管并获取到此异常。但是在EPT的虚拟化方式中，qemu-kvm忽略此异常，Guest并不退出，而是按照传统的缺页中断处理，在缺页中断处理的过程中会产生EXIT_REASON_EPT_VIOLATION，Guest退出，qemu-kvm捕获到异常后，分配物理地址并建立GVA-&gt;HPA的映射，并保存到EPT中，将EPT载入到MMU，下次转换时候直接查询根据CR3查询EPT表来完成GVA-&gt;HPA的转换。以后的转换都由硬件直接完成，大大提高了效率，且不需要为每个进程维护一套页表，减少了内存开销。在笔者的测试中，Guest和HV的内存访问速率对比为3756MB/s对比4340MB/s。可以看到内存访问已经很接近宿主机的水平了。 总结KVM内存的虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程，Guest使用的依然是宿主机的物理内存，只是在这个过程中怎样减少转换带来的开销成为优化的主要点。KVM经过软件模拟-&gt;影子页表-&gt;EPT的技术的进化，效率也越来越高。]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM 虚拟化原理3--CPU]]></title>
    <url>%2F2018%2F12%2F10%2Fkvm-cpu%2F</url>
    <content type="text"><![CDATA[CPU 虚拟化简介上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。 用一张图来解释更为贴切。 VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。 Intel-V 技术Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。 Intel-V虚拟化技术结构Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。比如说一个IO操作： 1int nread = read(fd, buffer, 1024); 当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。 12345movel $3,%eaxmovel fd,%ebxmovel buffer,%ecxmovel 1024,%edx int $0x80 Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。 Intel的虚拟架构基本上分两个部分: 虚拟机监视器 客户机（Guest VM) 虚拟机监视器（Virtual-machine monitors - VMM)虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。 Guest这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。 VMM 与 Guest 的切换 Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。 VMM 的生命周期如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。 VMCS （Virtual-Machine control structure)顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。 Guest exit Reason下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123; [EXIT_REASON_EXCEPTION_NMI] = handle_exception, [EXIT_REASON_EXTERNAL_INTERRUPT] = handle_external_interrupt, [EXIT_REASON_TRIPLE_FAULT] = handle_triple_fault, [EXIT_REASON_NMI_WINDOW] = handle_nmi_window, // 访问了IO设备 [EXIT_REASON_IO_INSTRUCTION] = handle_io, // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试 [EXIT_REASON_CR_ACCESS] = handle_cr, [EXIT_REASON_DR_ACCESS] = handle_dr, [EXIT_REASON_CPUID] = handle_cpuid, // 访问了MSR寄存器 [EXIT_REASON_MSR_READ] = handle_rdmsr, [EXIT_REASON_MSR_WRITE] = handle_wrmsr, [EXIT_REASON_PENDING_INTERRUPT] = handle_interrupt_window, // Guest执行了HLT指令，Demo开胃菜就是这个指令 [EXIT_REASON_HLT] = handle_halt, [EXIT_REASON_INVD] = handle_invd, [EXIT_REASON_INVLPG] = handle_invlpg, [EXIT_REASON_RDPMC] = handle_rdpmc, // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机） [EXIT_REASON_VMCALL] = handle_vmcall, [EXIT_REASON_VMCLEAR] = handle_vmclear, [EXIT_REASON_VMLAUNCH] = handle_vmlaunch, [EXIT_REASON_VMPTRLD] = handle_vmptrld, [EXIT_REASON_VMPTRST] = handle_vmptrst, [EXIT_REASON_VMREAD] = handle_vmread, [EXIT_REASON_VMRESUME] = handle_vmresume, [EXIT_REASON_VMWRITE] = handle_vmwrite, [EXIT_REASON_VMOFF] = handle_vmoff, [EXIT_REASON_VMON] = handle_vmon, [EXIT_REASON_TPR_BELOW_THRESHOLD] = handle_tpr_below_threshold, // 访问了高级PCI设备 [EXIT_REASON_APIC_ACCESS] = handle_apic_access, [EXIT_REASON_APIC_WRITE] = handle_apic_write, [EXIT_REASON_EOI_INDUCED] = handle_apic_eoi_induced, [EXIT_REASON_WBINVD] = handle_wbinvd, [EXIT_REASON_XSETBV] = handle_xsetbv, // 进程切换 [EXIT_REASON_TASK_SWITCH] = handle_task_switch, [EXIT_REASON_MCE_DURING_VMENTRY] = handle_machine_check, // ept 是Intel的一个硬件内存虚拟化技术 [EXIT_REASON_EPT_VIOLATION] = handle_ept_violation, [EXIT_REASON_EPT_MISCONFIG] = handle_ept_misconfig, // 执行了暂停指令 [EXIT_REASON_PAUSE_INSTRUCTION] = handle_pause, [EXIT_REASON_MWAIT_INSTRUCTION] = handle_invalid_op, [EXIT_REASON_MONITOR_INSTRUCTION] = handle_invalid_op, [EXIT_REASON_INVEPT] = handle_invept,&#125;; 总结KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM 虚拟化原理2— QEMU启动过程]]></title>
    <url>%2F2018%2F12%2F10%2Fkvm-boot%2F</url>
    <content type="text"><![CDATA[虚拟机启动过程1234567891011121314151617181920212223第一步，获取到kvm句柄kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);第二步，创建虚拟机，获取到虚拟机句柄。vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);第四步，创建vCPUvcpufd = ioctl(vmfd, KVM_CREATE_VCPU, vcpuio)第五步，为vCPU分配内存vcpu_size=ioctl(kvmfd, KVM_GET_VCPU_MMAP_SIZE, NULL)run = (struct kvm_run*)mmap(NULL, mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpufd, 0)第六步，创建vCPU个数的线程并运行虚拟机。ioctl(vcpufd, KVM_RUN, 0);将汇编代码加载到用户内存中，并且设置vCPU的寄存器，例如RIP第七步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。while(1) &#123; ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0); &#125;;这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。 12345678910open(&quot;/dev/kvm&quot;)ioctl(KVM_CREATE_VM)ioctl(KVM_CREATE_VCPU)for (;;) &#123; ioctl(KVM_RUN) switch (exit_reason) &#123; case KVM_EXIT_IO: /* ... */ case KVM_EXIT_HLT: /* ... */ &#125;&#125; 关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。 KVM ioctl接口文档 先来一个KVM API开胃菜下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。4\n (并不直接输出\n，而是换了一行），hlt 指令表示虚拟机退出 12345678910.globl _start .code16_start: mov $0x3f8, %dx add %bl, %al add $&apos;0&apos;, %al out %al, (%dx) mov $&apos;\n&apos;, %al out %al, (%dx) hlt 我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件 12as -32 bin.S -o bin.old -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o 查看一下二进制格式 12345678910111213➜ demo1 hexdump -C bin.bin00000000 ba f8 03 00 d8 04 30 ee b0 0a ee f4 |......0.....|0000000c对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了 const uint8_t code[] = &#123; 0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */ 0x00, 0xd8, /* add %bl, %al */ 0x04, &apos;0&apos;, /* add $&apos;0&apos;, %al */ 0xee, /* out %al, (%dx) */ 0xb0, &apos;\n&apos;, /* mov $&apos;\n&apos;, %al */ 0xee, /* out %al, (%dx) */ 0xf4, /* hlt */ &#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/kvm.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int main(void)&#123; int kvm, vmfd, vcpufd, ret; const uint8_t code[] = &#123; 0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */ 0x00, 0xd8, /* add %bl, %al */ 0x04, &apos;0&apos;, /* add $&apos;0&apos;, %al */ 0xee, /* out %al, (%dx) */ 0xb0, &apos;\n&apos;, /* mov $&apos;\n&apos;, %al */ 0xee, /* out %al, (%dx) */ 0xf4, /* hlt */ &#125;; uint8_t *mem; struct kvm_sregs sregs; size_t mmap_size; struct kvm_run *run; // 获取 kvm 句柄 第一步 kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC); if (kvm == -1) err(1, &quot;/dev/kvm&quot;); // 确保是正确的 API 版本 ret = ioctl(kvm, KVM_GET_API_VERSION, NULL); if (ret == -1) err(1, &quot;KVM_GET_API_VERSION&quot;); if (ret != 12) errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret); // 创建一虚拟机 第二步 vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0); if (vmfd == -1) err(1, &quot;KVM_CREATE_VM&quot;); // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中 mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (!mem) err(1, &quot;allocating guest memory&quot;); memcpy(mem, code, sizeof(code)); // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录 struct kvm_userspace_memory_region region = &#123; .slot = 0, .guest_phys_addr = 0x1000, .memory_size = 0x1000, .userspace_addr = (uint64_t)mem, &#125;; // 设置 KVM 的内存区域 第三部 ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region); if (ret == -1) err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;); // 创建虚拟CPU 第四部 vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0); if (vcpufd == -1) err(1, &quot;KVM_CREATE_VCPU&quot;); // 获取 KVM 运行时结构的大小 ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL); if (ret == -1) err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;); mmap_size = ret; if (mmap_size &lt; sizeof(*run)) errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;); // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息 第五步 run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0); if (!run) err(1, &quot;mmap vcpu&quot;); // 获取特殊寄存器 第六步 ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs); if (ret == -1) err(1, &quot;KVM_GET_SREGS&quot;); // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置 sregs.cs.base = 0; sregs.cs.selector = 0; // KVM_SET_SREGS 设置特殊寄存器 ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs); if (ret == -1) err(1, &quot;KVM_SET_SREGS&quot;); // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。 // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令 struct kvm_regs regs = &#123; .rip = 0x1000, .rax = 2, // 设置 ax 寄存器初始值为 2 .rbx = 2, // 同理 .rflags = 0x2, // 初始化flags寄存器，x86架构下需要设置，否则会粗错 &#125;; ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs); if (ret == -1) err(1, &quot;KVM_SET_REGS&quot;); // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令 第七步 while (1) &#123; // 开始运行虚拟机 ret = ioctl(vcpufd, KVM_RUN, NULL); if (ret == -1) err(1, &quot;KVM_RUN&quot;); // 获取虚拟机退出原因 switch (run-&gt;exit_reason) &#123; case KVM_EXIT_HLT: puts(&quot;KVM_EXIT_HLT&quot;); return 0; // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以 // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器 // 后面CPU虚拟化会讲到这部分 // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到 // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备 case KVM_EXIT_IO: if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1) putchar(*(((char *)run) + run-&gt;io.data_offset)); else errx(1, &quot;unhandled KVM_EXIT_IO&quot;); break; case KVM_EXIT_FAIL_ENTRY: errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;, (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason); case KVM_EXIT_INTERNAL_ERROR: errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror); default: errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason); &#125; &#125;&#125; 编译并运行这个demo 1234gcc -g demo.c -o demo➜ demo1 ./demo4KVM_EXIT_HLT 另外一个简单的QEMU emulator demoIBM的徐同学有做过介绍，在此基础上我再详细介绍一下qemu-kvm的启动过程。 123456789.globl _start .code16_start: xorw %ax, %ax # 将 ax 寄存器清零loop1: out %ax, $0x10 # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。 inc %ax # ax 值加一 jmp loop1 # 继续循环 这个汇编的作用就是一直不停的向0x10端口输出一字节的值。 从main函数开始说起 12345678910111213141516171819202122232425262728293031int main(int argc, char **argv) &#123; int ret = 0; // 初始化kvm结构体 struct kvm *kvm = kvm_init(); if (kvm == NULL) &#123; fprintf(stderr, &quot;kvm init fauilt\n&quot;); return -1; &#125; // 创建VM，并分配内存空间 if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123; fprintf(stderr, &quot;create vm fault\n&quot;); return -1; &#125; // 加载镜像 load_binary(kvm); // only support one vcpu now kvm-&gt;vcpu_number = 1; // 创建执行现场 kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread); // 启动虚拟机 kvm_run_vm(kvm); kvm_clean_vm(kvm); kvm_clean_vcpu(kvm-&gt;vcpus); kvm_clean(kvm);&#125; 第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。 1234567891011121314struct kvm &#123; int dev_fd; // /dev/kvm 的句柄 int vm_fd; // GUEST 的句柄 __u64 ram_size; // GUEST 的内存大小 __u64 ram_start; // GUEST 的内存起始地址， // 这个地址是qemu emulator通过mmap映射的地址 int kvm_version; struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、 // 允许对guest的地址做分段。将多个slot组成线性地址 struct vcpu *vcpus; // vcpu 数组 int vcpu_number; // vcpu 个数&#125;; 初始化 kvm 结构体。 12345678910111213struct kvm *kvm_init(void) &#123; struct kvm *kvm = malloc(sizeof(struct kvm)); kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR); // 打开 /dev/kvm 获取 kvm 句柄 if (kvm-&gt;dev_fd &lt; 0) &#123; perror(&quot;open kvm device fault: &quot;); return NULL; &#125; kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0); // 获取 kvm API 版本 return kvm;&#125; 第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。 12345678910111213141516171819202122232425262728293031323334353637383940int kvm_create_vm(struct kvm *kvm, int ram_size) &#123; int ret = 0; // 调用 KVM_CREATE_KVM 接口获取 vm 句柄 kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0); if (kvm-&gt;vm_fd &lt; 0) &#123; perror(&quot;can not create vm&quot;); return -1; &#125; // 为 kvm 分配内存。通过系统调用. kvm-&gt;ram_size = ram_size; kvm-&gt;ram_start = (__u64)mmap(NULL, kvm-&gt;ram_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0); if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123; perror(&quot;can not mmap ram&quot;); return -1; &#125; // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口 // 只有一个内存槽 kvm-&gt;mem.slot = 0; // guest 物理内存起始地址 kvm-&gt;mem.guest_phys_addr = 0; // 虚拟机内存大小 kvm-&gt;mem.memory_size = kvm-&gt;ram_size; // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start; // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。 ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem)); if (ret &lt; 0) &#123; perror(&quot;can not set user memory region&quot;); return ret; &#125; return ret;&#125; 接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。 1234567891011121314151617181920void load_binary(struct kvm *kvm) &#123; int fd = open(BINARY_FILE, O_RDONLY); // 打开这个二进制文件(镜像） if (fd &lt; 0) &#123; fprintf(stderr, &quot;can not open binary file\n&quot;); exit(1); &#125; int ret = 0; char *p = (char *)kvm-&gt;ram_start; while(1) &#123; ret = read(fd, p, 4096); // 将镜像内容加载到虚拟机的内存中 if (ret &lt;= 0) &#123; break; &#125; printf(&quot;read size: %d&quot;, ret); p += ret; &#125;&#125; 加载完镜像后，需要初始化vCPU，以便能够运行镜像内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct vcpu &#123; int vcpu_id; // vCPU id，vCPU int vcpu_fd; // vCPU 句柄 pthread_t vcpu_thread; // vCPU 线程句柄 struct kvm_run *kvm_run; // KVM 运行时结构，也可以看做是上下文 int kvm_run_mmap_size; // 运行时结构大小 struct kvm_regs regs; // vCPU的寄存器 struct kvm_sregs sregs; // vCPU的特殊寄存器 void *(*vcpu_thread_func)(void *); // 线程执行函数&#125;;struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123; // 申请vcpu结构 struct vcpu *vcpu = malloc(sizeof(struct vcpu)); // 只有一个 vCPU，所以这里只初始化一个 vcpu-&gt;vcpu_id = 0; // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回） vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id); if (vcpu-&gt;vcpu_fd &lt; 0) &#123; perror(&quot;can not create vcpu&quot;); return NULL; &#125; // 获取KVM运行时结构大小 vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0); if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123; perror(&quot;can not get vcpu mmsize&quot;); return NULL; &#125; printf(&quot;%d\n&quot;, vcpu-&gt;kvm_run_mmap_size); // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作 // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息 vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0); if (vcpu-&gt;kvm_run == MAP_FAILED) &#123; perror(&quot;can not mmap kvm_run&quot;); return NULL; &#125; // 设置线程执行函数 vcpu-&gt;vcpu_thread_func = fn; return vcpu;&#125; 最后一步，以上工作就绪后，启动虚拟机。 12345678910111213void kvm_run_vm(struct kvm *kvm) &#123; int i = 0; for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123; // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程 if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123; perror(&quot;can not create kvm thread&quot;); exit(1); &#125; &#125; pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);&#125; 启动虚拟机其实就是创建线程，并执行相应的线程回调函数。线程回调函数在kvm_init_vcpu的时候传入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114void *kvm_cpu_thread(void *data) &#123; // 获取参数 struct kvm *kvm = (struct kvm *)data; int ret = 0; // 设置KVM的参数 kvm_reset_vcpu(kvm-&gt;vcpus); while (1) &#123; printf(&quot;KVM start run\n&quot;); // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。 ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0); if (ret &lt; 0) &#123; fprintf(stderr, &quot;KVM_RUN failed\n&quot;); exit(1); &#125; // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存 // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因 switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123; case KVM_EXIT_UNKNOWN: printf(&quot;KVM_EXIT_UNKNOWN\n&quot;); break; case KVM_EXIT_DEBUG: printf(&quot;KVM_EXIT_DEBUG\n&quot;); break; // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并 // 把执行权交给emulator case KVM_EXIT_IO: printf(&quot;KVM_EXIT_IO\n&quot;); printf(&quot;out port: %d, data: %d\n&quot;, kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port, *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset) ); sleep(1); break; // 虚拟机执行了memory map IO操作 case KVM_EXIT_MMIO: printf(&quot;KVM_EXIT_MMIO\n&quot;); break; case KVM_EXIT_INTR: printf(&quot;KVM_EXIT_INTR\n&quot;); break; case KVM_EXIT_SHUTDOWN: printf(&quot;KVM_EXIT_SHUTDOWN\n&quot;); goto exit_kvm; break; default: printf(&quot;KVM PANIC\n&quot;); goto exit_kvm; &#125; &#125;exit_kvm: return 0;&#125;void kvm_reset_vcpu (struct vcpu *vcpu) &#123; if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123; perror(&quot;can not get sregs\n&quot;); exit(1); &#125; // #define CODE_START 0x1000 /* sregs 结构体 x86 struct kvm_sregs &#123; struct kvm_segment cs, ds, es, fs, gs, ss; struct kvm_segment tr, ldt; struct kvm_dtable gdt, idt; __u64 cr0, cr2, cr3, cr4, cr8; __u64 efer; __u64 apic_base; __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64]; &#125;; */ // cs 为code start寄存器，存放了程序的起始地址 vcpu-&gt;sregs.cs.selector = CODE_START; vcpu-&gt;sregs.cs.base = CODE_START * 16; // ss 为堆栈寄存器，存放了堆栈的起始位置 vcpu-&gt;sregs.ss.selector = CODE_START; vcpu-&gt;sregs.ss.base = CODE_START * 16; // ds 为数据段寄存器，存放了数据开始地址 vcpu-&gt;sregs.ds.selector = CODE_START; vcpu-&gt;sregs.ds.base = CODE_START *16; // es 为附加段寄存器 vcpu-&gt;sregs.es.selector = CODE_START; vcpu-&gt;sregs.es.base = CODE_START * 16; // fs, gs 同样为段寄存器 vcpu-&gt;sregs.fs.selector = CODE_START; vcpu-&gt;sregs.fs.base = CODE_START * 16; vcpu-&gt;sregs.gs.selector = CODE_START; // 为vCPU设置以上寄存器的值 if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123; perror(&quot;can not set sregs&quot;); exit(1); &#125; // 设置寄存器标志位 vcpu-&gt;regs.rflags = 0x0000000000000002ULL; // rip 表示了程序的起始指针，地址为 0x0000000 // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位 // 所以虚拟机开始的时候会直接运行binary vcpu-&gt;regs.rip = 0; // rsp 为堆栈顶 vcpu-&gt;regs.rsp = 0xffffffff; // rbp 为堆栈底部 vcpu-&gt;regs.rbp= 0; if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123; perror(&quot;KVM SET REGS\n&quot;); exit(1); &#125;&#125; 运行一下结果，可以看到当虚拟机执行了指令 out %ax, $0x10 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。 123456789101112131415161718➜ kvmsample git:(master) ✗ ./kvmsampleread size: 712288KVM start runKVM_EXIT_IOout port: 16, data: 0KVM start runKVM_EXIT_IOout port: 16, data: 1KVM start runKVM_EXIT_IOout port: 16, data: 2KVM start runKVM_EXIT_IOout port: 16, data: 3KVM start runKVM_EXIT_IOout port: 16, data: 4... 总结虚拟机的启动过程基本上可以这么总结：创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。 当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。 源代码本文中提到的所有源代码都可以从这里下载到，仅供大家学习交流使用github|kvm-cheat]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM 虚拟化原理1 -- 概述]]></title>
    <url>%2F2018%2F12%2F10%2Fkvm-overview%2F</url>
    <content type="text"><![CDATA[KVM虚拟化简介KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。 Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。 正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。 KVM有如下特点： guest作为一个普通进程运行于宿主机 guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度 KVM整体架构 虚拟CPU虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。 KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。 虚拟IO设备guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。 虚拟内存guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。 # 虚拟化概述 ## CPU虚拟化 ### 指令的模拟 #### 陷入（利用处理器的保护机制，中断和异常） 1，基于处理器保护机制出发的异常 2，虚拟机主动触发的异常 3，异步zhognduan ##### 虚拟处理器 ##### 虚拟寄存器 ##### 上下文 ### 中断和异常的虚拟化 ### 对称对处理器技术的虚拟化（SMP） #### VMM选择第一个虚拟处理器，BSP #### 其他虚拟处理器，AP ## Memory虚拟化 ### 物理地址从0开始 ### 内存地址连续 ## I/O虚拟化 ### 设备发现 #### 总线类型的设备 ##### 总线类型不可枚举 ###### ISA设备 ###### PS/2键盘、鼠标、RTC ###### 传统IDE控制器 ##### 总线类型可枚举、资源可配置 ###### PCI #### 完全模拟的设备 ##### Frontend / backend 模型 ### 访问截获 #### I/O端口的访问 ##### I/O位图来决定 #### MMIO访问 ##### 页表项设置为无效 ### 设备模拟]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QMP 简介]]></title>
    <url>%2F2018%2F12%2F10%2Fqmp-introduction%2F</url>
    <content type="text"><![CDATA[什么是QMP协议QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。 QMP协议有哪些特征1）轻量、基于文本、指令格式易于解析，因为它是json格式的；2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。 QMP协议有哪些模式 有两种模式：Capabilities Negotiation模式和Command模式。 那么该如何建立qmp连接呢这里简要介绍通过tcp和unix socket使用qmp。 通过TCP使用QMP使用-qmp添加qmp相关参数： 1./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp tcp:localhost:1234,server,nowait 新开一个终端使用telnet 链接localhost：1234 1telnet localhost 1234 之后就可以使用qmp的命令和虚拟机交互了 123456789[root@localhost ~]# telnet localhost 1234Trying ::1...Connected to localhost.Escape character is &apos;^]&apos;.&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;&#123;&quot;return&quot;: &#123;&#125;&#125;&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125; 通过unix socket使用QMP使用unix socket创建qmp： 1./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait 使用nc连接该socket: 1nc -U /tmp/qmp-test 之后就一样了。 123456[root@localhost qmp]# nc -U /tmp/qmp-test&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;&#123;&quot;return&quot;: &#123;&#125;&#125;&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125; QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。 自动批量发送QMP命令可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135# QEMU Monitor Protocol Python class## Copyright (C) 2009 Red Hat Inc.## This work is licensed under the terms of the GNU GPL, version 2. See# the COPYING file in the top-level directory.import socket, json, time, commandsfrom optparse import OptionParserclass QMPError(Exception): passclass QMPConnectError(QMPError): passclass QEMUMonitorProtocol: def connect(self): print self.filename self.sock.connect(self.filename) data = self.__json_read() if data == None: raise QMPConnectError if not data.has_key(&apos;QMP&apos;): raise QMPConnectError return data[&apos;QMP&apos;][&apos;capabilities&apos;] def close(self): self.sock.close() def send_raw(self, line): self.sock.send(str(line)) return self.__json_read() def send(self, cmdline, timeout=30, convert=True): end_time = time.time() + timeout if convert: cmd = self.__build_cmd(cmdline) else: cmd = cmdline print(&quot;*cmdline = %s&quot; % cmd) print cmd self.__json_send(cmd) while time.time() &lt; end_time: resp = self.__json_read() if resp == None: return (False, None) elif resp.has_key(&apos;error&apos;): return (False, resp[&apos;error&apos;]) elif resp.has_key(&apos;return&apos;): return (True, resp[&apos;return&apos;]) def read(self, timeout=30): o = &quot;&quot; end_time = time.time() + timeout while time.time() &lt; end_time: try: o += self.sock.recv(1024) if len(o) &gt; 0: break except: time.sleep(0.01) if len(o) &gt; 0: return json.loads(o) else: return None def __build_cmd(self, cmdline): cmdargs = cmdline.split() qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125; for arg in cmdargs[1:]: opt = arg.split(&apos;=&apos;) try: value = int(opt[1]) except ValueError: value = opt[1] qmpcmd[&apos;arguments&apos;][opt[0]] = value print(&quot;*cmdline = %s&quot; % cmdline) return qmpcmd def __json_send(self, cmd): # XXX: We have to send any additional char, otherwise # the Server won&apos;t read our input self.sock.send(json.dumps(cmd) + &apos; &apos;) def __json_read(self): try: return json.loads(self.sock.recv(1024)) except ValueError: return def __init__(self, filename, protocol=&quot;tcp&quot;): if protocol == &quot;tcp&quot;: self.filename = (&quot;localhost&quot;, int(filename)) self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) elif protocol == &quot;unix&quot;: self.filename = filename print self.filename self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) #self.sock.setblocking(0) self.sock.settimeout(5)if __name__ == &quot;__main__&quot;: parser = OptionParser() parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;) parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;) parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;) def usage(): parser.print_help() sys.exit(1) options, args = parser.parse_args() print options if len(args) &gt; 0: usage() num = int(options.num) qmp_filename = options.port qmp_protocol = options.protocol qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol) qmp_socket.connect() qmp_socket.send(&quot;qmp_capabilities&quot;) qmp_socket.close()###########################################################Usage#Options:# -h, --help show this help message and exit# -n NUM, --num=NUM Times want to try# -f PORT, --file=PORT QMP port/filename# -p PROTOCOL, --protocol=PROTOCOL# QMP protocol# e.g: # python xxxxx.py -n $NUM -f $PORT########################################################## 参考文档关于QMP更详细的文档，可以参考其官方文档：https://wiki.qemu.org/Documentation/QMP]]></content>
      <categories>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>QEMU</tag>
        <tag>QMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next主题]]></title>
    <url>%2F2018%2F11%2F26%2Fhexo-next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~ 从印象笔记到简书到Hexo我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。 但使用了简书3个月之后，我就发现了一些问题： 首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦； 其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容； 另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一； 在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。 Hexo部署hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。 安装前提安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下： image-20180809141924679安装Hexo安装好node.js和git后，可以通过npm来安装Hexo。 npm install -g hexo-cli建站之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹： hexo init cd npm install 就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。 文件夹开始初始化了站内内容新建好的文件夹目录如下： .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes这里解释一下各个文件夹的作用： config.yml博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。 package.json应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。 scaffoldsscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。 这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容 sourcesource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。 themes放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。 初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。 Hexo命令init新建一个网站。 hexo init new新建文章或页面。 hexo new “title”这里的对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。 默认是添加posts。 然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。 generate生成静态页面 hexo generate也可以简写成 hexo gdeploy将内容部署到网站 hexo deploy也可以简写成 hexo -dpublish发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。 hexo publish server启动服务器，默认情况下，访问网站为http://localhost:4000/ hexo server也可以简写成 hexo s根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是： hexo n 新建文章hexo s 启动服务器，在本地查看内容hexo g 生成静态页面hexo deploy 部署到网站以上四个步骤。 其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。 搭建好后我们在localhost:4000就可以看到这样的博客内容： image-20180809152743968实际操作我在新建博客之后，做了以下改动： 创建“分类”页面新建分类页面 hexo new page categories给分类页面添加类型 我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。 title: 文章分类date: 2017-05-27 13:47:40 type: “categories” #这部分是新添加的给模板添加分类属性 现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。 title: hexo+next主题date: 1543200599000categories:tags:给文章添加分类 现在我们可以找到一篇文章，然后尝试给它添加分类 layout: poststitle: 写给小白的express学习笔记1： express-static文件静态管理date: 2018-06-07 00:38:36categories: 学习笔记tags: [node.js, express] 创建“标签”页面创建”标签”页的方式和创建“分类”一样。 新建“标签”页面 hexo new page tags给标签页面添加类型 我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。 title: tagsdate: 2018-08-06 22:48:29type: “tags” #新添加的内容给文章添加标签 有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开 layout: poststitle: 写给小白的express学习笔记1： express-static文件静态管理date: 2018-06-07 00:38:36categories: 学习笔记tags: [node.js, express]第二种写法是用-短划线列出来 layout: poststitle: 写给小白的express学习笔记1： express-static文件静态管理date: 2018-06-07 00:38:36categories: 学习笔记tags: node.js express部署域名紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。 部署Github首先你必须有一个github账号 然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选) image-20180809153134467然后在setting里添加生成页面的选项 image-20180809153304980image-20180809153343362这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径 image-20180809153610047这里注意两小点： 属性和内容之间一定要有一个空格，配置文件有自己的格式规范如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了 image-20180809153933270部署自己的域名首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的； 购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了； 认证成功后需要解析域名 image-20180809154942783image-20180809155013659记录类型选CNAME，记录值是自己github生成页面的地址。 在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下 这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可 npm i hexo-generator-cname –save最后hexo g &amp;&amp; hexo deploy就可以了 NexT主题hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。 首先，NexT也有中文文档，然后我们就可以开始了。 安装我是用的git clone的方法，文档中还有其他方法 $ git clone https://github.com/iissnan/hexo-theme-next themes/next设置主题在hexo根目录下的配置文件config.yml里设置主题 theme: next配置主题接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。 官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用 菜单栏 menu原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive schedule: /schedule/ || calendarsitemap: /sitemap.xml || sitemapcommonweal: /404/ || heartbeat注意点： 如果事先没有通过hexo new page 来创建页面的话，即使在配置文件中取消注释，页面也没法显示我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里||后面是fontAwesome里的文件对应的名称menu_icons记得选enable: true（默认应该是true）我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th 读书: /books || book 电影: /movies || film archives: /archives/ || archive schedule: /schedule/ || calendarsitemap: /sitemap.xml || sitemapcommonweal: /404/ || heartbeat主题风格 schemes主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。 Muse image-20180809164700600Mist image-20180809164749052Pisces image-20180809164925685Gemini image-20180809165023401选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。 底部建站时间和图标修改修改主题的配置文件： footer: Specify the date when the site was setup.If not defined, current year will be used. since: 2018 Icon between year and copyright info. icon: snowflake-o If not defined, will be used author from Hexo main config. copyright: ————————————————————-Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: false 我在这部分做了这样几件事： 把用户的图标从小人user改成了雪花snowflake-ocopyright留空，显示成页面author即我的名字powered: false把hexo的授权图片取消了theme: enable:false 把主题的内容也取消了这样底部信息比较简单。 image-20180809172835606个人社交信息 social在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。 social: GitHub: https://github.com/XuQuan-nikkkki || github E-Mail: mailto:xuquan1225@hotmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook注意点： ||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球网站动画效果为了网站响应速度我们可以把网站的动画关掉 motion: enable: false但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。 motion: enable: true async: true Canvas-nestcanvas_nest: true three_wavesthree_waves: false canvas_linescanvas_lines: false canvas_spherecanvas_sphere: false评论系统NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。 方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。 Disqusdisqus: enable: true shortname: xuquan count: true统计文章字数和阅读时间post_wordcount: item_text: true wordcount: true # 文章字数 min2read: true # 阅读时间 totalcount: true # 总共字数 separated_meta: true统计阅读次数这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下： image-20180809175133462第三方插件Hexo-adminHexo-admin插件允许我们直接在本地页面上修改文章内容。 下载 npm i hexo-admin –save登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容 Hexo-doubanhexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。 下载 npm install hexo-douban –save配置 在hexo根目录下的config.yml文件中添加如下内容 douban: user: builtin: false book: title: ‘This is my book title’ quote: ‘This is my book quote’ movie: title: ‘This is my movie title’ quote: ‘This is my movie quote’ game: title: ‘This is my game title’ quote: ‘This is my game quote’ timeout: 10000title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。 user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。 生成页面 hexo douban #生成读书、电影、游戏三个页面hexo douban -b #生成读书页面hexo douban -m #生成电影页面hexo douban -g #生成游戏页面在博客中生成页面 这里就需要用到我们前面提过的hexo new命令了。 hexo new page bookshexo new page movieshexo new page games在博客中添加页面 在menu部分添加我们需要添加的页面名称和相对路径 menu: Home: / Archives: /archives Books: /books #This is your books page Movies: /movies #This is your movies page Games: /games #This is your games page部署到博客 hexo g &amp;&amp; hexo deploy我踩过的坑iPic图片上传hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。 但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。 我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。 评论系统因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。]]></content>
  </entry>
  <entry>
    <title><![CDATA[KVM源代码分析4:内存虚拟化]]></title>
    <url>%2F2014%2F12%2F11%2Fkvm-src-4-mem%2F</url>
    <content type="text"><![CDATA[代码版本：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v3.16.37 在虚拟机的创建与运行中pc_init_pci负责(“KVM源代码分析2:虚拟机的创建与运行”)，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。 插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下： typedefstruct RAMBlock { //对应宿主的内存地址 uint8_t *host; //block在ramlist中的偏移 ram_addr_t offset; //block长度 ram_addr_t length; uint32_t flags; //block名字 char idstr[256]; QLIST_ENTRY(RAMBlock) next; \#if defined(__linux__) && !defined(TARGET_S390X) int fd; \#endif } RAMBlock; typedef struct RAMList { //看代码理解就是list的head，但是不知道为啥叫dirty... uint8_t *phys_dirty; QLIST_HEAD(ram, RAMBlock) blocks; } RAMList; 下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在”KVM源代码分析2:虚拟机的创建与运行”，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。 void \*qemu_memalign(size_t alignment, size_t size){ void *ptr; //使用posix进行内存针对页大小对齐 \#if defined(_POSIX_C_SOURCE) && !defined(__sun__) int ret; ret = posix_memalign(&ptr, alignment, size); if (ret != 0) { fprintf(stderr, "Failed to allocate %zu B: %sn", size, strerror(ret)); abort(); } \#elif defined(CONFIG_BSD) ptr = qemu_oom_check(valloc(size)); \#else //所谓检查oom就是看memalign对应malloc申请内存是否成功 ptr = qemu_oom_check(memalign(alignment, size)); \#endif trace_qemu_memalign(alignment, size, ptr); return ptr; } 以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。然后一层层的退回到pc_memory_init函数。 此时pc.ram已经分配完成，ram_addr已经拿到了分配的内存地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是 struct kvm_userspace_memory_region { __u32 slot; __u32 flags; __u64 guest_phys_addr; __u64 memory_size; /* bytes */ __u64 userspace_addr; /* start of the userspace allocated memory */ }; kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE - 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm “KVM源代码分析2:虚拟机的创建与运行”中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。扩充了new的kvm_memory_slot，下面直接在代码中注释更方便： //映射内存有大小，不是删除内存条if (npages) { //内存槽号没有虚拟内存条，意味内存新创建if (!old.npages) change = KVM_MR_CREATE; else { /* Modify an existing slot. */ //修改已存在的内存修改标志或者平移映射地址 //下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读） if ((mem->userspace_addr != old.userspace_addr) || (npages != old.npages) || ((new.flags ^ old.flags) & KVM_MEM_READONLY)) goto out; //guest地址不同，内存条平移 if (base_gfn != old.base_gfn) change = KVM_MR_MOVE; else if (new.flags != old.flags) //修改属性 change = KVM_MR_FLAGS_ONLY; else { /* Nothing to change. */ r = 0; goto out; } } } else if (old.npages) { //申请插入的内存为0，而内存槽上有内存，意味删除 change = KVM_MR_DELETE; } else /* Modify a non-existent slot: disallowed. */ goto out; 另外看kvm_mr_change就知道memslot的变动值了： enum kvm_mr_change { KVM_MR_CREATE, KVM_MR_DELETE, KVM_MR_MOVE, KVM_MR_FLAGS_ONLY, }; 在往下是一段检查 if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) { /* Check for overlaps */ r = -EEXIST; kvm_for_each_memslot(slot, kvm->memslots) { if ((slot->id >= KVM_USER_MEM_SLOTS) || //下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的 (slot->id == mem->slot)) continue; //下面就是当前已有的slot与new在guest线性区间上有交集 if (!((base_gfn + npages base_gfn) || (base_gfn >= slot->base_gfn + slot->npages))) goto out; //out错误码就是EEXIST } } 如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages - 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;09,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;19,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。如果有脏页,并且脏页位图为空,则分配脏页位图, kvm_create_dirty_bitmap实际就是”页数/8”. if ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) { if (kvm_create_dirty_bitmap(&new) < 0) goto out_free; } 当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。 内存的添加说完了，看一下EPT页表的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。 context->page_fault = tdp_page_fault; context->sync_page = nonpaging_sync_page; context->invlpg = nonpaging_invlpg; context->update_pte = nonpaging_update_pte; context->shadow_root_level = kvm_x86_ops->get_tdp_level(); context->root_hpa = INVALID_PAGE; context->direct_map = true; context->set_cr3 = kvm_x86_ops->set_tdp_cr3; context->get_cr3 = get_cr3; context->get_pdptr = kvm_pdptr_read; context->inject_page_fault = kvm_inject_page_fault; 当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。 //填充kvm mmu专用的slab r = mmu_topup_memory_caches(vcpu); //获取gfn使用的level，即hugepage的问题 force_pt_level = mapping_level_dirty_bitmap(vcpu, gfn); if (likely(!force_pt_level)) { level = mapping_level(vcpu, gfn); gfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1); } else level = PT_PAGE_TABLE_LEVEL; //顾名思义，快速处理一个简单的page fault //即present同时有写权限的非mmio page fault //参考page_fault_can_be_fast函数 //一部分处理没有写权限的page fault //一部分处理 TLB lazy //fast_pf_fix_direct_spte也就是将pte获取的写权限 if (fast_page_fault(vcpu, gpa, level, error_code)) return 0; //下面函数主要就一件事情，gfn_to_pfn if (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable)) return 0; //direct map就是映射ept页表的过程 r = __direct_map(vcpu, gpa, write, map_writable, level, gfn, pfn, prefault); 在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva: static pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic, bool *async, bool write_fault, bool *writable) { unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault); if (addr == KVM_HVA_ERR_RO_BAD) return KVM_PFN_ERR_RO_FAULT; if (kvm_is_error_hva(addr)) return KVM_PFN_NOSLOT; /* Do not map writable pfn in the readonly memslot. */ if (writable && memslot_is_readonly(slot)) { *writable = false; writable = NULL; } return hva_to_pfn(addr, atomic, async, write_fault, writable); } gfn2hva本质就是 staticinline unsigned long __gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn) { return slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE; } 而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。 static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write, int map_writable, int level, gfn_t gfn, pfn_t pfn, bool prefault) { struct kvm_shadow_walk_iterator iterator; struct kvm_mmu_page *sp; int emulate = 0; gfn_t pseudo_gfn; if (!VALID_PAGE(vcpu->arch.mmu.root_hpa)) return0; //遍历ept四级页表 for_each_shadow_entry(vcpu, (u64)gfn < PAGE_SHIFT, iterator) { //如果是最后一级，level是hugepage下的level if (iterator.level == level) { //设置pte，页表下一级的page地址就是pfn写入到pte mmu_set_spte(vcpu, iterator.sptep, ACC_ALL, write, &emulate, level, gfn, pfn, prefault, map_writable); direct_pte_prefetch(vcpu, iterator.sptep); ++vcpu->stat.pf_fixed; break; } drop_large_spte(vcpu, iterator.sptep); //mmu page不在位的情况，也就是缺页 if (!is_shadow_present_pte(*iterator.sptep)) { u64 base_addr = iterator.addr; //获取指向的具体mmu page entry的index base_addr &= PT64_LVL_ADDR_MASK(iterator.level); pseudo_gfn = base_addr >> PAGE_SHIFT; //获取mmu page sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr, iterator.level - 1, 1, ACC_ALL, iterator.sptep); //将当前的mmu page的地址写入到上一级别mmu page的pte中 link_shadow_page(iterator.sptep, sp, true); } } return emulate; } static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu, gfn_t gfn, gva_t gaddr, unsigned level, int direct, unsigned access, u64 *parent_pte) { union kvm_mmu_page_role role; unsigned quadrant; struct kvm_mmu_page *sp; bool need_sync = false; role = vcpu->arch.mmu.base_role; role.level = level; role.direct = direct; if (role.direct) role.cr4_pae = 0; role.access = access; if (!vcpu->arch.mmu.direct_map && vcpu->arch.mmu.root_level (PAGE_SHIFT + (PT64_PT_BITS * level)); quadrant &= (1 < ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1; role.quadrant = quadrant; } //根据一个hash索引来的 for_each_gfn_sp(vcpu->kvm, sp, gfn) { //检查整个mmu ept是否被失效了 if (is_obsolete_sp(vcpu->kvm, sp)) continue; if (!need_sync && sp->unsync) need_sync = true; if (sp->role.word != role.word) continue; if (sp->unsync && kvm_sync_page_transient(vcpu, sp)) break; mmu_page_add_parent_pte(vcpu, sp, parent_pte); if (sp->unsync_children) { kvm_make_request(KVM_REQ_MMU_SYNC, vcpu); kvm_mmu_mark_parents_unsync(sp); } else if (sp->unsync) kvm_mmu_mark_parents_unsync(sp); __clear_sp_write_flooding_count(sp); trace_kvm_mmu_get_page(sp, false); return sp; } ++vcpu->kvm->stat.mmu_cache_miss; sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct); if (!sp) return sp; sp->gfn = gfn; sp->role = role; //新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有 //被分配 hlist_add_head(&sp->hash_link, &vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]); if (!direct) { if (rmap_write_protect(vcpu->kvm, gfn)) kvm_flush_remote_tlbs(vcpu->kvm); if (level > PT_PAGE_TABLE_LEVEL && need_sync) kvm_sync_pages(vcpu, gfn); account_shadowed(vcpu->kvm, gfn); } sp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen; init_shadow_page_table(sp); trace_kvm_mmu_get_page(sp, true); return sp; }]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM源代码分析3:CPU虚拟化]]></title>
    <url>%2F2014%2F12%2F11%2Fkvm-src-3-cpu%2F</url>
    <content type="text"><![CDATA[在虚拟机的创建与运行章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。 QEMU：git://git.qemu.org/qemu.git v2.4.0 KVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2 1.VT-x 技术Intel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。 处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考CPU的运行环、特权级与保护）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。 为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问中断寄存器）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。 在KVM源代码分析1:基本工作原理章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。 如下图 在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。 2.VMCS寄存器VMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的寄存器（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。 VMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域： col 1 | col 2 | col 3———————- | ——————————————————– | —————————————————————– VM-execution controls | Determines what operations cause VM exits | CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etcGuest-state area | Saved on VM exits，Reloaded on VM entry | EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc Host-state area | Loaded on VM exits | CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc VM-exit controls | Determines which state to save, load, how to transition | Example: MSR save-load list VM-entry controls | Determines which state to load, how to transition | Including injecting events (interrupts, exceptions) on entry 关于具体控制域的细节，还是翻Intel手册吧。 3.VM-Entry/VM-ExitVM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。 VM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，发生中断，模拟特权资源等。 运行在非根模式下的敏感指令一般分为3个方面： 1.行为没有变化的，也就是说该指令能够正确执行。 2.行为有变化的，直接产生VM-Exit。 3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。 主要说一下”受到VM-Execution控制域控制”的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在虚拟化场景下是不适用的，典型的就是TSC offset了。 VM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。 4.KVM_CREATE_VM创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。 struct kvm { struct mm_struct *mm; /* userspace tied to this vm */ struct kvm_memslots *memslots; /*qemu模拟的内存条模型*/ struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */ atomic_t online_vcpus; int last_boosted_vcpu; struct list_head vm_list; //HOST上VM管理链表， struct kvm_io_bus *buses[KVM_NR_BUSES]; struct kvm_vm_stat stat; struct kvm_arch arch; //这个是host的arch的一些参数 atomic_t users_count; long tlbs_dirty; struct list_head devices; }; kvm_arch_init_vm基本没有特别动作，初始化了KVM-&gt;arch，以及更新了kvmclock函数，这个另外再说。而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理位图，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。 5.KVM_CREATE_VCPUkvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。 struct kvm_vcpu { struct kvm *kvm; //归属的KVM\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier; \#endif int cpu; int vcpu_id; int srcu_idx; int mode; unsigned long requests; unsigned long guest_debug; struct mutex mutex; struct kvm_run *run; //运行时的状态 int fpu_active; int guest_fpu_loaded, guest_xcr0_loaded; wait_queue_head_t wq; //队列 struct pid *pid; int sigset_active; sigset_t sigset; struct kvm_vcpu_stat stat; //一些数据 \#ifdef CONFIG_HAS_IOMEM int mmio_needed; int mmio_read_completed; int mmio_is_write; int mmio_cur_fragment; int mmio_nr_fragments; struct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS]; \#endif \#ifdef CONFIG_KVM_ASYNC_PF struct { u32 queued; struct list_head queue; struct list_head done; spinlock_t lock; } async_pf; \#endif \#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT /* \* Cpu relax intercept or pause loop exit optimization \* in_spin_loop: set when a vcpu does a pause loop exit \* or cpu relax intercepted. \* dy_eligible: indicates whether vcpu is eligible for directed yield. \*/ struct { bool in_spin_loop; bool dy_eligible; } spin_loop; \#endif bool preempted; struct kvm_vcpu_arch arch; //当前VCPU虚拟的架构，默认介绍X86 }; 借着看kvm_arch_vcpu_create，它借助kvm_x86_ops-&gt;vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu-&gt;run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch： struct kvm_vcpu_arch { /* \* rip and regs accesses must go through \* kvm_{register,rip}_{read,write} functions. \*/unsignedlong regs[NR_VCPU_REGS]; u32 regs_avail; u32 regs_dirty; //类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0; unsignedlong cr0_guest_owned_bits; unsignedlong cr2; unsignedlong cr3; unsigned long cr4; unsigned long cr4_guest_owned_bits; unsigned long cr8; u32 hflags; u64 efer; u64 apic_base; struct kvm_lapic *apic; /* kernel irqchip context */ unsigned long apic_attention; int32_t apic_arb_prio; int mp_state; u64 ia32_misc_enable_msr; bool tpr_access_reporting; u64 ia32_xss; /* \* Paging state of the vcpu \* \* If the vcpu runs in guest mode with two level paging this still saves \* the paging mode of the l1 guest. This context is always used to \* handle faults. \*/ struct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数 /* \* Paging state of an L2 guest (used for nested npt) \* \* This context will save all necessary information to walk page tables \* of the an L2 guest. This context is only initialized for page table \* walking and not for faulting since we never handle l2 page faults on \* the host. \*/ struct kvm_mmu nested_mmu; /* \* Pointer to the mmu context currently used for \* gva_to_gpa translations. \*/ struct kvm_mmu *walk_mmu; struct kvm_mmu_memory_cache mmu_pte_list_desc_cache; struct kvm_mmu_memory_cache mmu_page_cache; struct kvm_mmu_memory_cache mmu_page_header_cache; struct fpu guest_fpu; u64 xcr0; u64 guest_supported_xcr0; u32 guest_xstate_size; struct kvm_pio_request pio; void *pio_data; u8 event_exit_inst_len; struct kvm_queued_exception { bool pending; bool has_error_code; bool reinject; u8 nr; u32 error_code; } exception; struct kvm_queued_interrupt { bool pending; bool soft; u8 nr; } interrupt; int halt_request; /* real mode on Intel only */ int cpuid_nent; struct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES]; int maxphyaddr; /* emulate context */ //下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套 struct x86_emulate_ctxt emulate_ctxt; bool emulate_regs_need_sync_to_vcpu; bool emulate_regs_need_sync_from_vcpu; int (*complete_userspace_io)(struct kvm_vcpu *vcpu); gpa_t time; struct pvclock_vcpu_time_info hv_clock; unsigned int hw_tsc_khz; struct gfn_to_hva_cache pv_time; bool pv_time_enabled; /* set guest stopped flag in pvclock flags field */ bool pvclock_set_guest_stopped_request; struct { u64 msr_val; u64 last_steal; u64 accum_steal; struct gfn_to_hva_cache stime; struct kvm_steal_time steal; } st; u64 last_guest_tsc; u64 last_host_tsc; u64 tsc_offset_adjustment; u64 this_tsc_nsec; u64 this_tsc_write; u64 this_tsc_generation; bool tsc_catchup; bool tsc_always_catchup; s8 virtual_tsc_shift; u32 virtual_tsc_mult; u32 virtual_tsc_khz; s64 ia32_tsc_adjust_msr; atomic_t nmi_queued; /* unprocessed asynchronous NMIs */ unsigned nmi_pending; /* NMI queued after currently running handler */ bool nmi_injected; /* Trying to inject an NMI this entry */ struct mtrr_state_type mtrr_state; u64 pat; unsigned switch_db_regs; unsigned long db[KVM_NR_DB_REGS]; unsigned long dr6; unsigned long dr7; unsigned long eff_db[KVM_NR_DB_REGS]; unsigned long guest_debug_dr7; u64 mcg_cap; u64 mcg_status; u64 mcg_ctl; u64 *mce_banks; /* Cache MMIO info */ u64 mmio_gva; unsigned access; gfn_t mmio_gfn; u64 mmio_gen; struct kvm_pmu pmu; /* used for guest single stepping over the given code position */ unsigned long singlestep_rip; /* fields used by HYPER-V emulation */ u64 hv_vapic; cpumask_var_t wbinvd_dirty_mask; unsigned long last_retry_eip; unsigned long last_retry_addr; struct { bool halted; gfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)]; struct gfn_to_hva_cache data; u64 msr_val; u32 id; bool send_user_only; } apf; /* OSVW MSRs (AMD only) */ struct { u64 length; u64 status; } osvw; struct { u64 msr_val; struct gfn_to_hva_cache data; } pv_eoi; /* \* Indicate whether the access faults on its page table in guest \* which is set when fix page fault and used to detect unhandeable \* instruction. \*/ bool write_fault_to_shadow_pgtable; /* set at EPT violation at this point */ unsigned long exit_qualification; /* pv related host specific info */ struct { bool pv_unhalted; } pv; }; 整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。kvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu-&gt;arch.emulate_ctxt.ops = &amp;emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。 static struct x86_emulate_ops emulate_ops = { .read_std = kvm_read_guest_virt_system, .write_std = kvm_write_guest_virt_system, .fetch = kvm_fetch_guest_virt, .read_emulated = emulator_read_emulated, .write_emulated = emulator_write_emulated, .cmpxchg_emulated = emulator_cmpxchg_emulated, .invlpg = emulator_invlpg, .pio_in_emulated = emulator_pio_in_emulated, .pio_out_emulated = emulator_pio_out_emulated, .get_segment = emulator_get_segment, .set_segment = emulator_set_segment, .get_cached_segment_base = emulator_get_cached_segment_base, .get_gdt = emulator_get_gdt, .get_idt = emulator_get_idt, .set_gdt = emulator_set_gdt, .set_idt = emulator_set_idt, .get_cr = emulator_get_cr, .set_cr = emulator_set_cr, .cpl = emulator_get_cpl, .get_dr = emulator_get_dr, .set_dr = emulator_set_dr, .set_msr = emulator_set_msr, .get_msr = emulator_get_msr, .halt = emulator_halt, .wbinvd = emulator_wbinvd, .fix_hypercall = emulator_fix_hypercall, .get_fpu = emulator_get_fpu, .put_fpu = emulator_put_fpu, .intercept = emulator_intercept, .get_cpuid = emulator_get_cpuid, }; x86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx-&gt;loaded_vmcs-&gt;vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从伙伴系统申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf-&gt;order = get_order(vmcs_config.size)，而vmcs_conf-&gt;size = vmx_msr_high &amp; 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。vmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。vmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops-&gt;vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。kvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。如此整个vcpu就创建完成了。 6.KVM_RUN KVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。 下一篇： KVM源代码分析4:内存虚拟化 ———-完———- ——————–下面未编辑的留存————————————-给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个页大小内存，用来保存vm和vmm信息。 vmx->vmcs = alloc_vmcs(); if (!vmx->vmcs) goto free_msrs; vmcs_init(vmx->vmcs); 执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。 vmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。 vcpu的创建到此结束，下面说一下vcpu的运行。 VCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。 KVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu-&gt;requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops-&gt;prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。 kvm_x86_ops->prepare_guest_switch(vcpu); if (vcpu->fpu_active) kvm_load_guest_fpu(vcpu); kvm_load_guest_xcr0(vcpu); vcpu->mode = IN_GUEST_MODE; /* We should set ->mode before check ->requests, \* see the comment in make_all_cpus_request. \*/ smp_mb(); local_irq_disable(); 然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu-&gt;mode和vcpu-&gt;requests等，如果有问题，则恢复host状态。 kvm_guest_enter做了两件事：account_system_vtime计算虚拟机系统时间；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。 准备工作搞定，kvm_x86_ops-&gt;run(vcpu)，开始运行guest，由vmx_vcpu_run实现。 if (vmx->emulation_required && emulate_invalid_guest_state) return; if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty)) vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]); if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty)) vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]); 判断模拟器，RSP，RIP寄存器值。 主要功能在这段内联汇编上 asm( /* Store host registers */ "push %%"R"dx; push %%"R"bp;" "push %%"R"cx nt" /* placeholder for guest rcx */ "push %%"R"cx nt"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上 "cmp %%"R"sp, %c[host_rsp](%0) nt""je 1f nt""mov %%"R"sp, %c[host_rsp](%0) nt" __ex(ASM_VMX_VMWRITE_RSP_RDX) "nt"//__kvm_handle_fault_on_reboot write host rsp"1: nt"/* Reload cr2 if changed */ "mov %c[cr2](%0), %%"R"ax nt" "mov %%cr2, %%"R"dx nt" //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上 "cmp %%"R"ax, %%"R"dx nt" "je 2f nt" "mov %%"R"ax, %%cr2 nt" "2: nt" /* Check if vmlaunch of vmresume is needed */ "cmpl $0, %c[launched](%0) nt" /* Load guest registers. Don't clobber flags. */ "mov %c[rax](%0), %%"R"ax nt" "mov %c[rbx](%0), %%"R"bx nt" "mov %c[rdx](%0), %%"R"dx nt" "mov %c[rsi](%0), %%"R"si nt" "mov %c[rdi](%0), %%"R"di nt" "mov %c[rbp](%0), %%"R"bp nt" \#ifdef CONFIG_X86_64 "mov %c[r8](%0), %%r8 nt" "mov %c[r9](%0), %%r9 nt" "mov %c[r10](%0), %%r10 nt" "mov %c[r11](%0), %%r11 nt" "mov %c[r12](%0), %%r12 nt" "mov %c[r13](%0), %%r13 nt" "mov %c[r14](%0), %%r14 nt" "mov %c[r15](%0), %%r15 nt" \#endif "mov %c[rcx](%0), %%"R"cx nt" /* kills %0 (ecx) */ /* Enter guest mode */ //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式 //RESUME和LAUNCH，通过__ex __kvm_handle_fault_on_reboot执行 "jne .Llaunched nt" __ex(ASM_VMX_VMLAUNCH) "nt" "jmp .Lkvm_vmx_return nt" ".Llaunched: " __ex(ASM_VMX_VMRESUME) "nt" //退出vmx，保存guest信息，加载host信息 ".Lkvm_vmx_return: " /* Save guest registers, load host registers, keep flags */ "mov %0, %c[wordsize](%%"R"sp) nt" "pop %0 nt" "mov %%"R"ax, %c[rax](%0) nt" "mov %%"R"bx, %c[rbx](%0) nt" "pop"Q" %c[rcx](%0) nt" "mov %%"R"dx, %c[rdx](%0) nt" "mov %%"R"si, %c[rsi](%0) nt" "mov %%"R"di, %c[rdi](%0) nt" "mov %%"R"bp, %c[rbp](%0) nt" \#ifdef CONFIG_X86_64 "mov %%r8, %c[r8](%0) nt" "mov %%r9, %c[r9](%0) nt" "mov %%r10, %c[r10](%0) nt" "mov %%r11, %c[r11](%0) nt" "mov %%r12, %c[r12](%0) nt" "mov %%r13, %c[r13](%0) nt" "mov %%r14, %c[r14](%0) nt" "mov %%r15, %c[r15](%0) nt" \#endif "mov %%cr2, %%"R"ax nt" "mov %%"R"ax, %c[cr2](%0) nt" "pop %%"R"bp; pop %%"R"dx nt" "setbe %c[fail](%0) nt" : : "c"(vmx), "d"((unsigned long)HOST_RSP), //下面加了前面寄存器的指针值，对应具体结构的值 [launched]"i"(offsetof(struct vcpu_vmx, launched)), [fail]"i"(offsetof(struct vcpu_vmx, fail)), [host_rsp]"i"(offsetof(struct vcpu_vmx, host_rsp)), [rax]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])), [rbx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])), [rcx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])), [rdx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])), [rsi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])), [rdi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])), [rbp]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])), \#ifdef CONFIG_X86_64 [r8]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])), [r9]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])), [r10]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])), [r11]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])), [r12]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])), [r13]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])), [r14]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])), [r15]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])), \#endif [cr2]"i"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)), [wordsize]"i"(sizeof(ulong)) : "cc", "memory" , R"ax", R"bx", R"di", R"si" \#ifdef CONFIG_X86_64 , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15" \#endif 以上代码相对容易理解的，根据注释大致清楚了具体作用。 然后就是恢复系统NMI等中断: vmx_complete_atomic_exit(vmx); vmx_recover_nmi_blocking(vmx); vmx_complete_interrupts(vmx); 回到vcpu_enter_guest，通过hw_breakpoint_restore恢复硬件断点。 if (hw_breakpoint_active()) hw_breakpoint_restore(); kvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc); //设置vcpu模式，恢复host相关内容 vcpu->mode = OUTSIDE_GUEST_MODE; smp_wmb(); local_irq_enable(); ++vcpu->stat.exits; /* \* We must have an instruction between local_irq_enable() and \* kvm_guest_exit(), so the timer interrupt isn't delayed by \* the interrupt shadow. The stat.exits increment will do nicely. \* But we need to prevent reordering, hence this barrier(): \*/ barrier(); //刷新系统时间 kvm_guest_exit(); preempt_enable(); vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu); /* \* Profile KVM exit RIPs: \*/ if (unlikely(prof_on == KVM_PROFILING)) { unsigned long rip = kvm_rip_read(vcpu); profile_hit(KVM_PROFILING, (void *)rip); } kvm_lapic_sync_from_vapic(vcpu); //处理vmx退出 r = kvm_x86_ops->handle_exit(vcpu); handle_exit退出函数由vmx_handle_exit实现，主要设置vcpu-&gt;run-&gt;exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下： staticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = { [EXIT_REASON_EXCEPTION_NMI] = handle_exception, [EXIT_REASON_EXTERNAL_INTERRUPT] = handle_external_interrupt, [EXIT_REASON_TRIPLE_FAULT] = handle_triple_fault, [EXIT_REASON_NMI_WINDOW] = handle_nmi_window, [EXIT_REASON_IO_INSTRUCTION] = handle_io, [EXIT_REASON_CR_ACCESS] = handle_cr, [EXIT_REASON_DR_ACCESS] = handle_dr, [EXIT_REASON_CPUID] = handle_cpuid, [EXIT_REASON_MSR_READ] = handle_rdmsr, [EXIT_REASON_MSR_WRITE] = handle_wrmsr, [EXIT_REASON_PENDING_INTERRUPT] = handle_interrupt_window, [EXIT_REASON_HLT] = handle_halt, [EXIT_REASON_INVD] = handle_invd, [EXIT_REASON_INVLPG] = handle_invlpg, [EXIT_REASON_VMCALL] = handle_vmcall, [EXIT_REASON_VMCLEAR] = handle_vmx_insn, [EXIT_REASON_VMLAUNCH] = handle_vmx_insn, [EXIT_REASON_VMPTRLD] = handle_vmx_insn, [EXIT_REASON_VMPTRST] = handle_vmx_insn, [EXIT_REASON_VMREAD] = handle_vmx_insn, [EXIT_REASON_VMRESUME] = handle_vmx_insn, [EXIT_REASON_VMWRITE] = handle_vmx_insn, [EXIT_REASON_VMOFF] = handle_vmx_insn, [EXIT_REASON_VMON] = handle_vmx_insn, [EXIT_REASON_TPR_BELOW_THRESHOLD] = handle_tpr_below_threshold, [EXIT_REASON_APIC_ACCESS] = handle_apic_access, [EXIT_REASON_WBINVD] = handle_wbinvd, [EXIT_REASON_XSETBV] = handle_xsetbv, [EXIT_REASON_TASK_SWITCH] = handle_task_switch, [EXIT_REASON_MCE_DURING_VMENTRY] = handle_machine_check, [EXIT_REASON_EPT_VIOLATION] = handle_ept_violation, [EXIT_REASON_EPT_MISCONFIG] = handle_ept_misconfig, [EXIT_REASON_PAUSE_INSTRUCTION] = handle_pause, [EXIT_REASON_MWAIT_INSTRUCTION] = handle_invalid_op, [EXIT_REASON_MONITOR_INSTRUCTION] = handle_invalid_op, }; 有handle_task_switch进行任务切换，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。 再次退回到__vcpu_run函数，在while (r &gt; 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。 if (need_resched()) { srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx); kvm_resched(vcpu); vcpu->srcu_idx = srcu_read_lock(&kvm->srcu); } 再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。 KVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。 KVM源代码分析未完待续]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM源代码分析2:虚拟机的创建与运行]]></title>
    <url>%2F2014%2F12%2F11%2Fkvm-src-2-vm-run%2F</url>
    <content type="text"><![CDATA[原文链接：http://oenhan.com/kvm-src-2-vm-run 前段时间挖了一个坑，KVM源代码分析1:基本工作原理，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和内核态驱动kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从虚拟机的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。 代码： QEMU：git://git.qemu.org/qemu.git v2.4.0 KVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2 QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。 使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。 而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。 所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。 所有看QEMU和KVM的配合流程如下： 接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出处理函数，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数： typedef enum { MODULE_INIT_BLOCK, MODULE_INIT_MACHINE, MODULE_INIT_QAPI, MODULE_INIT_QOM, MODULE_INIT_MAX } module_init_type; 最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种模拟设备，具体可以参考http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。 module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图 它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e-&gt;init()完成功能的，而e-&gt;init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有 \#define block_init(function) module_init(function, MODULE_INIT_BLOCK) \#define machine_init(function) module_init(function, MODULE_INIT_MACHINE) \#define qapi_init(function) module_init(function, MODULE_INIT_QAPI) \#define type_init(function) module_init(function, MODULE_INIT_QOM) 那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有 \#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\##suffix(MachineState *machine) { void (*compat)(MachineState *m) = (compatfn); if (compat) { compat(machine); } pc_init1(machine); } DEFINE_PC_MACHINE(suffix, name, pc_init_\##suffix, optionfn) \#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) static void pc_machine_\##suffix##_class_init(ObjectClass *oc, void *data) { MachineClass *mc = MACHINE_CLASS(oc); optsfn(mc); mc->name = namestr; mc->init = initfn; } static const TypeInfo pc_machine_type_\##suffix = { .name = namestr TYPE_MACHINE_SUFFIX, .parent = TYPE_PC_MACHINE, .class_init = pc_machine_\##suffix##_class_init, }; static void pc_machine_init_\##suffix(void) { type_register(&pc_machine_type_\##suffix); } machine_init(pc_machine_init_\##suffix) DEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc-&gt;init，其他爱看不看吧。而module_init的宏是 \#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \## function(void) { register_dso_module_init(function, type); } \#else /* This should not be used directly. Use block_init etc. instead. */ \#define module_init(function, type) static void __attribute__((constructor)) do_qemu_init_ \## function(void) { register_module_init(function, type); } 它前面的修饰是attribute((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-&gt; kvm_accel_type -&gt; kvm_accel_class_init -&gt; kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机句柄。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对内存管理的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。 这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc-&gt;init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。 下面涉及对OPT入参的解析过程略过不提。 qemu准备模拟的机器的类型从下面语句获得: current_machine = MACHINE(object_new(object_class_get_name( OBJECT_CLASS(machine_class)))); machine_class则是通过入参传入的 case QEMU_OPTION_machine: olist = qemu_find_opts("machine"); opts = qemu_opts_parse_noisily(olist, optarg, true); if (!opts) { exit(1); } break; man qemu -machine [type=]name[,prop=value[,...]] Select the emulated machine by name. Use "-machine help" to list available machines 下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class-&gt;init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。 现在进入pc_init1函数： 在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。pc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看 { .name = "SandyBridge", .level = 0xd, .vendor = CPUID_VENDOR_INTEL, .family = 6, .model = 42, .stepping = 1, .features[FEAT_1_EDX] = CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX | CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA | CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 | CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE | CPUID_DE | CPUID_FP87, .features[FEAT_1_ECX] = CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES | CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT | CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 | CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ | CPUID_EXT_SSE3, .features[FEAT_8000_0001_EDX] = CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX | CPUID_EXT2_SYSCALL, .features[FEAT_8000_0001_ECX] = CPUID_EXT3_LAHF_LM, .features[FEAT_XSAVE] = CPUID_XSAVE_XSAVEOPT, .features[FEAT_6_EAX] = CPUID_6_EAX_ARAT, .xlevel = 0x80000008, .model_id = "Intel Xeon E312xx (Sandy Bridge)", }, 你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下： //创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn, cpu, QEMU_THREAD_JOINABLE); //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的 while (!cpu->created) { qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex); } 线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作 \#define type_init(function) module_init(function, MODULE_INIT_QOM) 从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中： //初始化VCPU r = kvm_init_vcpu(env); //初始化KVM中断 qemu_kvm_init_cpu_signals(env); //标志VCPU创建完成，和上面判断是对应的 cpu->created = true; qemu_cond_signal(&qemu_cpu_cond); while (1) { if (cpu_can_run(env)) { //CPU进入执行状态 r = kvm_cpu_exec(env); if (r == EXCP_DEBUG) { cpu_handle_guest_debug(env); } } qemu_kvm_wait_io_event(env); } CPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env-&gt;kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。qemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看内存的初始化。内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。 qemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页对齐分配内存。后续的都是对RAMBlock的插入等处理。从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。vmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr-&gt;name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr-&gt;owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。memory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码： while (iold < old_view->nr || inew < new_view->nr) { if (iold < old_view->nr) { frold = &old_view->ranges[iold]; } else { frold = NULL; } if (inew < new_view->nr) { frnew = &new_view->ranges[inew]; } else { frnew = NULL; } if (frold && (!frnew || int128_lt(frold->addr.start, frnew->addr.start) || (int128_eq(frold->addr.start, frnew->addr.start) && !flatrange_equal(frold, frnew)))) { /* In old but not in new, or in both but attributes changed. */ if (!adding) { //这个判断代码添加的无用，可以直接删除, //address_space_update_topology里面的两个pass也可以删除一个 MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del); } ++iold; } else if (frold && frnew && flatrange_equal(frold, frnew)) { /* In both and unchanged (except logging may have changed) */ if (adding) { MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop); if (frold->dirty_log_mask && !frnew->dirty_log_mask) { MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop); } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) { MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start); } } ++iold; ++inew; } else { /* In new */ if (adding) { MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add); } ++inew; } } 重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem)传递给kernel。我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行： while (1) { if (cpu_can_run(cpu)) { r = kvm_cpu_exec(cpu); if (r == EXCP_DEBUG) { cpu_handle_guest_debug(cpu); } } qemu_kvm_wait_io_event(cpu); } 判断条件就是cpu_can_run函数，即cpu-&gt;stop &amp;&amp; cpu-&gt;stopped &amp;&amp; current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的 void vm_start(void){ if (!runstate_is_running()) { cpu_enable_ticks(); runstate_set(RUN_STATE_RUNNING); vm_state_notify(1, RUN_STATE_RUNNING); resume_all_vcpus(); monitor_protocol_event(QEVENT_RESUME, NULL); } } 如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM源代码分析1:基本工作原理]]></title>
    <url>%2F2014%2F12%2F11%2Fkvm-src-1%2F</url>
    <content type="text"><![CDATA[原文出自：http://oenhan.com/kvm-src-1文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发 1.KVM模型结构为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。 当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子内存分配，进程调度等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。 guest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，内存管理，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。 如上图所示，guest自身有自己的用户模式和内核模式；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行创建进程或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。 2.KVM工作原理 上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。 3.CPU虚拟化X86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。 VMM调度guest执行时，qemu 通过 ioctl 系统调用进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。 当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。 4.Mem虚拟化OS对于物理内存主要有两点认识：1.物理地址从0开始；2.内存地址是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。 在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。 这样MEM虚拟化就是GVA-&gt;GPA-&gt;HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。 总体描述到此，后面代码里面见真相。]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2014%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment workflowRefence: http://flowchart.js.org/ st=>start: Start:>http://www.google.com[blank] e=>end:>http://www.google.com op1=>operation: My Operation sub1=>subroutine: My Subroutine cond=>condition: Yes or No?:>http://www.google.com io=>inputoutput: catch something... para=>parallel: parallel tasks st->op1->cond cond(yes)->io->e cond(no)->para para(path1, bottom)->sub1(right)->op1 para(path2, top)->op1 &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
  </entry>
</search>

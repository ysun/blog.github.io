<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>利用QOM(Qemu Object Model)创建虚拟设备</title>
      <link href="/2018/12/26/qemu-qom/"/>
      <url>/2018/12/26/qemu-qom/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是QOM"><a href="#什么是QOM" class="headerlink" title="什么是QOM"></a>什么是QOM</h2><p>QOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。<br>QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。</p><h2 id="QOM-的初始化"><a href="#QOM-的初始化" class="headerlink" title="QOM 的初始化"></a>QOM 的初始化</h2><p>对象的初始化分为四步：</p><ul><li>将 TypeInfo 注册 TypeImpl</li><li>实例化 ObjectClass</li><li>实例化 Object</li><li>添加 Property</li></ul><p>根据QEMU的wiki ，QOM没有构造和析构的概念。但矛盾的是根据代码，TypeInfo 中定义的 class_init 和 instance_init 无论从名字还是实现上都做了对象的初始化工作，比如设置对象成员的值。但为什么说它们最多只能算是初始化函数呢？<br><code>Everything in QOM is a device</code><br>根据实现，经过 class_init 和 instance_init 产生设备对应Object后，这个Object是不能直接使用的。其真正初始化逻辑的大头都放在 realize 中做，比如创建对应的memory region，挂载到对应bus上等等。只有在 realize 后，设备才算真正构造完成，可以拿来用了。因此QEMU认为，类似构造和析构的是realize和unrealize。而在设备的生命周期中，可以被realize和unrealize多次。<br>为了保持习惯，本文会依然将 class_init 和 instance_init 当做构造函数，称前者为类构造函数，后者为类实例构造函数。</p><h2 id="使用QOM添加设备源码分析"><a href="#使用QOM添加设备源码分析" class="headerlink" title="使用QOM添加设备源码分析"></a>使用QOM添加设备源码分析</h2><p>下面我们就利用一个真实的案例，讲解一下利用QOM添加设备的具体实现步骤</p><h3 id="TypeInfo-gt-ModuleEntry"><a href="#TypeInfo-gt-ModuleEntry" class="headerlink" title="TypeInfo =&gt; ModuleEntry"></a>TypeInfo =&gt; ModuleEntry</h3><p>设备相关代码的入口就是这里了, TypeInfo 定义了一种类型，并且使用函数type_register_static注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static const TypeInfo caffee_agent_info = &#123;</span><br><span class="line">    .name          = &quot;caffee-agent&quot;,</span><br><span class="line">    .parent        = TYPE_ISA_DEVICE,</span><br><span class="line">    .class_init    = caffee_agent_class_init,</span><br><span class="line">    .instance_size = sizeof(CaffeeAgentState),</span><br><span class="line">    .instance_init = caffee_agent_initfn,</span><br><span class="line">&#125;;</span><br><span class="line">                                             </span><br><span class="line">static void caffee_agent_register_types (void)</span><br><span class="line">&#123;</span><br><span class="line">    type_register_static (&amp;caffee_agent_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(cafe_agent_register_types)</span><br></pre></td></tr></table></figure><p>包含 类型的名称(name)、父类名称(parent)、Object实例的大小(instance_size)、是否抽象类(abstract)、初始化函数(class_init)。<br>代码底部有 type_init ，由 C run-time(CRT)负责执行：<br><!--`type_init(kvm_type_init) => module_init(function, MODULE_INIT_QOM) => register_module_init(function, type)`--></p><div id="flowchart-0" class="flow-chart"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void register_module_init(void (*fn)(void), module_init_type type)</span><br><span class="line">&#123;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line"></span><br><span class="line">    e = g_malloc0(sizeof(*e));</span><br><span class="line">    e-&gt;init = fn;</span><br><span class="line">    e-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(l, e, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 type 为 MODULE_INIT_QOM ，init为 kvm_type_init 的 ModuleEntry ，并加入到 MODULE_INIT_QOM 的 ModuleTypeList 中。</p><h3 id="ModuleEntry-gt-TypeImpl"><a href="#ModuleEntry-gt-TypeImpl" class="headerlink" title="ModuleEntry =&gt; TypeImpl"></a>ModuleEntry =&gt; TypeImpl</h3><p>在 main.c(vl.c) 的一开始执行了 module_call_init(MODULE_INIT_QOM) ，它从 init_type_list 中取出对应的 ModuleTypeList ，然后对里面的 ModuleEntry 成员都调用 init 函数。<br>对于上文提到的 ModuleEntry ，调用的是：<br><!---`kvm_type_init => type_register_static(&kvm_accel_type) => type_register => type_register_internal`--></p><div id="flowchart-1" class="flow-chart"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static TypeImpl *type_register_internal(const TypeInfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line"></span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    return ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它根据 kvm_accel_type(TypeInfo) 创建一个名为TYPE_KVM_ACCEL的 TypeImpl 类型的结构。<br>同时将该 TypeImpl 注册到全局 type_table 中，key为类型名称，即 TYPE_KVM_ACCEL</p><h3 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectClass</span><br><span class="line">&#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    Type type;              // 用typedef定义的 TypeImpl 指针</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ObjectClass 属于类对象，它是所有类对象的基类。</p><h4 id="TypeImpl-gt-ObjectClass"><a href="#TypeImpl-gt-ObjectClass" class="headerlink" title="TypeImpl =&gt; ObjectClass"></a>TypeImpl =&gt; ObjectClass</h4><p>有两种路径，一种是主动地调用：<br><!---`object_class_get_list => object_class_foreach => g_hash_table_foreach(object_class_foreach_tramp) => object_class_foreach_tramp => type_initialize`--></p><p><div id="flowchart-2" class="flow-chart"></div><br>比如 object_class_get_list(TYPE_DEVICE, false) 创建 TYPE_DEVICE 类型的 ObjectClass<br>该过程用到glic的函数 g_hash_table_foreach ，见 <a href="https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#g-hash-table-foreach" target="_blank" rel="noopener">https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#g-hash-table-foreach</a><br>另一种是被动调用，如:</p><ul><li>object_class_by_name</li><li>object_class_get_parent</li><li>object_new_with_type</li><li>object_initialize_with_type</li></ul><p>在获取 class、class的parent、创建type的object、初始化TypeImpl的object时，调用 type_initialize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type_initialize</span><br><span class="line">=&gt; 如果 TypeImpl 已创建(class成员有值)，返回</span><br><span class="line">=&gt; ti-&gt;class = g_malloc0(ti-&gt;class_size)                    根据class_size分配内存空间</span><br><span class="line">=&gt; type_get_parent(ti)                                      获取父类的TypeImpl</span><br><span class="line">=&gt; memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size)     将parent的class拷贝到自己class的最前面</span><br><span class="line">=&gt; ti-&gt;class-&gt;properties = g_hash_table_new_full            创建存放property的hash table</span><br><span class="line">=&gt; type_initialize_interface                                初始化class的接口，包括父类和自己的</span><br><span class="line">=&gt; ti-&gt;class-&gt;type = ti                                     设置class的type为对应TypeImpl</span><br><span class="line">=&gt; parent-&gt;class_base_init                                  如果parent定义了 class_base_init ，调用之</span><br><span class="line">=&gt; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data)                调用class的 class_init</span><br></pre></td></tr></table></figure></p><p>对于 kvm_accel_type 这个 TypeInfo 的 TypeImpl ，调用的class_init是 kvm_accel_class_init ，它将传入的 ObjectClass 强转为子类 AccelClass ，设置 init_machine 成员为 kvm_init<br>这里的class是该类型的类实例，它的基类是 ObjectClass 。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>从创建流程可以看出，在创建类对象时，会调用 type_initialize ，其会递归地对 TypeImpl 中的 parent 成员(TypeImpl)递归调用 type_initialize ，然后将创建出来的相应 ObjectClass 拷贝到自己class的最前面。<br>类对象的第一个成员是 parent_class ，由于父类对象会拷到子类对象的最前面，因此可以认为其指向父类的对象，如此构成链状的继承链，最终指向基类对象 ObjectClass<br>比如 kvm_accel_type 对应的类对象，该类对象作为叶子类型并没有定义，但其父类 AccelClass 在代码中有定义，其的第一个成员为 ObjectClass ，表示其继承自 ObjectClass 。为了能表示该叶子类型继承 AccelClass ，它修改了 AccelClass的一些对象成员，这样在某种程度上表示了继承关系。比如修改了函数指针成员的指向，相当于实现了虚函数。<br>又如： <code>register_info 对应的类对象 =&gt; PCIDeviceClass =&gt; DeviceClass =&gt; ObjectClass</code> 构成继承链，最前端的叶子类型通过修改 PCIDeviceClass 成员进行定义。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>将一个父类的指针转换为子类的指针是不安全的，为了实现这种转换，各类需要提供强制类型转换的宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ACCEL_CLASS(klass) \</span><br><span class="line">    OBJECT_CLASS_CHECK(AccelClass, (klass), TYPE_ACCEL)</span><br><span class="line"></span><br><span class="line">#define OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="line">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="line">                                               __FILE__, __LINE__, __func__))</span><br></pre></td></tr></table></figure></p><p>如果类对象指针的name和目标子类的name一致，或类对象指针是目标子类的祖先，则执行转换，否则 abort<br>反过来，从子类指针转换为父类指针是安全的，因为类的第一项就指向父类，访问时不会存在越界等问题。 </p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 属于类实例对象，它是所有类实例对象的基类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Object</span><br><span class="line">&#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    ObjectClass *class;             // 指向类对象</span><br><span class="line">    ObjectFree *free;</span><br><span class="line">    GHashTable *properties;         // 维护属性的哈希表</span><br><span class="line">    uint32_t ref;                   // 引用计数</span><br><span class="line">    Object *parent;                 // 指向父类实例对象，实现继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到其第一个成员指向类对象，同时维护有区别于类属性的类实例属性。</p><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p>就流程而言，在C runtime 根据 TypeInfo 创建了 TypeImpl 后，此后主要根据 TypeImpl 创建 ObjectClass 和 Object<br>以 TypeInfo(kvm_accel_type) 为例，其创建的 TypeImpl 在以下流程发挥作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main =&gt; configure_accelerator =&gt; accel_init_machine(acc, ms)</span><br><span class="line">=&gt; ObjectClass *oc = OBJECT_CLASS(acc)                                  将AccelClass指针转换成父类(ObjectClass)指针</span><br><span class="line">=&gt; object_class_get_name                                                获取 ObjectClass-&gt;TypeImpl 的类名，如 kvm-accel</span><br><span class="line">=&gt; ACCEL(object_new(cname))                                             利用名称创建 AccelState 对象</span><br><span class="line">=&gt; acc-&gt;init_machine(ms)                                                初始化machine，实际上是调用 kvm_init</span><br><span class="line"></span><br><span class="line">object_new</span><br><span class="line">=&gt; type_get_by_name(typename)                                           根据类名查type_table获取 TypeImpl</span><br><span class="line">=&gt; object_new_with_type =&gt; type_initialize                              创建 TypeImpl 对应的类对象，设置到对应 TypeImpl-&gt;class 中</span><br><span class="line">                        =&gt; g_malloc(type-&gt;instance_size)                分配类实例对象的内存</span><br><span class="line">                        =&gt; object_initialize_with_type                  创建类实例对象</span><br><span class="line">                            =&gt; type_initialize  会再次尝试实例化类对象</span><br><span class="line">                            =&gt; obj-&gt;class = type-&gt;class                 设置类实例对象的类对象为 TypeImpl-&gt;class</span><br><span class="line">                            =&gt; obj-&gt;properties = g_hash_table_new_full  创建存放类实例对象property的hash table</span><br><span class="line">                            =&gt; object_init_with_type =&gt; object_init_with_type   如果 TypeImpl 有父类，递归调用object_init_with_type</span><br><span class="line">                                                     =&gt; ti-&gt;instance_init(obj)  如果定义了类实例的构造函数，调用之</span><br></pre></td></tr></table></figure></p><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>定义上的继承主要指类的继承，既然类对象已经通过包含的方式实现了继承，那么类实例对象就可以通过调用自己的class成员调用父类的函数，访问父类的class property。<br>但在QEMU实现的这套面向对象模型中，类实例对象也拥有自己的构造函数，因此根据继承关系，需要对父类实例对象的构造函数进行调用。<br>从创建流程可以看出，在创建类实例对象时，会调用 object_init_with_type ，其会递归地对 TypeImpl 中的 parent 成员递归调用 object_init_with_type ，从而让所有父类的 instance_init 都得到调用，在调用时传入的是当前对象的地址，相当于在当前对象上对父类实例对象进行构造。<br>同理，类实例对象的第一个成员是 parent_obj ，指向父类的实例对象，如此构成链状的继承链，最终指向基类实例对象 Object<br>如： kvm_accel_type的类实例Object =&gt; AccelState =&gt; Object<br>又如： register_info的类实例Object =&gt; PCIDevice =&gt; DeviceState =&gt; Object</p><h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>同理，将一个父类实例的指针转换为子类实例指针是不安全的。为了实现这种转换，各类需要提供强制类型转换的宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ACCEL(obj) \</span><br><span class="line">    OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)</span><br><span class="line"></span><br><span class="line">#define OBJECT_CHECK(type, obj, name) \</span><br><span class="line">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="line">                                        __FILE__, __LINE__, __func__))</span><br></pre></td></tr></table></figure></p><p>如果类实例对象指针的name和目标子类实例的name一致，或类实例对象指针是目标子类的祖先，则执行转换，否则 abort。<br>反过来，从子类实例指针转换为父类实例指针是安全的，因为类实例的第一项就指向父类实例，访问时不会存在越界等问题。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性分为类对象(ObjectClass)属性和类实例对象(Object)属性，存储于 properties 成员中。properties 是一个 GHashTable ，存储了属性名到ObjectProperty的映射。</p><h4 id="属性模版"><a href="#属性模版" class="headerlink" title="属性模版"></a>属性模版</h4><p>用于创建属性对象 ObjectProperty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Property &#123;</span><br><span class="line">    const char   *name;</span><br><span class="line">    PropertyInfo *info;</span><br><span class="line">    ptrdiff_t    offset;</span><br><span class="line">    uint8_t      bitnr;</span><br><span class="line">    QType        qtype;</span><br><span class="line">    int64_t      defval;</span><br><span class="line">    int          arrayoffset;</span><br><span class="line">    PropertyInfo *arrayinfo;</span><br><span class="line">    int          arrayfieldsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h4><p>属性对象包含属性名称、类型、描述，类型对应的属性结构，以及相应访问函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ObjectProperty</span><br><span class="line">&#123;</span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *set;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    void *opaque;</span><br><span class="line">&#125; ObjectProperty;</span><br></pre></td></tr></table></figure></p><p>如对于bool类型的属性，opaque为 BoolProperty ，set为 property_set_bool ，get为 property_get_bool 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BoolProperty</span><br><span class="line">&#123;</span><br><span class="line">    bool (*get)(Object *, Error **);</span><br><span class="line">    void (*set)(Object *, bool, Error **);</span><br><span class="line">&#125; BoolProperty;</span><br></pre></td></tr></table></figure></p><p>用于保存用户传入的 getter 和 setter 。</p><h4 id="getter-setter-callback-hook"><a href="#getter-setter-callback-hook" class="headerlink" title="getter / setter (callback hook)"></a>getter / setter (callback hook)</h4><p>定义了在设置/读取属性时触发的函数。<br>比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL)</span><br></pre></td></tr></table></figure></p><p>则 getter 为 device_get_realized ， setter 为 device_set_realized</p><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>凡是在代码中就已经定义好名称和类型的属性，都是静态属性。包括在初始化过程中添加 和 props 。</p><h5 id="初始化过程中添加"><a href="#初始化过程中添加" class="headerlink" title="初始化过程中添加"></a>初始化过程中添加</h5><p>比如对于 TypeInfo x86_cpu_type_info ，类实例初始化函数 x86_cpu_initfn 定义好了属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object_property_add(obj, &quot;family&quot;, &quot;int&quot;,</span><br><span class="line">                    x86_cpuid_version_get_family,</span><br><span class="line">                    x86_cpuid_version_set_family, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">object_property_add_alias(obj, &quot;kvm_steal_time&quot;, obj, &quot;kvm-steal-time&quot;, &amp;error_abort);</span><br></pre></td></tr></table></figure></p><p>该属性会直接加到类实例对象的properties中。</p><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><p>一些类对象会在 class_init 中设置 props 成员，比如 TypeInfo host_x86_cpu_type_info 在 host_x86_cpu_class_init 设置为 host_x86_cpu_properties：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static Property host_x86_cpu_properties[] = &#123;</span><br><span class="line">    DEFINE_PROP_BOOL(&quot;migratable&quot;, X86CPU, migratable, true),</span><br><span class="line">    DEFINE_PROP_BOOL(&quot;host-cache-info&quot;, X86CPU, cache_info_passthrough, false),</span><br><span class="line">    DEFINE_PROP_END_OF_LIST()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define DEFINE_PROP_BOOL(_name, _state, _field, _defval) &#123;       \</span><br><span class="line">        .name      = (_name),                                    \</span><br><span class="line">        .info      = &amp;(qdev_prop_bool),                          \</span><br><span class="line">        .offset    = offsetof(_state, _field)                    \</span><br><span class="line">            + type_check(bool, typeof_field(_state, _field)),    \</span><br><span class="line">        .qtype     = QTYPE_QBOOL,                                \</span><br><span class="line">        .defval    = (bool)_defval,                              \</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 闭包</span><br><span class="line">PropertyInfo qdev_prop_bool = &#123;</span><br><span class="line">    .name  = &quot;bool&quot;,</span><br><span class="line">    .get   = get_bool,</span><br><span class="line">    .set   = set_bool,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>而类实例 X86CPU 中定义了这些属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct X86CPU &#123;</span><br><span class="line">    bool migratable;</span><br><span class="line">    ...</span><br><span class="line">    bool cache_info_passthrough;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>于是 X86CPU.migratable 和 X86CPU.cache_info_passthrough 两个成员被定义成属性。</p><p>在父类 device_type_info 的类实例初始化函数 device_initfn 中，对所有的props，有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    for (prop = DEVICE_CLASS(class)-&gt;props; prop &amp;&amp; prop-&gt;name; prop++) &#123;</span><br><span class="line">        qdev_property_add_legacy(dev, prop, &amp;error_abort);</span><br><span class="line">        qdev_property_add_static(dev, prop, &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">    class = object_class_get_parent(class);</span><br><span class="line">&#125; while (class != object_class_by_name(TYPE_DEVICE));</span><br></pre></td></tr></table></figure></p><p>而 qdev_property_add_static ：</p><p><pre><br>=&gt; object_property_add(obj, prop-&gt;name, prop-&gt;info-&gt;name, prop-&gt;info-&gt;get, prop-&gt;info-&gt;set, prop-&gt;info-&gt;release, prop, &amp;local_err)<br>    根据Property中的数据，创建ObjectProperty，并将其加到类实例对象的 properties 中<br>    关键是将闭包中的get和set取出，作为ObjectProperty的get和set<br>=&gt; object_property_set_description     设置属性的描述字符串<br>=&gt; 设置属性的默认值<br></pre></p><h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><p>可通过命令查看设备的静态属性，参数为设备 TypeInfo 的 name：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/binss/work/qemu/qemu-2.8.1.1/x86_64-softmmu/qemu-system-x86_64 -device Broadwell-x86_64-cpu,?</span><br></pre></td></tr></table></figure></p><p>但是， x86_64-cpu 抽象设备无法打。 host-x86_64-cpu 无法列出。</p><h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>指在运行时动态进行添加的属性。比如用户通过参数传入了一个设备，需要作为属性和其它设备关联起来。<br>典型的动态属性就是 child&lt;&gt; 和 link&lt;&gt; (因为其类型就是这样构造的，后文简称child和link) 。</p><h5 id="child"><a href="#child" class="headerlink" title="child"></a>child</h5><p>child实现了composition关系，表示一个设备(parent)创建了另外一个设备(child)，parent掌控child的生命周期，负责向其发送事件。一个device只能有一个parent，但能有多个child。这样就构成一棵组合树。<br>通过 object_property_add_child 添加child：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; object_property_add            将 child 作为 obj 的属性，属性名name，类型为 &quot;child&lt;child的类名&gt;&quot;，同时getter为object_get_child_property，没有setter</span><br><span class="line">=&gt; child-&gt;parent = obj</span><br></pre></td></tr></table></figure></p><p>例如 x86_cpu_realizefn =&gt; x86_cpu_apic_create =&gt; object_property_add_child(OBJECT(cpu), “lapic”, OBJECT(cpu-&gt;apic_state), &amp;error_abort) 将创建 APICCommonState ，并设置为 X86CPU 的child。<br>可以在qemu hmp查询到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info qom-tree</span><br><span class="line">/machine (pc-q35-2.8-machine)</span><br><span class="line">  /unattached (container)</span><br><span class="line">    /device[0] (host-x86_64-cpu)</span><br></pre></td></tr></table></figure></p><h5 id="link"><a href="#link" class="headerlink" title="link"></a>link</h5><p>link实现了backlink关系，表示一个设备引用了另外一个设备，是一种松散的联系。两个设备之间能有多个link关系，可以进行修改。它完善了组合树，使其构成构成了一幅有向图。<br>通过 object_property_add_link 添加link：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 创建 LinkProperty ，填充目标(child)的信息</span><br><span class="line">=&gt; object_property_add            将 LinkProperty 作为 obj 的属性，属性名name，类型为 &quot;link&lt;child的类名&gt;&quot;，同时getter为 object_get_link_property 。如果传入了check函数，则需要回调，设置setter为 object_set_link_property</span><br></pre></td></tr></table></figure></p><p>例如 q35 有以下link：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void q35_host_initfn(Object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_RAM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.ram_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_PCI_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.pci_address_space,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_SYSTEM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.system_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_IO_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.address_space_io,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 Q35PCIHost 和 ram_memory / pci_address_space / system_memory / address_space_io 链接起来。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>根据前面所述，属性有两种定义方式，一种是通过 <code>DEFINE_PROP_*</code> 定义，另一种是通过 <code>object_property_add_&lt;type&gt;</code> 进行定义。根据不同的定义方式，set会不同，设置值的方式也有所不同。</p><h5 id="object-property-set-lt-type-gt"><a href="#object-property-set-lt-type-gt" class="headerlink" title="object_property_set_&lt;type&gt;"></a><code>object_property_set_&lt;type&gt;</code></h5><p>用于设置某个属性的值。比如 object_property_set_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=&gt; qbool_from_bool                                              将要设置的值包装成相应的 QObject ，这里是QBool</span><br><span class="line">=&gt; object_property_set_qobject</span><br><span class="line">    =&gt; qobject_input_visitor_new                                将传入的QObject包装成Visitor，其中含各类型的处理函数</span><br><span class="line">    =&gt; object_property_set =&gt; object_property_find              从props的hash table中找到对应的 ObjectProperty</span><br><span class="line">                           =&gt; prop-&gt;set</span><br></pre></td></tr></table></figure></p><p>对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 set 被设置为 set_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_bool</span><br><span class="line">=&gt; qdev_get_prop_ptr                                                                       将设备指针加上属性值在其中的偏移量，得到属性值的地址</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object   从Visitor中取出QObject</span><br><span class="line">                                                             =&gt; qbool_get_bool             从QObject中取出值，设置到属性值的地址</span><br></pre></td></tr></table></figure></p><p>对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 set 为 property_set_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property_set_bool</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object  找到QObject</span><br><span class="line">=&gt; (BoolProperty)prop-&gt;set    调用setter</span><br></pre></td></tr></table></figure></p><p>比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL)</span><br></pre></td></tr></table></figure></p><p>于是 setter 为 device_set_realized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; dc-&gt;realize                                      调用realize函数，其在 class_init 中定义</span><br><span class="line">=&gt; dev-&gt;realized = value                            设置类实例对象的成员</span><br></pre></td></tr></table></figure></p><p>一句话总结，前者的属性值的设置由 type_bool 负责设置，而后者由 setter 负责设置。</p><h5 id="object-property-get-lt-type-gt"><a href="#object-property-get-lt-type-gt" class="headerlink" title="object_property_get_&lt;type&gt;"></a><code>object_property_get_&lt;type&gt;</code></h5><p>用于读取某个属性的值。比如 object_property_get_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; object_property_get_qobject</span><br><span class="line">    =&gt; 创建空的QObject指针</span><br><span class="line">    =&gt; qobject_output_visitor_new                                                           将传入的QObject包装成Visitor，其中含各类型的处理函数</span><br><span class="line">    =&gt; object_property_get =&gt; object_property_find                                          从props的hash table中找到对应的 ObjectProperty</span><br><span class="line">                           =&gt; prop-&gt;get                                                     调用get函数，设置QObject</span><br><span class="line">=&gt; qobject_to_qbool                                                                         将QObject转成QBool</span><br><span class="line">=&gt; qbool_get_bool                                                                           从QBool中取出值，返回</span><br></pre></td></tr></table></figure></p><p>对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 get 被设置为 get_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_bool</span><br><span class="line">=&gt; qdev_get_prop_ptr(dev, prop)                                                             将设备指针加上属性值在其中的偏移量，得到属性值的地址</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object   将属性值包装成QObject</span><br></pre></td></tr></table></figure></p><p>对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 get 为 property_get_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property_get_bool</span><br><span class="line">=&gt; prop-&gt;get                                                                                调用getter，得到属性值</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object   将属性值包装成QObject</span><br></pre></td></tr></table></figure></p><p>个人的理解是，set 和 get 都需要通过 QObject 和 Visitor 两层包装。前者把要设置属性值包装成QObject再到Visitor，然后再取出设置到相应地址。后者根据属性值地址将属性值包装成QObject，设置为Visitor中QObject指针指向，然后再从QObject中取出值。</p><h5 id="object-property-parse"><a href="#object-property-parse" class="headerlink" title="object_property_parse"></a>object_property_parse</h5><p>在用一个string设置不知道类型的属性的值时，使用 object_property_parse：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void object_property_parse(Object *obj, const char *string,</span><br><span class="line">                           const char *name, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">    Visitor *v = string_input_visitor_new(string);</span><br><span class="line">    object_property_set(obj, v, name, errp);</span><br><span class="line">    visit_free(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会创建一个 Visitor 并将值设置到里面，这里定义了string转其他类型属性的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-&gt;visitor.type = VISITOR_INPUT;</span><br><span class="line">v-&gt;visitor.type_int64 = parse_type_int64;</span><br><span class="line">v-&gt;visitor.type_uint64 = parse_type_uint64;</span><br><span class="line">v-&gt;visitor.type_size = parse_type_size;</span><br><span class="line">v-&gt;visitor.type_bool = parse_type_bool;</span><br><span class="line">v-&gt;visitor.type_str = parse_type_str;</span><br><span class="line">v-&gt;visitor.type_number = parse_type_number;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如此一来，根据 TypeInfo 创建了 TypeImpl ，然后根据 TypeImpl 创建了对应的 ObjectClass ，再根据 TypeImpl 创建了对应的 Object ， ObjectClass 和 Object 都有自己的 Property，关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                TypeImpl</span><br><span class="line">                class      -&gt;  ObjectClass(AccelClass)    Object(AccelState)</span><br><span class="line">                           &lt;-       type            &lt;-         class</span><br><span class="line">TypeImpl  &lt;-  parent_type    properties(GHashTable)     properties(GHashTable)</span><br></pre></td></tr></table></figure></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: type_init(kvm_type_init)op2=>operation: module_init(function, MODULE_INIT_QOM)op3=>operation: register_module_init(function, type)op1(right)->op2(right)->op3</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: kvm_type_initop2=>operation: type_register_static(&kvm_accel_type)op3=>operation: type_registerop4=>operation: type_register_internalop1(right)->op2(right)->op3(right)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: object_class_get_listop2=>operation: object_class_foreachop3=>operation: g_hash_table_foreach(object_class_foreach_tramp)op4=>operation: object_class_foreach_trampop5=>operation: type_initializeop1(right)->op2(right)->op3(right)->op4(right)->op5</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> QEMU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QEMU QOM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Debug QEMU with GDB</title>
      <link href="/2018/12/24/qemu-debug/"/>
      <url>/2018/12/24/qemu-debug/</url>
      
        <content type="html"><![CDATA[<p>学习Qemu-KVM虚拟机最重要的一步——调试QEMU，我们这里提前帮大家简单的总结归纳一下。<br>Qemu的调试稍微有点特殊的地方就是，除了Qemu程序自身源代码的调试以外，我们可以通过Qemu+GDB来调试我们虚拟机程序。下面将两个不同方面的调试方法介绍一下。</p><h2 id="1-调试QEMU源码"><a href="#1-调试QEMU源码" class="headerlink" title="1. 调试QEMU源码"></a>1. 调试QEMU源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args x86_64-softmmu/qemu-system-x86_64 --enable-kvm -m 1024 -drive file=test.qcow2 -append console=ttyS0 -kernel /boot/vmlinuz -initrd /boot/initrd.gz</span><br></pre></td></tr></table></figure><p>当然以上参数中从–enable-kvm开始之后的参数因人而异，不尽相同。执行过之后，就会进入gdb界面，就可以跟其他普通应用程序一样，进行单步调试、设置断点、查看栈、寄存器内容等</p><h2 id="2-调试虚拟机"><a href="#2-调试虚拟机" class="headerlink" title="2. 调试虚拟机"></a>2. 调试虚拟机</h2><p>这部分是本文的重点。跟调试应用程序不同，调试虚拟机时gdb和qemu分开执行，似乎并不能用gdb来调用qemu。长话短说，先来看如何启动qemu：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./x86_64-softmmu/qemu-system-x86_64 -s -S --enable-kvm -m 1024 -hda test.qcow2</span><br></pre></td></tr></table></figure></p><p>同样，参数从–enable-kvm开始之后的参数也都不是必须的。着重了解下两个必须的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s shorthand for -gdb tcp::1234</span><br><span class="line">-S freeze CPU at startup (use &apos;c&apos; to start execution)</span><br></pre></td></tr></table></figure></p><p>然后新开一个终端执行gdb，这样就跟调试应用程序一样，会看到同样的’(gdb)’ 提示符。<br>在提示符中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure></p><p>1234是默认用于远程调试连接的端口号。<br>然后设置断点”break *0x7c00”，这样就将一个断点设置在了bootloader被加载到的内存地址，接下来就任你玩了。</p><pre>[root@ccd-sdv6 ~]# gdbGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-100.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later <http: gnu.org="" licenses="" gpl.html="">This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-redhat-linux-gnu".For bug reporting instructions, please see:<http: www.gnu.org="" software="" gdb="" bugs="">.<font color="#0099ff" face="黑体">(gdb) target remote localhost:1234</font>Remote debugging using localhost:12340x0000fff0 in ?? ()(gdb) cContinuing.Program received signal SIGINT, Interrupt.0x00002bcb in ?? ()<font color="#0099ff" face="黑体">(gdb) b *0x7c00</font>Breakpoint 1 at 0x7c00.<font color="#0099ff" face="黑体">(gdb) info breakpoints</font>Num     Type           Disp Enb Address    What1       breakpoint     keep y   0x00007c00(gdb)</http:></http:></pre><h2 id="顺便附上一些用到的gdb的快捷键以及命令"><a href="#顺便附上一些用到的gdb的快捷键以及命令" class="headerlink" title="顺便附上一些用到的gdb的快捷键以及命令"></a>顺便附上一些用到的gdb的快捷键以及命令</h2><h3 id="TUI-窗口"><a href="#TUI-窗口" class="headerlink" title="TUI 窗口"></a>TUI 窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + x, Ctrl + a</span><br><span class="line">好像等效</span><br><span class="line">Ctrl + x, a</span><br></pre></td></tr></table></figure><p>一般也就按着Ctrl键，依次按下字母x 和a就可以再TUI和非TUI间切换</p><h3 id="TUI-窗口概述"><a href="#TUI-窗口概述" class="headerlink" title="TUI 窗口概述"></a>TUI 窗口概述</h3><p>在TUI模式中，可以显示以下几个窗口：</p><ul><li>命令窗口<br>用于GDB调试时的命令输入和命令结果输出显示，与普通GDB窗口无异。</li><li>源代码窗口<br>用于显示程序源代码，包括当前运行行、中断以中断标识等。</li><li>汇编窗口<br>显示当前程序的汇编代码。</li><li>寄存器窗口<br>显示处理器的寄存器内容，当寄存器内容发生改变时会高亮显示。<br>源代码窗口和汇编窗口会高亮显示程序运行位置并以’&gt;’符号标记。有两个特殊标记用于标识断点，第一个标记用于标识断点类型：<ul><li>B : 程序至少有一次运行到了该断点</li><li>b : 程序没有运行到过该断点</li><li>H : 程序至少有一次运行到了该硬件断点</li><li>h : 程序没有运行到过该硬件断点<br>第二个标记用于标识断点使能与否:</li><li>+ : 断点使能Breakpointis enabled. </li><li>- : 断点被禁用Breakpointis disabled. </li></ul></li></ul><h3 id="三窗口模式"><a href="#三窗口模式" class="headerlink" title="三窗口模式"></a>三窗口模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + 2</span><br></pre></td></tr></table></figure><p>使TUI的上半部分分割成两个窗口，连接按此快捷键可在三种组合中切换。<br>寄存器窗口、代码窗口、汇编窗口 三个窗口只能同时显示两个，共3种组合。</p><h3 id="更换激活窗口"><a href="#更换激活窗口" class="headerlink" title="更换激活窗口"></a>更换激活窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + o</span><br></pre></td></tr></table></figure><p>之所以需要切换激活窗口，是因为有些快捷键，比如箭头上下左右，page up/down只有在当前窗口起作用</p><h3 id="GDB-command"><a href="#GDB-command" class="headerlink" title="GDB command"></a>GDB command</h3><p><code>c</code> : continue<br><code>r</code> : run<br><code>n</code> : next<br><code>s</code> : step</p><h3 id="TUI-特有命令"><a href="#TUI-特有命令" class="headerlink" title="TUI 特有命令"></a>TUI 特有命令</h3><p><code>info win</code> ：显示正在显示的窗口大小信息<br><code>layout next</code> ：显示下一个窗口<br><code>layout prev</code> ：显示上一个窗口<br><code>layout src</code> ：显示源代码窗口<br><code>layout asm</code> ：显示汇编窗口<br><code>layout split</code> ：显示源代码和汇编窗口<br><code>layout regs</code> ：显示寄存器窗口<br><code>focus next</code> ： 将一个窗口置为激活状态<br><code>focus prev</code> ：将上一个窗口置为激活状态<br><code>focus src</code> : 将源代码窗口置为激活状态<br><code>focus asm</code> ：将汇编窗口置为激活状态<br><code>focus regs</code> ： 将寄存器窗口置为激活状态<br><code>focus cmd</code> ：将命令行窗口置为激活状态<br><code>refresh</code> ： 更新窗口，与C-L快捷键同</p><p><code>tuireg float</code> ：寄存器窗口显示内容为浮点寄存器<br><code>tuireg general</code> ：寄存器窗口显示内容为普通寄存器<br><code>tuireg next</code> ：显示下一组寄存器，预定义的寄存器组: general, float,system, vector,all, save,restore.<br><code>tuireg system</code> ：显示上一组寄存器<br><code>update</code> ：更新源代码窗口到当前运行点<br><code>winname + count</code> ：增加指定窗口的高度<br><code>winname + count</code> ：减小指定窗口的高度<br><code>tabset nchars</code> : Set the width of tab stops to be nchars characters</p><h3 id="条件断点："><a href="#条件断点：" class="headerlink" title="条件断点："></a>条件断点：</h3><p>在gdb中可以watch一个寄存器，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch $eax == 0x0000ffaa</span><br></pre></td></tr></table></figure><p>另外，当我们想有条件的设置某一个断点的时候，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break test.c:120 if $eax == 0x0000ffaa</span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/24/qemu-debug/gdb_tui.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> QEMU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QEMU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM 虚拟化原理3--CPU</title>
      <link href="/2018/12/10/kvm-cpu/"/>
      <url>/2018/12/10/kvm-cpu/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU-虚拟化简介"><a href="#CPU-虚拟化简介" class="headerlink" title="CPU 虚拟化简介"></a>CPU 虚拟化简介</h2><p>上一篇文章笼统的介绍了一个虚拟机的诞生过程，从demo中也可以看到，运行一个虚拟机再也不需要像以前想象的那样，需要用软件来模拟硬件指令集了。虚拟机的指令集直接运行在宿主机物理CPU上，当虚拟机中的指令设计到IO操作或者一些特殊指令的时候，控制权转让给了宿主机（这里其实是转让给了vm monitor，下面检查VMM），也就是一个demo进程，他在宿主机上的表现形式也就是一个用户级进程。</p><p>用一张图来解释更为贴切。</p><p><img src="/2018/12/10/kvm-cpu/vcpu-follow.png" alt=""></p><p>VMM完成vCPU，内存的初始化后，通过ioctl调用KVM的接口，完成虚拟机的创建，并创建一个线程来运行VM，由于VM在前期初始化的时候会设置各种寄存器来帮助KVM查找到需要加载的指令的入口（main函数）。所以线程在调用了KVM接口后，物理CPU的控制权就交给了VM。VM运行在VMX non-root模式，这是Intel-V或者AMD-V提供的一种特殊的CPU执行模式。然后当VM执行了特殊指令的时候，CPU将当前VM的上下文保存到VMCS寄存器（这个寄存器是一个指针，保存了实际的上下文地址），然后执行权切换到VMM。VMM 获取 VM 返回原因，并做处理。如果是IO请求，VMM 可以直接读取VM的内存并将IO操作模拟出来，然后再调用VMRESUME指令，VM继续执行，此时在VM看来，IO操作的指令被CPU执行了。</p><h2 id="Intel-V-技术"><a href="#Intel-V-技术" class="headerlink" title="Intel-V 技术"></a>Intel-V 技术</h2><p>Intel-V 技术是Intel为了支持虚拟化而提供的一套CPU特殊运行模式。</p><h3 id="Intel-V虚拟化技术结构"><a href="#Intel-V虚拟化技术结构" class="headerlink" title="Intel-V虚拟化技术结构"></a>Intel-V虚拟化技术结构</h3><p>Intel-V 在IA-32处理器上扩展了处理器等级，原来的CPU支持ring0~ring3 4个等级，但是Linux只使用了其中的两个ring0,ring3。当CPU寄存器标示了当前CPU处于ring0级别的时候，表示此时CPU正在运行的是内核的代码。而当CPU处于ring3级别的时候，表示此时CPU正在运行的是用户级别的代码。当发生系统调用或者进程切换的时候，CPU会从ring3级别转到ring0级别。ring3级别是不允许执行硬件操作的，所有硬件操作都需要系统提供的API来完成。<br>比如说一个IO操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nread = read(fd, buffer, 1024);</span><br></pre></td></tr></table></figure><p>当执行到此段代码的时候，然后查找到系统调用号，保存到寄存器eax，然后会将对应的参数压栈后产生一个系统调用中断，对应的是 int $0x80。产生了系统调用中断后，此时CPU将切换到ring0模式，内核通过寄存器读取到参数，并完成最后的IO后续操作，操作完成后返回ring3模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movel　　$3,%eax</span><br><span class="line">movel　　fd,%ebx</span><br><span class="line">movel　　buffer,%ecx</span><br><span class="line">movel　　1024,%edx　　　　　　</span><br><span class="line">int　　  $0x80</span><br></pre></td></tr></table></figure><p>Intel-V 在 ring0~ring3 的基础上，增加了VMX模式，VMX分为root和non-root。这里的VMX root模式是给VMM（前面有提到VM monitor)，在KVM体系中，就是qemu-kvm进程所运行的模式。VMX non-root模式就是运行的Guest，Guest也分ring0~ring3，不过他并不感知自己处于VMX non-root模式下。</p><p><img src="/2018/12/10/kvm-cpu/vcpu-ring.png" alt=""></p><p>Intel的虚拟架构基本上分两个部分:</p><ul><li>虚拟机监视器</li><li>客户机（Guest VM)</li></ul><h4 id="虚拟机监视器（Virtual-machine-monitors-VMM"><a href="#虚拟机监视器（Virtual-machine-monitors-VMM" class="headerlink" title="虚拟机监视器（Virtual-machine monitors - VMM)"></a>虚拟机监视器（Virtual-machine monitors - VMM)</h4><p>虚拟机监视器在宿主机上表现为一个提供虚拟机CPU，内存以及一系列硬件虚拟的实体，这个实体在KVM体系中就是一个进程，如qemu-kvm。VMM负责管理虚拟机的资源，并拥有所有虚拟机资源的控制权，包括切换虚拟机的CPU上下文等。</p><h4 id="Guest"><a href="#Guest" class="headerlink" title="Guest"></a>Guest</h4><p>这个Guest在前面的Demo里面也提到，可能是一个操作系统（OS），也可能就是一个二进制程序，whatever，对于VMM来说，他就是一堆指令集，只需要知道入口（rip寄存器值）就可以加载。<br>Guest运行需要虚拟CPU，当Guest代码运行的时候，处于VMX non-root模式，此模式下，该用什么指令还是用什么指令，该用寄存器该用cache还是用cache，但是在执行到特殊指令的时候（比如Demo中的out指令），把CPU控制权交给VMM，由VMM来处理特殊指令，完成硬件操作。</p><h4 id="VMM-与-Guest-的切换"><a href="#VMM-与-Guest-的切换" class="headerlink" title="VMM 与 Guest 的切换"></a>VMM 与 Guest 的切换</h4><p><img src="/2018/12/10/kvm-cpu/vmm_guest_switch.png" alt=""></p><p>Guest与VMM之间的切换分两个部分：VM entry 和 VM exit。有几种情况会导致VM exit，比如说Guest执行了硬件访问操作，或者Guest调用了VMCALL指令或者调用了退出指令或者产生了一个page fault，或者访问了特殊设备的寄存器等。当Guest处于VMX模式的时候，没有提供获取是否处于此模式下的指令或者寄存器，也就是说，Guest不能判断当前CPU是否处于VMX模式。当产生VM exit的时候，CPU会将exit reason保存到MSRs（VMX模式的特殊寄存器组），对应到KVM就是vCPU-&gt;kvm_run-&gt;exit_reason。VMM根据exit_reason做相应的处理。</p><h4 id="VMM-的生命周期"><a href="#VMM-的生命周期" class="headerlink" title="VMM 的生命周期"></a>VMM 的生命周期</h4><p>如上图所示，VMM 开始于VMXON 指令，结束与VMXOFF指令。<br>第一次启动Guest，通过VMLAUNCH指令加载Guest，这时候一切都是新的，比如说起始的rip寄存器等。后续Guest exit后再entry，是通过VMRESUME指令，此指令会将VMCS(后面会介绍到）所指向的内容加载到当前Guest的上下文，以便Guest继续执行。</p><h4 id="VMCS-（Virtual-Machine-control-structure"><a href="#VMCS-（Virtual-Machine-control-structure" class="headerlink" title="VMCS （Virtual-Machine control structure)"></a>VMCS （Virtual-Machine control structure)</h4><p>顾名思义，VMCS就是虚拟机控制结构，前面提到过很多次，Guest Exit的时候，会将当前Guest的上下文保存到VMCS中，Guest entry的时候把VMCS上下文恢复到VMM。VMCS是一个64位的指针，指向一个真实的内存地址，VMCS是以vCPU为单位的，就是说当前有多少个vCPU，就有多少个VMCS指针。VMCS的操作包括VMREAD，VMWRITE，VMCLEAR。</p><h4 id="Guest-exit-Reason"><a href="#Guest-exit-Reason" class="headerlink" title="Guest exit Reason"></a>Guest exit Reason</h4><p>下面是qemu-kvm定义的exit reason。可以看到有很多可能会导致Guest转让控制权。选取几个解释一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = &#123;</span><br><span class="line">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception, </span><br><span class="line">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt, </span><br><span class="line">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class="line">    [EXIT_REASON_NMI_WINDOW]              = handle_nmi_window,</span><br><span class="line">     // 访问了IO设备</span><br><span class="line">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class="line">     // 访问了CR寄存器，地址寄存器，和DR寄存器（debug register)一样，用于调试</span><br><span class="line">    [EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class="line">    [EXIT_REASON_DR_ACCESS]               = handle_dr, </span><br><span class="line">    [EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class="line">    // 访问了MSR寄存器</span><br><span class="line">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class="line">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class="line">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class="line">    // Guest执行了HLT指令，Demo开胃菜就是这个指令</span><br><span class="line">    [EXIT_REASON_HLT]                     = handle_halt,</span><br><span class="line">    [EXIT_REASON_INVD]                    = handle_invd,</span><br><span class="line">    [EXIT_REASON_INVLPG]                  = handle_invlpg,</span><br><span class="line">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class="line">    // 不太清楚以下VM系列的指令有什么用，猜测是递归VM（虚拟机里面运行虚拟机）</span><br><span class="line">    [EXIT_REASON_VMCALL]                  = handle_vmcall, </span><br><span class="line">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,</span><br><span class="line">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class="line">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class="line">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class="line">    [EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class="line">    [EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class="line">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class="line">    [EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class="line">    [EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class="line"></span><br><span class="line">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class="line">    // 访问了高级PCI设备</span><br><span class="line">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class="line">    [EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class="line">    [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class="line">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class="line">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class="line">    // 进程切换</span><br><span class="line">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class="line">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class="line">    // ept 是Intel的一个硬件内存虚拟化技术</span><br><span class="line">    [EXIT_REASON_EPT_VIOLATION]           = handle_ept_violation,</span><br><span class="line">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class="line">    // 执行了暂停指令</span><br><span class="line">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class="line">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,</span><br><span class="line">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,</span><br><span class="line">    [EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>KVM的CPU虚拟化依托于Intel-V提供的虚拟化技术，将Guest运行于VMX模式，当执行了特殊操作的时候，将控制权返回给VMM。VMM处理完特殊操作后再把结果返回给Guest。<br>CPU虚拟化可以说是KVM的最关键的核心，弄清楚了VM Exit和VM Entry。后续的IO虚拟化，内存虚拟化都是建立在此基础上。下一章介绍内存虚拟化。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM 虚拟化原理2— QEMU启动过程</title>
      <link href="/2018/12/10/kvm-boot/"/>
      <url>/2018/12/10/kvm-boot/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机启动过程"><a href="#虚拟机启动过程" class="headerlink" title="虚拟机启动过程"></a>虚拟机启动过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第一步，获取到kvm句柄</span><br><span class="line">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class="line"></span><br><span class="line">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class="line">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class="line"></span><br><span class="line">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class="line"></span><br><span class="line">第四步，创建vCPU</span><br><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, vcpuio)</span><br><span class="line"></span><br><span class="line">第五步，为vCPU分配内存</span><br><span class="line">vcpu_size=ioctl(kvmfd, KVM_GET_VCPU_MMAP_SIZE, NULL)</span><br><span class="line">run = (struct kvm_run*)mmap(NULL, mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpufd, 0)</span><br><span class="line"></span><br><span class="line">第六步，创建vCPU个数的线程并运行虚拟机。</span><br><span class="line">ioctl(vcpufd, KVM_RUN, 0);</span><br><span class="line">将汇编代码加载到用户内存中，并且设置vCPU的寄存器，例如RIP</span><br><span class="line"></span><br><span class="line">第七步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class="line">while(1) &#123; ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0); &#125;;</span><br><span class="line">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;/dev/kvm&quot;)</span><br><span class="line">ioctl(KVM_CREATE_VM)</span><br><span class="line">ioctl(KVM_CREATE_VCPU)</span><br><span class="line">for (;;) &#123;</span><br><span class="line">     ioctl(KVM_RUN)</span><br><span class="line">     switch (exit_reason) &#123;</span><br><span class="line">     case KVM_EXIT_IO:  /* ... */</span><br><span class="line">     case KVM_EXIT_HLT: /* ... */</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p><p><a href="https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">KVM ioctl接口文档</a></p><h2 id="先来一个KVM-API开胃菜"><a href="#先来一个KVM-API开胃菜" class="headerlink" title="先来一个KVM API开胃菜"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\n (并不直接输出\n，而是换了一行），hlt 指令表示虚拟机退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">    .code16</span><br><span class="line">_start:</span><br><span class="line">    mov $0x3f8, %dx</span><br><span class="line">    add %bl, %al</span><br><span class="line">    add $&apos;0&apos;, %al</span><br><span class="line">    out %al, (%dx)</span><br><span class="line">    mov $&apos;\n&apos;, %al</span><br><span class="line">    out %al, (%dx)</span><br><span class="line">    hlt</span><br></pre></td></tr></table></figure><p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as -32 bin.S -o bin.o</span><br><span class="line">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure><p>查看一下二进制格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  demo1 hexdump -C bin.bin</span><br><span class="line">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class="line">0000000c</span><br><span class="line">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class="line">    const uint8_t code[] = &#123;</span><br><span class="line">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class="line">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class="line">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xb0, &apos;\n&apos;,       /* mov $&apos;\n&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xf4,             /* hlt */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;err.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;linux/kvm.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int kvm, vmfd, vcpufd, ret;</span><br><span class="line">    const uint8_t code[] = &#123;</span><br><span class="line">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class="line">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class="line">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xb0, &apos;\n&apos;,       /* mov $&apos;\n&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xf4,             /* hlt */</span><br><span class="line">    &#125;;</span><br><span class="line">    uint8_t *mem;</span><br><span class="line">    struct kvm_sregs sregs;</span><br><span class="line">    size_t mmap_size;</span><br><span class="line">    struct kvm_run *run;</span><br><span class="line"></span><br><span class="line">    // 获取 kvm 句柄 第一步</span><br><span class="line">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (kvm == -1)</span><br><span class="line">        err(1, &quot;/dev/kvm&quot;);</span><br><span class="line"></span><br><span class="line">    // 确保是正确的 API 版本</span><br><span class="line">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class="line">    if (ret != 12)</span><br><span class="line">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class="line"></span><br><span class="line">    // 创建一虚拟机 第二步</span><br><span class="line">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class="line">    if (vmfd == -1)</span><br><span class="line">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class="line"></span><br><span class="line">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class="line">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (!mem)</span><br><span class="line">        err(1, &quot;allocating guest memory&quot;);</span><br><span class="line">    memcpy(mem, code, sizeof(code));</span><br><span class="line"></span><br><span class="line">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class="line">    struct kvm_userspace_memory_region region = &#123;</span><br><span class="line">        .slot = 0,</span><br><span class="line">        .guest_phys_addr = 0x1000,</span><br><span class="line">        .memory_size = 0x1000,</span><br><span class="line">        .userspace_addr = (uint64_t)mem,</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置 KVM 的内存区域 第三部</span><br><span class="line">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class="line"></span><br><span class="line">    // 创建虚拟CPU 第四部</span><br><span class="line">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class="line">    if (vcpufd == -1)</span><br><span class="line">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class="line"></span><br><span class="line">    // 获取 KVM 运行时结构的大小</span><br><span class="line">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class="line">    mmap_size = ret;</span><br><span class="line">    if (mmap_size &lt; sizeof(*run))</span><br><span class="line">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class="line">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息 第五步</span><br><span class="line">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class="line">    if (!run)</span><br><span class="line">        err(1, &quot;mmap vcpu&quot;);</span><br><span class="line"></span><br><span class="line">    // 获取特殊寄存器  第六步</span><br><span class="line">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class="line">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class="line">    sregs.cs.base = 0;</span><br><span class="line">    sregs.cs.selector = 0;</span><br><span class="line">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class="line">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class="line">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class="line">    struct kvm_regs regs = &#123;</span><br><span class="line">        .rip = 0x1000,</span><br><span class="line">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class="line">        .rbx = 2,    // 同理</span><br><span class="line">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class="line">    &#125;;</span><br><span class="line">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class="line"></span><br><span class="line">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令 第七步</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 开始运行虚拟机</span><br><span class="line">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">            err(1, &quot;KVM_RUN&quot;);</span><br><span class="line">        // 获取虚拟机退出原因</span><br><span class="line">        switch (run-&gt;exit_reason) &#123;</span><br><span class="line">        case KVM_EXIT_HLT:</span><br><span class="line">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class="line">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class="line">        // 后面CPU虚拟化会讲到这部分</span><br><span class="line">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class="line">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class="line">        case KVM_EXIT_IO:</span><br><span class="line">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class="line">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class="line">            else</span><br><span class="line">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class="line">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class="line">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class="line">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class="line">        default:</span><br><span class="line">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行这个demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -g demo.c -o demo</span><br><span class="line">➜  demo1 ./demo</span><br><span class="line">4</span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure><h2 id="另外一个简单的QEMU-emulator-demo"><a href="#另外一个简单的QEMU-emulator-demo" class="headerlink" title="另外一个简单的QEMU emulator demo"></a>另外一个简单的QEMU emulator demo</h2><p><a href="http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/" target="_blank" rel="noopener">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">    .code16</span><br><span class="line">_start:</span><br><span class="line">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class="line">    inc %ax         # ax 值加一</span><br><span class="line">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure><p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p><p>从main函数开始说起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 初始化kvm结构体</span><br><span class="line">    struct kvm *kvm = kvm_init();</span><br><span class="line"></span><br><span class="line">    if (kvm == NULL) &#123;</span><br><span class="line">        fprintf(stderr, &quot;kvm init fauilt\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建VM，并分配内存空间</span><br><span class="line">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;create vm fault\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载镜像</span><br><span class="line">    load_binary(kvm);</span><br><span class="line"></span><br><span class="line">    // only support one vcpu now</span><br><span class="line">    kvm-&gt;vcpu_number = 1;</span><br><span class="line">    // 创建执行现场</span><br><span class="line">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class="line"></span><br><span class="line">    // 启动虚拟机</span><br><span class="line">    kvm_run_vm(kvm);</span><br><span class="line"></span><br><span class="line">    kvm_clean_vm(kvm);</span><br><span class="line">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class="line">    kvm_clean(kvm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct kvm &#123;</span><br><span class="line">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class="line">   int vm_fd;               // GUEST 的句柄</span><br><span class="line">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class="line">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class="line">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class="line"></span><br><span class="line">   int kvm_version;         </span><br><span class="line">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class="line">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class="line"></span><br><span class="line">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class="line">   int vcpu_number;         // vcpu 个数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化 kvm 结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct kvm *kvm_init(void) &#123;</span><br><span class="line">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class="line">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class="line"></span><br><span class="line">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open kvm device fault: &quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class="line"></span><br><span class="line">    return kvm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class="line">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class="line"></span><br><span class="line">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not create vm&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为 kvm 分配内存。通过系统调用.</span><br><span class="line">    kvm-&gt;ram_size = ram_size;</span><br><span class="line">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class="line">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class="line">                -1, 0);</span><br><span class="line"></span><br><span class="line">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;can not mmap ram&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class="line">    // 只有一个内存槽</span><br><span class="line">    kvm-&gt;mem.slot = 0;</span><br><span class="line">    // guest 物理内存起始地址</span><br><span class="line">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class="line">    // 虚拟机内存大小</span><br><span class="line">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class="line">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class="line">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class="line"></span><br><span class="line">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class="line">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not set user memory region&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void load_binary(struct kvm *kvm) &#123;</span><br><span class="line">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;can not open binary file\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class="line">        if (ret &lt;= 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;read size: %d&quot;, ret);</span><br><span class="line">        p += ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">struct vcpu &#123;</span><br><span class="line">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class="line">    int vcpu_fd;                 // vCPU 句柄</span><br><span class="line">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class="line">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class="line">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class="line">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class="line">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class="line">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class="line">    // 申请vcpu结构</span><br><span class="line">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class="line">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class="line">    vcpu-&gt;vcpu_id = 0;</span><br><span class="line">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class="line">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not create vcpu&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取KVM运行时结构大小</span><br><span class="line">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class="line">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class="line">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class="line">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置线程执行函数</span><br><span class="line">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class="line">    return vcpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步，以上工作就绪后，启动虚拟机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class="line">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class="line">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class="line">            perror(&quot;can not create kvm thread&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">void *kvm_cpu_thread(void *data) &#123;</span><br><span class="line">    // 获取参数</span><br><span class="line">    struct kvm *kvm = (struct kvm *)data;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 设置KVM的参数</span><br><span class="line">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;KVM start run\n&quot;);</span><br><span class="line">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class="line">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class="line"></span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            fprintf(stderr, &quot;KVM_RUN failed\n&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class="line">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class="line">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class="line">        case KVM_EXIT_UNKNOWN:</span><br><span class="line">            printf(&quot;KVM_EXIT_UNKNOWN\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_DEBUG:</span><br><span class="line">            printf(&quot;KVM_EXIT_DEBUG\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class="line">        // 把执行权交给emulator</span><br><span class="line">        case KVM_EXIT_IO:</span><br><span class="line">            printf(&quot;KVM_EXIT_IO\n&quot;);</span><br><span class="line">            printf(&quot;out port: %d, data: %d\n&quot;, </span><br><span class="line">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class="line">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class="line">                );</span><br><span class="line">            sleep(1);</span><br><span class="line">            break;</span><br><span class="line">        // 虚拟机执行了memory map IO操作</span><br><span class="line">        case KVM_EXIT_MMIO:</span><br><span class="line">            printf(&quot;KVM_EXIT_MMIO\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_INTR:</span><br><span class="line">            printf(&quot;KVM_EXIT_INTR\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_SHUTDOWN:</span><br><span class="line">            printf(&quot;KVM_EXIT_SHUTDOWN\n&quot;);</span><br><span class="line">            goto exit_kvm;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;KVM PANIC\n&quot;);</span><br><span class="line">            goto exit_kvm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">exit_kvm:</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not get sregs\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // #define CODE_START 0x1000</span><br><span class="line">    /* sregs 结构体</span><br><span class="line">        x86</span><br><span class="line">        struct kvm_sregs &#123;</span><br><span class="line">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class="line">            struct kvm_segment tr, ldt;</span><br><span class="line">            struct kvm_dtable gdt, idt;</span><br><span class="line">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class="line">            __u64 efer;</span><br><span class="line">            __u64 apic_base;</span><br><span class="line">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class="line">        &#125;;</span><br><span class="line">    */</span><br><span class="line">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class="line">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class="line">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class="line">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class="line">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class="line">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class="line">    // es 为附加段寄存器</span><br><span class="line">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class="line">    // fs, gs 同样为段寄存器</span><br><span class="line">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class="line">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class="line"></span><br><span class="line">    // 为vCPU设置以上寄存器的值</span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not set sregs&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置寄存器标志位</span><br><span class="line">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class="line">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class="line">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class="line">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class="line">    vcpu-&gt;regs.rip = 0;</span><br><span class="line">    // rsp 为堆栈顶</span><br><span class="line">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class="line">    // rbp 为堆栈底部</span><br><span class="line">    vcpu-&gt;regs.rbp= 0;</span><br><span class="line"></span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;KVM SET REGS\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class="line">read size: 712288</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 0</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 1</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 2</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 3</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p><p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本文中提到的所有源代码都可以从这里下载到，仅供大家学习交流使用<br><a href="https://github.com/ysun/kvm-cheat" target="_blank" rel="noopener">github|kvm-cheat</a></p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM 虚拟化原理1 -- 概述</title>
      <link href="/2018/12/10/kvm-overview/"/>
      <url>/2018/12/10/kvm-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="KVM虚拟化简介"><a href="#KVM虚拟化简介" class="headerlink" title="KVM虚拟化简介"></a>KVM虚拟化简介</h2><p>KVM 全称 kernel-based virtual machine，由Qumranet公司发起，2008年被RedHat收购。<br>KVM实现主要基于Intel-V或者AMD-V提供的虚拟化平台，利用Linux进程模拟虚拟机CPU和内存等。KVM不提供硬件虚拟化操作，其IO操作等都借助QEMU来完成。</p><p>Qemu  是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p><p>正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。</p><p><img src="/2018/12/10/kvm-overview/01_brief.png" alt=""></p><p>KVM有如下特点：</p><ul><li>guest作为一个普通进程运行于宿主机</li><li>guest的CPU(vCPU)作为进程的线程存在，并受到宿主机内核的调度</li></ul><h2 id="KVM整体架构"><a href="#KVM整体架构" class="headerlink" title="KVM整体架构"></a>KVM整体架构</h2><p><img src="/2018/12/10/kvm-overview/02_kvm_framework.png" alt=""></p><h3 id="虚拟CPU"><a href="#虚拟CPU" class="headerlink" title="虚拟CPU"></a>虚拟CPU</h3><p>虚拟机所有用户级别(user)的指令集，都会直接由宿主机线程执行，此线程会调用KVM的ioctl方式提供的接口加载guest的指令并在特殊的CPU模式下运行，不需要经过CPU指令集的软件模拟转换，大大的减少了虚拟化成本，这也是KVM优于其他虚拟化方式的点之一。</p><p>KVM向外提供了一个虚拟设备/dev/kvm，通过ioctl(IO设备带外管理接口）来对KVM进行操作，包括虚拟机的初始化，分配内存，指令加载等等。</p><h3 id="虚拟IO设备"><a href="#虚拟IO设备" class="headerlink" title="虚拟IO设备"></a>虚拟IO设备</h3><p>guest作为一个进程存在，当然他的内核的所有驱动等都存在，只是硬件被QEMU所模拟。guest的所有虚拟的硬件操作都会有QEMU来接管，那些由host passthrough给guest的设备除外，QEMU负责与真实的宿主机硬件打交道。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>guest的内存在host上由emulator提供，对emulator来说，guest访问的内存就是他的虚拟地址空间，guest上需要经过一次虚拟地址到物理地址的转换，转换到guest的物理地址其实也就是emulator的虚拟地址，emulator再次经过一次转换，转换为host的物理地址。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QMP 简介</title>
      <link href="/2018/12/10/qmp-introduction/"/>
      <url>/2018/12/10/qmp-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是QMP协议"><a href="#什么是QMP协议" class="headerlink" title="什么是QMP协议"></a>什么是QMP协议</h2><p>QMP，即QEMU Machine Protocol，就是qemu虚拟机中的一种协议，是qemu的一部分。qmp是基于json格式的一整套协议，通过这套协议我们可以控制qemu虚拟机实例的整个生命周期，包括挂起、暂停、快照、查询、外设的热插拔等，以及最简单的查询，都可以通过qmp实现。 有多种方法使用qmp，这里简要介绍通过tcp和unix socket使用qmp。</p><h2 id="QMP协议有哪些特征"><a href="#QMP协议有哪些特征" class="headerlink" title="QMP协议有哪些特征"></a>QMP协议有哪些特征</h2><p>1）轻量、基于文本、指令格式易于解析，因为它是json格式的；<br>2）支持异步消息，主要指通过qmp发送给虚拟机的指令支持异步；<br>3）Capabilities Negotiation，主要指我们初次建立qmp连接时，进入了capabilities negotiation模式,这时我们不能发送任何指令，除了qmp_capabilities指令，发送了qmp_capabilitie指令，我们就退出了capabilities negotiation模式，进入了指令模式（command mode），这时我们可以发送qmp指令，如{ “execute”: “query-status” }，这样就可以查询虚拟机的状态。</p><h2 id="QMP协议有哪些模式"><a href="#QMP协议有哪些模式" class="headerlink" title="QMP协议有哪些模式"></a>QMP协议有哪些模式</h2><p> 有两种模式：Capabilities Negotiation模式和Command模式。</p><h2 id="那么该如何建立qmp连接呢"><a href="#那么该如何建立qmp连接呢" class="headerlink" title="那么该如何建立qmp连接呢"></a>那么该如何建立qmp连接呢</h2><p>这里简要介绍通过tcp和unix socket使用qmp。</p><h3 id="通过TCP使用QMP"><a href="#通过TCP使用QMP" class="headerlink" title="通过TCP使用QMP"></a>通过TCP使用QMP</h3><p>使用-qmp添加qmp相关参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -<span class="built_in">enable</span>-kvm -qmp tcp:localhost:1234,server,nowait</span><br></pre></td></tr></table></figure><p>新开一个终端使用telnet 链接localhost：1234</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 1234</span><br></pre></td></tr></table></figure><p>之后就可以使用qmp的命令和虚拟机交互了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# telnet localhost 1234</span><br><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class="line">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class="line">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class="line">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="通过unix-socket使用QMP"><a href="#通过unix-socket使用QMP" class="headerlink" title="通过unix socket使用QMP"></a>通过unix socket使用QMP</h3><p>使用unix socket创建qmp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 -m 2048 -hda /root/centos6.img -enable-kvm -qmp unix:/tmp/qmp-test,server,nowait</span><br></pre></td></tr></table></figure><p>使用nc连接该socket:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /tmp/qmp-test</span><br></pre></td></tr></table></figure><p>之后就一样了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost qmp]# nc -U /tmp/qmp-test</span><br><span class="line">&#123;&quot;QMP&quot;: &#123;&quot;version&quot;: &#123;&quot;qemu&quot;: &#123;&quot;micro&quot;: 0, &quot;minor&quot;: 6, &quot;major&quot;: 2&#125;, &quot;package&quot;: &quot;&quot;&#125;, &quot;capabilities&quot;: []&#125;&#125;</span><br><span class="line">&#123; &quot;execute&quot;: &quot;qmp_capabilities&quot; &#125;</span><br><span class="line">&#123;&quot;return&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;execute&quot;: &quot;query-status&quot; &#125;</span><br><span class="line">&#123;&quot;return&quot;: &#123;&quot;status&quot;: &quot;running&quot;, &quot;singlestep&quot;: false, &quot;running&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure><p>QMP的详细命令格式可以在qemu的代码树主目录下面的qmp-commands.hx中找到。</p><h3 id="自动批量发送QMP命令"><a href="#自动批量发送QMP命令" class="headerlink" title="自动批量发送QMP命令"></a>自动批量发送QMP命令</h3><p>可以通过下面这个脚本给QEMU虚拟机发送命令。这对于测试虚拟机的一些功能是很有用的。试了一下，对于unix socket的方法能使用的，对于tcp连接的方法没有使用成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"># QEMU Monitor Protocol Python class</span><br><span class="line">#</span><br><span class="line"># Copyright (C) 2009 Red Hat Inc.</span><br><span class="line">#</span><br><span class="line"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class="line"># the COPYING file in the top-level directory.</span><br><span class="line"></span><br><span class="line">import socket, json, time, commands</span><br><span class="line">from optparse import OptionParser</span><br><span class="line"></span><br><span class="line">class QMPError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class QMPConnectError(QMPError):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class QEMUMonitorProtocol:</span><br><span class="line">    def connect(self):</span><br><span class="line">        print self.filename</span><br><span class="line">        self.sock.connect(self.filename)</span><br><span class="line">        data = self.__json_read()</span><br><span class="line">        if data == None:</span><br><span class="line">            raise QMPConnectError</span><br><span class="line">        if not data.has_key(&apos;QMP&apos;):</span><br><span class="line">            raise QMPConnectError</span><br><span class="line">        return data[&apos;QMP&apos;][&apos;capabilities&apos;]</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        self.sock.close()</span><br><span class="line"></span><br><span class="line">    def send_raw(self, line):</span><br><span class="line">        self.sock.send(str(line))</span><br><span class="line">        return self.__json_read()</span><br><span class="line"></span><br><span class="line">    def send(self, cmdline, timeout=30, convert=True):</span><br><span class="line">        end_time = time.time() + timeout</span><br><span class="line">        if convert:</span><br><span class="line">            cmd = self.__build_cmd(cmdline)</span><br><span class="line">        else:</span><br><span class="line">            cmd = cmdline</span><br><span class="line">    print(&quot;*cmdline = %s&quot; % cmd)</span><br><span class="line">        print cmd</span><br><span class="line">        self.__json_send(cmd)</span><br><span class="line">        while time.time() &lt; end_time:</span><br><span class="line">            resp = self.__json_read()</span><br><span class="line">            if resp == None:</span><br><span class="line">                return (False, None)</span><br><span class="line">            elif resp.has_key(&apos;error&apos;):</span><br><span class="line">                return (False, resp[&apos;error&apos;])</span><br><span class="line">            elif resp.has_key(&apos;return&apos;):</span><br><span class="line">                return (True, resp[&apos;return&apos;])</span><br><span class="line"></span><br><span class="line">    def read(self, timeout=30):</span><br><span class="line">        o = &quot;&quot;</span><br><span class="line">        end_time = time.time() + timeout</span><br><span class="line">        while time.time() &lt; end_time:</span><br><span class="line">            try:</span><br><span class="line">                o += self.sock.recv(1024)</span><br><span class="line">                if len(o) &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">            except:</span><br><span class="line">                time.sleep(0.01)</span><br><span class="line">        if len(o) &gt; 0:</span><br><span class="line">            return json.loads(o)</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    def __build_cmd(self, cmdline):</span><br><span class="line">        cmdargs = cmdline.split()</span><br><span class="line">        qmpcmd = &#123; &apos;execute&apos;: cmdargs[0], &apos;arguments&apos;: &#123;&#125; &#125;</span><br><span class="line">        for arg in cmdargs[1:]:</span><br><span class="line">            opt = arg.split(&apos;=&apos;)</span><br><span class="line">            try:</span><br><span class="line">                value = int(opt[1])</span><br><span class="line">            except ValueError:</span><br><span class="line">                value = opt[1]</span><br><span class="line">            qmpcmd[&apos;arguments&apos;][opt[0]] = value</span><br><span class="line">print(&quot;*cmdline = %s&quot; % cmdline)</span><br><span class="line">        return qmpcmd</span><br><span class="line"></span><br><span class="line">    def __json_send(self, cmd):</span><br><span class="line">        # XXX: We have to send any additional char, otherwise</span><br><span class="line">        # the Server won&apos;t read our input</span><br><span class="line">        self.sock.send(json.dumps(cmd) + &apos; &apos;)</span><br><span class="line"></span><br><span class="line">    def __json_read(self):</span><br><span class="line">        try:</span><br><span class="line">            return json.loads(self.sock.recv(1024))</span><br><span class="line">        except ValueError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def __init__(self, filename, protocol=&quot;tcp&quot;):</span><br><span class="line">        if protocol == &quot;tcp&quot;:</span><br><span class="line">            self.filename = (&quot;localhost&quot;, int(filename))</span><br><span class="line">            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        elif protocol == &quot;unix&quot;:</span><br><span class="line">            self.filename = filename</span><br><span class="line">            print self.filename</span><br><span class="line">            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line">        #self.sock.setblocking(0)</span><br><span class="line">        self.sock.settimeout(5)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    parser = OptionParser()</span><br><span class="line">    parser.add_option(&apos;-n&apos;, &apos;--num&apos;, dest=&apos;num&apos;, default=&apos;10&apos;, help=&apos;Times want to try&apos;)</span><br><span class="line">    parser.add_option(&apos;-f&apos;, &apos;--file&apos;, dest=&apos;port&apos;, default=&apos;4444&apos;, help=&apos;QMP port/filename&apos;)</span><br><span class="line">    parser.add_option(&apos;-p&apos;, &apos;--protocol&apos;, dest=&apos;protocol&apos;,default=&apos;tcp&apos;, help=&apos;QMP protocol&apos;)</span><br><span class="line">    def usage():</span><br><span class="line">        parser.print_help()</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    options, args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    print options</span><br><span class="line">    if len(args) &gt; 0:</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    num = int(options.num)</span><br><span class="line">    qmp_filename = options.port</span><br><span class="line">    qmp_protocol = options.protocol</span><br><span class="line">    qmp_socket = QEMUMonitorProtocol(qmp_filename,qmp_protocol)</span><br><span class="line">    qmp_socket.connect()</span><br><span class="line">    qmp_socket.send(&quot;qmp_capabilities&quot;)</span><br><span class="line">    qmp_socket.close()</span><br><span class="line"></span><br><span class="line">##########################################################</span><br><span class="line">#Usage</span><br><span class="line">#Options:</span><br><span class="line">#  -h, --help            show this help message and exit</span><br><span class="line">#  -n NUM, --num=NUM     Times want to try</span><br><span class="line">#  -f PORT, --file=PORT  QMP port/filename</span><br><span class="line">#  -p PROTOCOL, --protocol=PROTOCOL</span><br><span class="line">#                        QMP protocol</span><br><span class="line"># e.g: # python xxxxx.py -n $NUM -f $PORT</span><br><span class="line">##########################################################</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>关于QMP更详细的文档，可以参考其官方文档：<br><a href="https://wiki.qemu.org/Documentation/QMP" target="_blank" rel="noopener">https://wiki.qemu.org/Documentation/QMP</a></p>]]></content>
      
      
      <categories>
          
          <category> QEMU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QEMU </tag>
            
            <tag> QMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+next主题</title>
      <link href="/2018/11/26/hexo-next%E4%B8%BB%E9%A2%98/"/>
      <url>/2018/11/26/hexo-next%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这篇内容详细记述了我在使用hexo搭载博客的过程中走过的路和跌过的坑。<br>另外，我搭建了一个新的博客作为自己的技术博客，地址是xuquan.site，欢迎来逛逛~</p><p>从印象笔记到简书到Hexo<br>我一直有收集资料的习惯，最开始把资料都放在印象笔记里，然后自己平时处理消化之后会添加一个Learning Card作为资料开头，方便自己复习和记忆。但是时间一久，资料就特别多，加上处理过和没处理过的都积攒在一起就显得特别臃肿，于是我就考虑将消化过的内容发布到简书上，给自己做一个记录，也算是自己的技术博客。</p><p>但使用了简书3个月之后，我就发现了一些问题：</p><p>首先，我是用Typora来写内容的，简书虽然支持Markdown，但是自带的编辑器功能不是特别完善，有些时候还得反复切换Markdown和富文本模式，很麻烦；</p><p>其次，直接复制Typora的内容到简书是无法同步图片的，因为Typora的图片是放在文件夹内的asset文件夹内的，复制到简书需要图片挨个重新上传，图片多的时候简直想放弃这一篇内容；</p><p>另外，简书无法添加标签，只能分笔记本来写不同的内容，而且也不能添加置顶，功能比较单一；</p><p>在综合考虑之后，我决定搭建一个自己的博客。正好看到有人推荐hexo搭建，而且大家搭建的博客都挺赏心悦目的，我就开始动手搭建自己的了。</p><p>Hexo部署<br>hexo有中文的文档，这一点非常方便，但是在安装过程中还是很容易有疏忽的地方，导致安装失败。</p><p>安装前提<br>安装Hexo之前，必须保证自己的电脑中已经安装好了Node.js和Git。因为这两个软件我之前都安装过，这里就不重复安装过程了，检验方式如下：</p><p>image-20180809141924679<br>安装Hexo<br>安装好node.js和git后，可以通过npm来安装Hexo。</p><p>npm install -g hexo-cli<br>建站<br>之后就可以在电脑里新建一个文件夹来作为存放博客全部内容的大本营了。我们直接用hexo命令来初始化博客文件夹：</p><p>hexo init <folder><br>cd <folder><br>npm install</folder></folder></p><p><folder>就是文件夹的名字，我们可以自己随意取这个名字，我的经验是，现在初始化应该不需要后面npm install这个步骤了，在创建的时候 ，文件夹初始化已经把需要的内容都下载进去了。</folder></p><p>文件夹开始初始化了<br>站内内容<br>新建好的文件夹目录如下：</p><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>这里解释一下各个文件夹的作用：</p><p>config.yml<br>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p><p>package.json<br>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p><p>scaffolds<br>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p><p>source<br>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p>themes<br>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p><p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p><p>Hexo命令<br>init<br>新建一个网站。</p><p>hexo init <folder><br>new<br>新建文章或页面。</folder></p><p>hexo new <layout> “title”<br>这里的<layout>对应我们要添加的内容，如果是posts就是添加新的文章，如果是page就是添加新的页面。</layout></layout></p><p>默认是添加posts。</p><p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p><p>generate<br>生成静态页面</p><p>hexo generate<br>也可以简写成</p><p>hexo g<br>deploy<br>将内容部署到网站</p><p>hexo deploy<br>也可以简写成</p><p>hexo -d<br>publish<br>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p><p>hexo publish <layout> <filename><br>server<br>启动服务器，默认情况下，访问网站为<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></filename></layout></p><p>hexo server<br>也可以简写成</p><p>hexo s<br>根据我的经验，除了第一次部署的时候，我们会重点用到hexo init这个命令外，在平时写博客和发布过程中最常用的就是：</p><p>hexo n <filename> 新建文章<br>hexo s 启动服务器，在本地查看内容<br>hexo g 生成静态页面<br>hexo deploy 部署到网站<br>以上四个步骤。</filename></p><p>其实以上命令我觉得就足够了，文档里还有很多功能，但我在实际使用的过程中都还没有遇到。</p><p>搭建好后我们在localhost:4000就可以看到这样的博客内容：</p><p>image-20180809152743968<br>实际操作<br>我在新建博客之后，做了以下改动：</p><ol><li>创建“分类”页面<br>新建分类页面</li></ol><p>hexo new page categories<br>给分类页面添加类型</p><p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p><hr><p>title: 文章分类<br>date: 2017-05-27 13:47:40</p><h2 id="type-“categories”-这部分是新添加的"><a href="#type-“categories”-这部分是新添加的" class="headerlink" title="type: “categories”   #这部分是新添加的"></a>type: “categories”   #这部分是新添加的</h2><p>给模板添加分类属性</p><p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p><p>title: hexo+next主题<br>date: 1543200599000<br>categories:<br>tags:<br>给文章添加分类</p><p>现在我们可以找到一篇文章，然后尝试给它添加分类</p><p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]</p><ol start="2"><li>创建“标签”页面<br>创建”标签”页的方式和创建“分类”一样。</li></ol><p>新建“标签”页面</p><p>hexo new page tags<br>给标签页面添加类型</p><p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p><p>title: tags<br>date: 2018-08-06 22:48:29<br>type: “tags” #新添加的内容<br>给文章添加标签</p><p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号[]里，用英文逗号隔开</p><p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: [node.js, express]<br>第二种写法是用-短划线列出来</p><p>layout: posts<br>title: 写给小白的express学习笔记1： express-static文件静态管理<br>date: 2018-06-07 00:38:36<br>categories: 学习笔记<br>tags: </p><ul><li>node.js</li><li>express<br>部署域名<br>紧接着我们就可以把这些内容添加到Github页面上，然后生成我们自己的博客了。</li></ul><p>部署Github<br>首先你必须有一个github账号</p><p>然后新建一个仓库，这一有第一个坑，我之前用了hexoblog来作为项目名称，一直没能搭建成功，后来看到其他大牛的经验，才发现项目名一定要是用户名.github.io的形式(README.md可选可不选)</p><p>image-20180809153134467<br>然后在setting里添加生成页面的选项</p><p>image-20180809153304980<br>image-20180809153343362<br>这个时候github页面其实就生成好了，但是我们的内容还需要同步到github上，所以打开hexo文件夹里的配置文件config.yml，添加部署路径</p><p>image-20180809153610047<br>这里注意两小点：</p><p>属性和内容之间一定要有一个空格，配置文件有自己的格式规范<br>如果你之前没有用git关联过自己的github库，需要配置SSH等参数，否则无法成功，这部分搜git就有很多相关教程<br>我们再用hexo g &amp;&amp; hexo deploy就能将内容推送到github上了，在github页面上也能看到自己的内容了</p><p>image-20180809153933270<br>部署自己的域名<br>首先我们需要获取一个域名，我是在阿里云上购买了，上面可以根据自己想要的内容搜，比如我用了自己的名字，推荐给你的域名根据后缀不同会有价格上的区别，我选了一个不太贵的；</p><p>购买域名之后需要实名认证，这是另一个坑，我之前不知道实名认证审核完成前域名无法用，一直以为自己搭建失败了；</p><p>认证成功后需要解析域名</p><p>image-20180809154942783<br>image-20180809155013659<br>记录类型选CNAME，记录值是自己github生成页面的地址。</p><p>在博客的页面添加CNAME文件，并在里面记录自己域名的地址，将这个文件放在public文件夹下</p><p>这里还有一个小坑，CNAME文件经常被覆盖，导致我们重新部署博客后，链接就不可用了，这里可以下载一个叫hexo-generator-cname的插件，这样它会自动搞定CNAME的问题，只需要第一次手动将域名添加到文件里即可</p><p>npm i hexo-generator-cname –save<br>最后hexo g &amp;&amp; hexo deploy就可以了</p><p>NexT主题<br>hexo有很多开源的主题，我选了NexT，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p><p>首先，NexT也有中文文档，然后我们就可以开始了。</p><p>安装<br>我是用的git clone的方法，文档中还有其他方法</p><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>设置主题<br>在hexo根目录下的配置文件config.yml里设置主题</p><p>theme: next<br>配置主题<br>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。</p><p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p><p>菜单栏 menu<br>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p><p>menu:<br>  home: / || home</p><h1 id="about-about-user"><a href="#about-about-user" class="headerlink" title="about: /about/ || user"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  archives: /archives/ || archive</p><h1 id="schedule-schedule-calendar"><a href="#schedule-schedule-calendar" class="headerlink" title="schedule: /schedule/ || calendar"></a>schedule: /schedule/ || calendar</h1><h1 id="sitemap-sitemap-xml-sitemap"><a href="#sitemap-sitemap-xml-sitemap" class="headerlink" title="sitemap: /sitemap.xml || sitemap"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id="commonweal-404-heartbeat"><a href="#commonweal-404-heartbeat" class="headerlink" title="commonweal: /404/ || heartbeat"></a>commonweal: /404/ || heartbeat</h1><p>注意点：</p><p>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示<br>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里<br>||后面是fontAwesome里的文件对应的名称<br>menu_icons记得选enable: true（默认应该是true）<br>我在这部分添加了两个自定义的页面，后面在第三方插件部分我会再提到。</pagename></p><p>menu:<br>  home: / || home</p><h1 id="about-about-user-1"><a href="#about-about-user-1" class="headerlink" title="about: /about/ || user"></a>about: /about/ || user</h1><p>  tags: /tags/ || tags<br>  categories: /categories/ || th<br>  读书: /books || book<br>  电影: /movies || film<br>  archives: /archives/ || archive</p><h1 id="schedule-schedule-calendar-1"><a href="#schedule-schedule-calendar-1" class="headerlink" title="schedule: /schedule/ || calendar"></a>schedule: /schedule/ || calendar</h1><h1 id="sitemap-sitemap-xml-sitemap-1"><a href="#sitemap-sitemap-xml-sitemap-1" class="headerlink" title="sitemap: /sitemap.xml || sitemap"></a>sitemap: /sitemap.xml || sitemap</h1><h1 id="commonweal-404-heartbeat-1"><a href="#commonweal-404-heartbeat-1" class="headerlink" title="commonweal: /404/ || heartbeat"></a>commonweal: /404/ || heartbeat</h1><p>主题风格 schemes<br>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p><p>Muse</p><p>image-20180809164700600<br>Mist</p><p>image-20180809164749052<br>Pisces</p><p>image-20180809164925685<br>Gemini</p><p>image-20180809165023401<br>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p><p>底部建站时间和图标修改<br>修改主题的配置文件：</p><p>footer:</p><h1 id="Specify-the-date-when-the-site-was-setup"><a href="#Specify-the-date-when-the-site-was-setup" class="headerlink" title="Specify the date when the site was setup."></a>Specify the date when the site was setup.</h1><h1 id="If-not-defined-current-year-will-be-used"><a href="#If-not-defined-current-year-will-be-used" class="headerlink" title="If not defined, current year will be used."></a>If not defined, current year will be used.</h1><p>  since: 2018</p><h1 id="Icon-between-year-and-copyright-info"><a href="#Icon-between-year-and-copyright-info" class="headerlink" title="Icon between year and copyright info."></a>Icon between year and copyright info.</h1><p>  icon: snowflake-o</p><h1 id="If-not-defined-will-be-used-author-from-Hexo-main-config"><a href="#If-not-defined-will-be-used-author-from-Hexo-main-config" class="headerlink" title="If not defined, will be used author from Hexo main config."></a>If not defined, will be used <code>author</code> from Hexo main config.</h1><p>  copyright:</p><h1 id="————————————————————"><a href="#————————————————————" class="headerlink" title="————————————————————-"></a>————————————————————-</h1><h1 id="Hexo-link-Powered-by-Hexo"><a href="#Hexo-link-Powered-by-Hexo" class="headerlink" title="Hexo link (Powered by Hexo)."></a>Hexo link (Powered by Hexo).</h1><p>  powered: false</p><p>  theme:</p><pre><code># Theme &amp; scheme info link (Theme - NexT.scheme).enable: false# Version info of NexT after scheme info (vX.X.X).# version: false</code></pre><p>我在这部分做了这样几件事：</p><p>把用户的图标从小人user改成了雪花snowflake-o<br>copyright留空，显示成页面author即我的名字<br>powered: false把hexo的授权图片取消了<br>theme: enable:false 把主题的内容也取消了<br>这样底部信息比较简单。</p><p>image-20180809172835606<br>个人社交信息 social<br>在social里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。</p><p>social:<br>  GitHub: <a href="https://github.com/XuQuan-nikkkki" target="_blank" rel="noopener">https://github.com/XuQuan-nikkkki</a> || github<br>  E-Mail: mailto:<a href="mailto:xuquan1225@hotmail.com" target="_blank" rel="noopener">xuquan1225@hotmail.com</a> || envelope</p><p>  #Google: <a href="https://plus.google.com/yourname" target="_blank" rel="noopener">https://plus.google.com/yourname</a> || google</p><p>  #Twitter: <a href="https://twitter.com/yourname" target="_blank" rel="noopener">https://twitter.com/yourname</a> || twitter</p><p>  #FB Page: <a href="https://www.facebook.com/yourname" target="_blank" rel="noopener">https://www.facebook.com/yourname</a> || facebook<br>注意点：</p><p>||后面对应的名称是fontAwesome里图标的名称，如果我们选择的账号没有对应的图标（如豆瓣、知乎），我们可以在fontAwesome库里去选择自己喜欢的图标<br>建议不要找太新的fontAwesome图标，主题关联的库版本没有那么新，很可能显示不了或者显示一个地球<br>网站动画效果<br>为了网站响应速度我们可以把网站的动画关掉</p><p>motion:<br>  enable: false<br>但我觉得页面比较素，所以开了动画，选择了canvas-nest这一个，主题自带四种效果，可以选自己喜欢的。</p><p>motion:<br>  enable: true<br>  async: true</p><h1 id="Canvas-nest"><a href="#Canvas-nest" class="headerlink" title="Canvas-nest"></a>Canvas-nest</h1><p>canvas_nest: true</p><h1 id="three-waves"><a href="#three-waves" class="headerlink" title="three_waves"></a>three_waves</h1><p>three_waves: false</p><h1 id="canvas-lines"><a href="#canvas-lines" class="headerlink" title="canvas_lines"></a>canvas_lines</h1><p>canvas_lines: false</p><h1 id="canvas-sphere"><a href="#canvas-sphere" class="headerlink" title="canvas_sphere"></a>canvas_sphere</h1><p>canvas_sphere: false<br>评论系统<br>NexT原生支持多说、Disqus、hypercomments等多种评论系统。我选择了Disqus。</p><p>方法也非常简单。直接去Disqus注册，注册完了在配置的时候会给你一个名为shortname的ID，将这个ID填在配置文件里即可。</p><h1 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h1><p>disqus:<br>  enable: true<br>  shortname: xuquan<br>  count: true<br>统计文章字数和阅读时间<br>post_wordcount:<br>  item_text: true<br>  wordcount: true  # 文章字数<br>  min2read: true   # 阅读时间<br>  totalcount: true  # 总共字数<br>  separated_meta: true<br>统计阅读次数<br>这里我用的是leancloud的服务，具体方法参考NexT上的教程,添加完之后效果如下：</p><p>image-20180809175133462<br>第三方插件<br>Hexo-admin<br>Hexo-admin插件允许我们直接在本地页面上修改文章内容。</p><p>下载</p><p>npm i hexo-admin –save<br>登录<a href="http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容" target="_blank" rel="noopener">http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容</a></p><p>Hexo-douban<br>hexo-douban插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。</p><p>下载</p><p>npm install hexo-douban –save<br>配置</p><p>在hexo根目录下的config.yml文件中添加如下内容</p><p>douban:<br>  user:<br>  builtin: false<br>  book:<br>    title: ‘This is my book title’<br>    quote: ‘This is my book quote’<br>  movie:<br>    title: ‘This is my movie title’<br>    quote: ‘This is my movie quote’<br>  game:<br>    title: ‘This is my game title’<br>    quote: ‘This is my game quote’<br>  timeout: 10000<br>title和quote后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。</p><p>user就写我们豆瓣的id，可以在“我的豆瓣”页面中找到，builtin指是否将生成页面功能嵌入hexo s和hexo g中，建议选false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面，长到怀疑人生。</p><p>生成页面</p><p>hexo douban   #生成读书、电影、游戏三个页面<br>hexo douban -b  #生成读书页面<br>hexo douban -m  #生成电影页面<br>hexo douban -g  #生成游戏页面<br>在博客中生成页面</p><p>这里就需要用到我们前面提过的hexo new命令了。</p><p>hexo new page books<br>hexo new page movies<br>hexo new page games<br>在博客中添加页面</p><p>在menu部分添加我们需要添加的页面名称和相对路径</p><p>menu:<br>  Home: /<br>  Archives: /archives<br>  Books: /books     #This is your books page<br>  Movies: /movies   #This is your movies page<br>  Games: /games   #This is your games page<br>部署到博客</p><p>hexo g &amp;&amp; hexo deploy<br>我踩过的坑<br>iPic图片上传<br>hexo博客发布Typora写好的内容也会出现图片无法同步的问题，网上有大佬给出的解决方案是使用hexo-asset-image插件，这样在创建博客时会有一个与.md文件同名的文件夹，将图片同步到文件夹内即可。</p><p>但时间下来还是比较麻烦，因为Typora并没有自定义图片路径的功能，它会放在与文件相关的asset文件夹内。</p><p>我找到的最终方案是使用Typora自带的一个功能：图片上传iPic图床。这样在添加图片的时候，图片链接就自动更换成了图床的地址，这时同步到博客就没有问题了。</p><p>评论系统<br>因为多说已经停止服务了，最开始看到有人说Disqus得翻墙，就选了一个韩国的评论服务，叫来必力，但事实证明墙外就没有稳定的服务，在我挂VPN的情况下也要加载好半天，后来就还是换成了Disqus，具体配置方法看前文。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>KVM源代码分析4:内存虚拟化</title>
      <link href="/2014/12/11/kvm-src-4-mem/"/>
      <url>/2014/12/11/kvm-src-4-mem/</url>
      
        <content type="html"><![CDATA[<p>代码版本：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v3.16.37</p><p>在虚拟机的创建与运行中pc_init_pci负责(“KVM源代码分析2:虚拟机的创建与运行”)，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。</p><p>插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：</p><pre class="lang:c decode:1 hljs cpp">typedefstruct RAMBlock {//对应宿主的内存地址    uint8_t *host;//block在ramlist中的偏移    ram_addr_t offset;//block长度    ram_addr_t length;    uint32_t flags;//block名字    char idstr[256];    QLIST_ENTRY(RAMBlock) next;\#if defined(__linux__) && !defined(TARGET_S390X)    int fd;\#endif} RAMBlock;typedef struct RAMList {//看代码理解就是list的head，但是不知道为啥叫dirty...    uint8_t *phys_dirty;    QLIST_HEAD(ram, RAMBlock) blocks;} RAMList;</pre><p>下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在”KVM源代码分析2:虚拟机的创建与运行”，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。</p><pre class="lang:c decode:1 hljs cpp">void \*qemu_memalign(size_t alignment, size_t size){    void *ptr;//使用posix进行内存针对页大小对齐\#if defined(_POSIX_C_SOURCE) && !defined(__sun__)    int ret;    ret = posix_memalign(&ptr, alignment, size);    if (ret != 0) {        fprintf(stderr, "Failed to allocate %zu B: %sn",                size, strerror(ret));        abort();    }\#elif defined(CONFIG_BSD)    ptr = qemu_oom_check(valloc(size));\#else//所谓检查oom就是看memalign对应malloc申请内存是否成功    ptr = qemu_oom_check(memalign(alignment, size));\#endif    trace_qemu_memalign(alignment, size, ptr);    return ptr;}</pre><p>以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。<br>然后一层层的退回到pc_memory_init函数。</p><p>此时pc.ram已经分配完成，ram_addr已经拿到了<a href="http://www.oenhan.com/kernel-program-exec" title="从一次内存泄露看程序在内核中的执行过程" target="_blank" rel="noopener">分配的内存</a>地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是</p><pre class="lang:c decode:1 hljs cpp">struct kvm_userspace_memory_region {__u32 slot;__u32 flags;__u64 guest_phys_addr;__u64 memory_size; /* bytes */__u64 userspace_addr; /* start of the userspace allocated memory */};</pre><p>kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到<strong>kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE - 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE - 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE - 1)) || !access_ok(VERIFY_WRITE,(void </strong>user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。<br>id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm “KVM源代码分析2:虚拟机的创建与运行”中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。<br>扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：</p><pre class="lang:c decode:1 hljs cs">//映射内存有大小，不是删除内存条if (npages) {//内存槽号没有虚拟内存条，意味内存新创建if (!old.npages)        change = KVM_MR_CREATE;    else { /* Modify an existing slot. *///修改已存在的内存修改标志或者平移映射地址//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）        if ((mem->userspace_addr != old.userspace_addr) ||            (npages != old.npages) ||            ((new.flags ^ old.flags) & KVM_MEM_READONLY))            goto out;//guest地址不同，内存条平移        if (base_gfn != old.base_gfn)            change = KVM_MR_MOVE;        else if (new.flags != old.flags)//修改属性            change = KVM_MR_FLAGS_ONLY;        else { /* Nothing to change. */            r = 0;            goto out;        }    }} else if (old.npages) {//申请插入的内存为0，而内存槽上有内存，意味删除    change = KVM_MR_DELETE;} else /* Modify a non-existent slot: disallowed. */    goto out;</pre><p>另外看kvm_mr_change就知道memslot的变动值了：</p><pre class="lang:c decode:1 hljs cpp">enum kvm_mr_change {    KVM_MR_CREATE,    KVM_MR_DELETE,    KVM_MR_MOVE,    KVM_MR_FLAGS_ONLY,};</pre><p>在往下是一段检查</p><pre class="lang:c decode:1 hljs php">if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {    /* Check for overlaps */    r = -EEXIST;    kvm_for_each_memslot(slot, kvm->memslots) {        if ((slot->id >= KVM_USER_MEM_SLOTS) ||//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的            (slot->id == mem->slot))            continue;//下面就是当前已有的slot与new在guest线性区间上有交集        if (!((base_gfn + npages <= slot-="">base_gfn) ||              (base_gfn >= slot->base_gfn + slot->npages)))            goto out;//out错误码就是EEXIST    }}</=></pre><p>如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages - 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;0<em>9,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;1</em>9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。<br>如果有脏页,并且脏页位图为空,则分配<a href="http://www.oenhan.com/linux-cache-writeback" target="_blank" rel="noopener">脏页位图</a>, kvm_create_dirty_bitmap实际就是”页数/8”.</p><pre class="lang:c decode:1 hljs cpp">if ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {        if (kvm_create_dirty_bitmap(&new) < 0)            goto out_free;    }</pre><p>当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。</p><p>内存的添加说完了，看一下<a href="http://www.oenhan.com/kernel-program-exec" target="_blank" rel="noopener">EPT页表</a>的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。</p><pre class="hljs php">context->page_fault = tdp_page_fault;context->sync_page = nonpaging_sync_page;context->invlpg = nonpaging_invlpg;context->update_pte = nonpaging_update_pte;context->shadow_root_level = kvm_x86_ops->get_tdp_level();context->root_hpa = INVALID_PAGE;context->direct_map = true;context->set_cr3 = kvm_x86_ops->set_tdp_cr3;context->get_cr3 = get_cr3;context->get_pdptr = kvm_pdptr_read;context->inject_page_fault = kvm_inject_page_fault;</pre><p>当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。</p><pre class="hljs cpp">//填充kvm mmu专用的slabr = mmu_topup_memory_caches(vcpu);//获取gfn使用的level，即hugepage的问题force_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);if (likely(!force_pt_level)) {    level = mapping_level(vcpu, gfn);    gfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);} else    level = PT_PAGE_TABLE_LEVEL;//顾名思义，快速处理一个简单的page fault//即present同时有写权限的非mmio page fault//参考page_fault_can_be_fast函数//一部分处理没有写权限的page fault//一部分处理 TLB lazy//fast_pf_fix_direct_spte也就是将pte获取的写权限if (fast_page_fault(vcpu, gpa, level, error_code))    return 0;//下面函数主要就一件事情，gfn_to_pfnif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))      return 0;//direct map就是映射ept页表的过程r = __direct_map(vcpu, gpa, write, map_writable,      level, gfn, pfn, prefault);</pre><p>在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:</p><pre class="hljs objectivec">static pfn_t__gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,             bool *async, bool write_fault, bool *writable){    unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);    if (addr == KVM_HVA_ERR_RO_BAD)        return KVM_PFN_ERR_RO_FAULT;    if (kvm_is_error_hva(addr))        return KVM_PFN_NOSLOT;    /* Do not map writable pfn in the readonly memslot. */    if (writable && memslot_is_readonly(slot)) {        *writable = false;        writable = NULL;    }    return hva_to_pfn(addr, atomic, async, write_fault,              writable);}</pre><p>gfn2hva本质就是</p><pre class="hljs cpp">staticinline unsigned long__gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn){    return slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE;}</pre><p>而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。</p><pre class="hljs php">static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,            int map_writable, int level, gfn_t gfn, pfn_t pfn,            bool prefault){    struct kvm_shadow_walk_iterator iterator;    struct kvm_mmu_page *sp;    int emulate = 0;    gfn_t pseudo_gfn;    if (!VALID_PAGE(vcpu->arch.mmu.root_hpa))        return0;//遍历ept四级页表    for_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {//如果是最后一级，level是hugepage下的level        if (iterator.level == level) {//设置pte，页表下一级的page地址就是pfn写入到pte            mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,                     write, &emulate, level, gfn, pfn,                     prefault, map_writable);            direct_pte_prefetch(vcpu, iterator.sptep);            ++vcpu->stat.pf_fixed;            break;        }        drop_large_spte(vcpu, iterator.sptep);//mmu page不在位的情况，也就是缺页        if (!is_shadow_present_pte(*iterator.sptep)) {            u64 base_addr = iterator.addr;//获取指向的具体mmu page entry的index            base_addr &= PT64_LVL_ADDR_MASK(iterator.level);            pseudo_gfn = base_addr >> PAGE_SHIFT;//获取mmu page            sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,                          iterator.level - 1,                          1, ACC_ALL, iterator.sptep);//将当前的mmu page的地址写入到上一级别mmu page的pte中            link_shadow_page(iterator.sptep, sp, true);        }    }    return emulate;}static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,                         gfn_t gfn,                         gva_t gaddr,                         unsigned level,                         int direct,                         unsigned access,                         u64 *parent_pte){    union kvm_mmu_page_role role;    unsigned quadrant;    struct kvm_mmu_page *sp;    bool need_sync = false;    role = vcpu->arch.mmu.base_role;    role.level = level;    role.direct = direct;    if (role.direct)        role.cr4_pae = 0;    role.access = access;    if (!vcpu->arch.mmu.direct_map        && vcpu->arch.mmu.root_level <= pt32_root_level)="" {="" quadrant="gaddr">> (PAGE_SHIFT + (PT64_PT_BITS * level));        quadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;        role.quadrant = quadrant;    }//根据一个hash索引来的    for_each_gfn_sp(vcpu->kvm, sp, gfn) {//检查整个mmu ept是否被失效了        if (is_obsolete_sp(vcpu->kvm, sp))            continue;        if (!need_sync && sp->unsync)            need_sync = true;        if (sp->role.word != role.word)            continue;        if (sp->unsync && kvm_sync_page_transient(vcpu, sp))            break;        mmu_page_add_parent_pte(vcpu, sp, parent_pte);        if (sp->unsync_children) {            kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);            kvm_mmu_mark_parents_unsync(sp);        } else if (sp->unsync)            kvm_mmu_mark_parents_unsync(sp);        __clear_sp_write_flooding_count(sp);        trace_kvm_mmu_get_page(sp, false);        return sp;    }    ++vcpu->kvm->stat.mmu_cache_miss;    sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);    if (!sp)        return sp;    sp->gfn = gfn;    sp->role = role;//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有//被分配    hlist_add_head(&sp->hash_link,        &vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);    if (!direct) {        if (rmap_write_protect(vcpu->kvm, gfn))            kvm_flush_remote_tlbs(vcpu->kvm);        if (level > PT_PAGE_TABLE_LEVEL && need_sync)            kvm_sync_pages(vcpu, gfn);        account_shadowed(vcpu->kvm, gfn);    }    sp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;    init_shadow_page_table(sp);    trace_kvm_mmu_get_page(sp, true);    return sp;}</=></pre><p>这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM源代码分析3:CPU虚拟化</title>
      <link href="/2014/12/11/kvm-src-3-cpu/"/>
      <url>/2014/12/11/kvm-src-3-cpu/</url>
      
        <content type="html"><![CDATA[<p>在<a href="http://www.oenhan.com/kvm-src-2-vm-run" title="KVM源代码分析2:虚拟机的创建与运行" target="_blank" rel="noopener">虚拟机的创建与运行</a>章节里面笼统的介绍了KVM在qemu中的创建和运行，基本的qemu代码流程已经梳理清楚，后续主要写一些硬件虚拟化的原理和代码流程，主要写原理和qemu控制KVM运行的的ioctl接口，后续对内核代码的梳理也从这些接口下手。</p><p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p><p>KVM：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p><h4 id="1-VT-x-技术"><a href="#1-VT-x-技术" class="headerlink" title="1.VT-x 技术"></a>1.VT-x 技术</h4><p>Intel处理器支持的虚拟化技术即是VT-x，之所以CPU支持硬件虚拟化是因为软件虚拟化的效率太低。</p><p>处理器虚拟化的本质是分时共享，主要体现在状态恢复和资源隔离，实际上每个VM对于VMM看就是一个task么，之前Intel处理器在虚拟化上没有提供默认的硬件支持，传统 x86 处理器有4个特权级，Linux使用了0,3级别，0即内核，3即用户态，（更多参考<a href="http://blog.csdn.net/drshenlei/article/details/4265101" target="_blank" rel="noopener">CPU的运行环、特权级与保护</a>）而在虚拟化架构上，虚拟机监控器的运行级别需要内核态特权级，而CPU特权级被传统OS占用，所以Intel设计了VT-x，提出了VMX模式，即VMX root operation 和 VMX non-root operation，虚拟机监控器运行在VMX root operation，虚拟机运行在VMX non-root operation。每个模式下都有相对应的0~3特权级。</p><p>为什么引入这两种特殊模式，在传统x86的系统中，CPU有不同的特权级，是为了划分不同的权限指令，某些指令只能由系统软件操作，称为特权指令，这些指令只能在最高特权级上才能正确执行，反之则会触发异常，处理器会陷入到最高特权级，由系统软件处理。还有一种需要操作特权资源（如访问<a href="http://www.oenhan.com/rwsem-realtime-task-hung" title="读写信号量与实时进程阻塞挂死问题" target="_blank" rel="noopener">中断寄存器</a>）的指令，称为敏感指令。OS运行在特权级上，屏蔽掉用户态直接执行的特权指令，达到控制所有的硬件资源目的；而在虚拟化环境中，VMM控制所有所有硬件资源，VM中的OS只能占用一部分资源，OS执行的很多特权指令是不能真正对硬件生效的，所以原特权级下有了root模式，OS指令不需要修改就可以正常执行在特权级上，但这个特权级的所有敏感指令都会传递到root模式处理，这样达到了VMM的目的。</p><p>在<a href="http://www.oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM源代码分析1:基本工作原理</a>章节中也说了kvm分3个模式，对应到VT-x 中即是客户模式对应vmx非root模式，内核模式对应VMX root模式下的0特权级，用户模式对应vmx root模式下的3特权级。</p><p>如下图<br><img src="/2014/12/11/kvm-src-3-cpu/kvm_vmx_intel-1.jpg" alt=""></p><p>在非根模式下敏感指令引发的陷入称为VM-Exit，VM-Exit发生后，CPU从非根模式切换到根模式；对应的，VM-Entry则是从根模式到非根模式，通常意味着调用VM进入运行态。VMLAUCH/VMRESUME命令则是用来发起VM-Entry。</p><h4 id="2-VMCS寄存器"><a href="#2-VMCS寄存器" class="headerlink" title="2.VMCS寄存器"></a>2.VMCS寄存器</h4><p>VMCS保存虚拟机的相关CPU状态，每个VCPU都有一个VMCS（内存的），每个物理CPU都有VMCS对应的<a href="http://www.oenhan.com/gdb-principle" title="gdb工作原理和内核实现" target="_blank" rel="noopener">寄存器</a>（物理的），当CPU发生VM-Entry时，CPU则从VCPU指定的内存中读取VMCS加载到物理CPU上执行，当发生VM-Exit时，CPU则将当前的CPU状态保存到VCPU指定的内存中，即VMCS，以备下次VMRESUME。</p><p>VMLAUCH指VM的第一次VM-Entry，VMRESUME则是VMLAUCH之后后续的VM-Entry。VMCS下有一些控制域：</p><p><colgroup></colgroup></p><p><col width="51*"></p><p><col width="51*"></p><p><col width="51*"></p><p><col width="51*"></p><p><col width="51*"> <br>col 1                  | col 2                                                    | col 3<br>———————- | ——————————————————– | —————————————————————–<br> VM-execution controls |  Determines what operations cause VM exits               |  CR0, CR3, CR4, Exceptions, IO Ports, Interrupts, Pin Events, etc<br>Guest-state area       |  Saved on VM exits，Reloaded on VM entry                  |  EIP, ESP, EFLAGS, IDTR, Segment Regs, Exit info, etc<br> Host-state area       |  Loaded on VM exits                                      |  CR3, EIP set to monitor entry point, EFLAGS hardcoded, etc<br> VM-exit controls      |  Determines which state to save, load, how to transition |  Example: MSR save-load list<br> VM-entry controls     |  Determines which state to load, how to transition       |  Including injecting events (interrupts, exceptions) on entry    </p><p>关于具体控制域的细节，还是翻Intel手册吧。</p><h4 id="3-VM-Entry-VM-Exit"><a href="#3-VM-Entry-VM-Exit" class="headerlink" title="3.VM-Entry/VM-Exit"></a>3.VM-Entry/VM-Exit</h4><p>VM-Entry是从根模式切换到非根模式，即VMM切换到guest上，这个状态由VMM发起，发起之前先保存VMM中的关键寄存器内容到VMCS中，然后进入到VM-Entry，VM-Entry附带参数主要有3个：1.guest是否处于64bit模式，2.MSR VM-Entry控制，3.注入事件。1应该只在VMLAUCH有意义，3更多是在VMRESUME，而VMM发起VM-Entry更多是因为3，2主要用来每次更新MSR。</p><p>VM-Exit是CPU从非根模式切换到根模式，从guest切换到VMM的操作，VM-Exit触发的原因就很多了，执行敏感指令，<a href="http://www.oenhan.com/rwsem-realtime-task-hung" title="读写信号量与实时进程阻塞挂死问题" target="_blank" rel="noopener">发生中断</a>，模拟特权资源等。</p><p>运行在非根模式下的敏感指令一般分为3个方面：</p><p>1.行为没有变化的，也就是说该指令能够正确执行。</p><p>2.行为有变化的，直接产生VM-Exit。</p><p>3.行为有变化的，但是是否产生VM-Exit受到VM-Execution控制域控制。</p><p>主要说一下”受到VM-Execution控制域控制”的敏感指令，这个就是针对性的硬件优化了，一般是1.产生VM-Exit；2.不产生VM-Exit，同时调用优化函数完成功能。典型的有“RDTSC指令”。除了大部分是优化性能的，还有一小部分是直接VM-Exit执行指令结果是异常的，或者说在<a href="http://www.oenhan.com/kvm-src-1" title="KVM源代码分析1:基本工作原理" target="_blank" rel="noopener">虚拟化</a>场景下是不适用的，典型的就是TSC offset了。</p><p>VM-Exit发生时退出的相关信息，如退出原因、触发中断等，这些内容保存在VM-Exit信息域中。</p><h4 id="4-KVM-CREATE-VM"><a href="#4-KVM-CREATE-VM" class="headerlink" title="4.KVM_CREATE_VM"></a>4.KVM_CREATE_VM</h4><p>创建VM就写这里吧，kvm_dev_ioctl_create_vm函数是主干，在kvm_create_vm中，主要有两个函数，kvm_arch_init_vm和hardware_enable_all，需要注意，但是更先一步的是KVM结构体，下面的struct是精简后的版本。</p><pre class="lang:c decode:1 hljs cpp">struct kvm {    struct mm_struct *mm; /* userspace tied to this vm */    struct kvm_memslots *memslots;  /*qemu模拟的内存条模型*/    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; /* 模拟的CPU */    atomic_t online_vcpus;    int last_boosted_vcpu;    struct list_head vm_list;  //HOST上VM管理链表，    struct kvm_io_bus *buses[KVM_NR_BUSES];    struct kvm_vm_stat stat;    struct kvm_arch arch; //这个是host的arch的一些参数    atomic_t users_count;    long tlbs_dirty;    struct list_head devices;};</pre><p>kvm_arch_init_vm基本没有特别动作，初始化了KVM-&gt;arch，以及更新了kvmclock函数，这个另外再说。<br>而hardware_enable_all，针对于每个CPU执行“on_each_cpu(hardware_enable_nolock, NULL, 1）”，在hardware_enable_nolock中先把cpus_hardware_enabled置位，进入到kvm_arch_hardware_enable中，有hardware_enable和TSC初始化规则，主要看hardware_enable，crash_enable_local_vmclear清理<a href="http://www.oenhan.com/reiserfs_check_can_fit_pages_for_8tb" title="reiserfs分区空闲8TB写文件提示磁盘空间不足" target="_blank" rel="noopener">位图</a>，判断MSR_IA32_FEATURE_CONTROL寄存器是否满足虚拟环境，不满足则将条件写入到寄存器内，CR4将X86_CR4_VMXE置位，另外还有kvm_cpu_vmxon打开VMX操作模式，外层包了vmm_exclusive的判断，它是kvm_intel.ko的外置参数，默认唯一，可以让用户强制不使用VMM硬件支持。</p><h4 id="5-KVM-CREATE-VCPU"><a href="#5-KVM-CREATE-VCPU" class="headerlink" title="5.KVM_CREATE_VCPU"></a>5.KVM_CREATE_VCPU</h4><p>kvm_vm_ioctl_create_vcpu主要有三部分，kvm_arch_vcpu_create，kvm_arch_vcpu_setup和kvm_arch_vcpu_postcreate，重点自然是kvm_arch_vcpu_create。老样子，在这之前先看一下VCPU的结构体。</p><pre class="lang:c decode:1 hljs cpp">struct kvm_vcpu {    struct kvm *kvm;  //归属的KVM\#ifdef CONFIG_PREEMPT_NOTIFIERSstruct preempt_notifier preempt_notifier;\#endif    int cpu;    int vcpu_id;    int srcu_idx;    int mode;    unsigned long requests;    unsigned long guest_debug;    struct mutex mutex;    struct kvm_run *run;  //运行时的状态    int fpu_active;    int guest_fpu_loaded, guest_xcr0_loaded;    wait_queue_head_t wq; //队列    struct pid *pid;    int sigset_active;    sigset_t sigset;    struct kvm_vcpu_stat stat; //一些数据\#ifdef CONFIG_HAS_IOMEM    int mmio_needed;    int mmio_read_completed;    int mmio_is_write;    int mmio_cur_fragment;    int mmio_nr_fragments;    struct kvm_mmio_fragment mmio_fragments[KVM_MAX_MMIO_FRAGMENTS];\#endif\#ifdef CONFIG_KVM_ASYNC_PF    struct {        u32 queued;        struct list_head queue;        struct list_head done;        spinlock_t lock;    } async_pf;\#endif\#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT    /*     \* Cpu relax intercept or pause loop exit optimization     \* in_spin_loop: set when a vcpu does a pause loop exit     \*  or cpu relax intercepted.     \* dy_eligible: indicates whether vcpu is eligible for directed yield.     \*/    struct {        bool in_spin_loop;        bool dy_eligible;    } spin_loop;\#endif    bool preempted;    struct kvm_vcpu_arch arch;  //当前VCPU虚拟的架构，默认介绍X86};</pre><p>借着看kvm_arch_vcpu_create，它借助kvm_x86_ops-&gt;vcpu_create即vmx_create_vcpu完成任务，vmx是X86硬件虚拟化层，从代码看，qemu用户态是一层，kernel 中KVM通用代码是一层，类似kvm_x86_ops是一层，针对各个不同硬件架构，而vcpu_vmx则是具体架构的虚拟化方案一层。首先是kvm_vcpu_init初始化，主要是填充结构体，可以注意的是vcpu-&gt;run分派了一页内存，下面有kvm_arch_vcpu_init负责填充x86 CPU结构体，下面就是kvm_vcpu_arch：</p><pre class="lang:c decode:1 hljs cpp">struct kvm_vcpu_arch {    /*     \* rip and regs accesses must go through     \* kvm_{register,rip}_{read,write} functions.     \*/unsignedlong regs[NR_VCPU_REGS];    u32 regs_avail;    u32 regs_dirty;//类似这些寄存器就是就是用来缓存真正的CPU值的unsignedlong cr0;    unsignedlong cr0_guest_owned_bits;    unsignedlong cr2;    unsignedlong cr3;    unsigned long cr4;    unsigned long cr4_guest_owned_bits;    unsigned long cr8;    u32 hflags;    u64 efer;    u64 apic_base;    struct kvm_lapic *apic;    /* kernel irqchip context */    unsigned long apic_attention;    int32_t apic_arb_prio;    int mp_state;    u64 ia32_misc_enable_msr;    bool tpr_access_reporting;    u64 ia32_xss;    /*     \* Paging state of the vcpu     \*     \* If the vcpu runs in guest mode with two level paging this still saves     \* the paging mode of the l1 guest. This context is always used to     \* handle faults.     \*/    struct kvm_mmu mmu; //内存管理，更多的是附带了直接操作函数    /*     \* Paging state of an L2 guest (used for nested npt)     \*     \* This context will save all necessary information to walk page tables     \* of the an L2 guest. This context is only initialized for page table     \* walking and not for faulting since we never handle l2 page faults on     \* the host.     \*/    struct kvm_mmu nested_mmu;    /*     \* Pointer to the mmu context currently used for     \* gva_to_gpa translations.     \*/    struct kvm_mmu *walk_mmu;    struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;    struct kvm_mmu_memory_cache mmu_page_cache;    struct kvm_mmu_memory_cache mmu_page_header_cache;    struct fpu guest_fpu;    u64 xcr0;    u64 guest_supported_xcr0;    u32 guest_xstate_size;    struct kvm_pio_request pio;    void *pio_data;    u8 event_exit_inst_len;    struct kvm_queued_exception {        bool pending;        bool has_error_code;        bool reinject;        u8 nr;        u32 error_code;    } exception;    struct kvm_queued_interrupt {        bool pending;        bool soft;        u8 nr;    } interrupt;    int halt_request; /* real mode on Intel only */    int cpuid_nent;    struct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];    int maxphyaddr;    /* emulate context *///下面是KVM的软件模拟模式，也就是没有vmx的情况，估计也没人用这一套    struct x86_emulate_ctxt emulate_ctxt;    bool emulate_regs_need_sync_to_vcpu;    bool emulate_regs_need_sync_from_vcpu;    int (*complete_userspace_io)(struct kvm_vcpu *vcpu);    gpa_t time;    struct pvclock_vcpu_time_info hv_clock;    unsigned int hw_tsc_khz;    struct gfn_to_hva_cache pv_time;    bool pv_time_enabled;    /* set guest stopped flag in pvclock flags field */    bool pvclock_set_guest_stopped_request;    struct {        u64 msr_val;        u64 last_steal;        u64 accum_steal;        struct gfn_to_hva_cache stime;        struct kvm_steal_time steal;    } st;    u64 last_guest_tsc;    u64 last_host_tsc;    u64 tsc_offset_adjustment;    u64 this_tsc_nsec;    u64 this_tsc_write;    u64 this_tsc_generation;    bool tsc_catchup;    bool tsc_always_catchup;    s8 virtual_tsc_shift;    u32 virtual_tsc_mult;    u32 virtual_tsc_khz;    s64 ia32_tsc_adjust_msr;    atomic_t nmi_queued;  /* unprocessed asynchronous NMIs */    unsigned nmi_pending; /* NMI queued after currently running handler */    bool nmi_injected;    /* Trying to inject an NMI this entry */    struct mtrr_state_type mtrr_state;    u64 pat;    unsigned switch_db_regs;    unsigned long db[KVM_NR_DB_REGS];    unsigned long dr6;    unsigned long dr7;    unsigned long eff_db[KVM_NR_DB_REGS];    unsigned long guest_debug_dr7;    u64 mcg_cap;    u64 mcg_status;    u64 mcg_ctl;    u64 *mce_banks;    /* Cache MMIO info */    u64 mmio_gva;    unsigned access;    gfn_t mmio_gfn;    u64 mmio_gen;    struct kvm_pmu pmu;    /* used for guest single stepping over the given code position */    unsigned long singlestep_rip;    /* fields used by HYPER-V emulation */    u64 hv_vapic;    cpumask_var_t wbinvd_dirty_mask;    unsigned long last_retry_eip;    unsigned long last_retry_addr;    struct {        bool halted;        gfn_t gfns[roundup_pow_of_two(ASYNC_PF_PER_VCPU)];        struct gfn_to_hva_cache data;        u64 msr_val;        u32 id;        bool send_user_only;    } apf;    /* OSVW MSRs (AMD only) */    struct {        u64 length;        u64 status;    } osvw;    struct {        u64 msr_val;        struct gfn_to_hva_cache data;    } pv_eoi;    /*     \* Indicate whether the access faults on its page table in guest     \* which is set when fix page fault and used to detect unhandeable     \* instruction.     \*/    bool write_fault_to_shadow_pgtable;    /* set at EPT violation at this point */    unsigned long exit_qualification;    /* pv related host specific info */    struct {        bool pv_unhalted;    } pv;};</pre><p>整个arch结构真是长，很适合凑篇幅，很多结构其他过程涉及到的再提吧，反正我也不知道。<br>kvm_arch_vcpu_init初始化了x86在虚拟化底层的实现函数，首先是pv和emulate_ctxt，这些不支持VMX下的模拟虚拟化，尤其是vcpu-&gt;arch.emulate_ctxt.ops = &amp;emulate_ops，emulate_ops初始化虚拟化模拟的对象函数。</p><pre class="lang:c decode:1 hljs bash">static struct x86_emulate_ops emulate_ops = {    .read_std            = kvm_read_guest_virt_system,    .write_std           = kvm_write_guest_virt_system,    .fetch               = kvm_fetch_guest_virt,    .read_emulated       = emulator_read_emulated,    .write_emulated      = emulator_write_emulated,    .cmpxchg_emulated    = emulator_cmpxchg_emulated,    .invlpg              = emulator_invlpg,    .pio_in_emulated     = emulator_pio_in_emulated,    .pio_out_emulated    = emulator_pio_out_emulated,    .get_segment         = emulator_get_segment,    .set_segment         = emulator_set_segment,    .get_cached_segment_base = emulator_get_cached_segment_base,    .get_gdt             = emulator_get_gdt,    .get_idt         = emulator_get_idt,    .set_gdt             = emulator_set_gdt,    .set_idt         = emulator_set_idt,    .get_cr              = emulator_get_cr,    .set_cr              = emulator_set_cr,    .cpl                 = emulator_get_cpl,    .get_dr              = emulator_get_dr,    .set_dr              = emulator_set_dr,    .set_msr             = emulator_set_msr,    .get_msr             = emulator_get_msr,    .halt                = emulator_halt,    .wbinvd              = emulator_wbinvd,    .fix_hypercall       = emulator_fix_hypercall,    .get_fpu             = emulator_get_fpu,    .put_fpu             = emulator_put_fpu,    .intercept           = emulator_intercept,    .get_cpuid           = emulator_get_cpuid,};</pre><p>x86_emulate_ops函数看看就好，实际上也很少有人放弃vmx直接软件模拟。后面又有mp_state，给pio_data分配了一个page，kvm_set_tsc_khz设置TSC，kvm_mmu_create则是初始化MMU的函数，里面的函数都是地址转换的重点，在内存虚拟化重点提到。kvm_create_lapic初始化lapic，初始化mce_banks结构，还有pv_time,xcr0,xstat,pmu等，类似x86硬件结构上需要存在的，OS底层需要看到的硬件名称都要有对应的软件结构。<br>回到vmx_create_vcpu，vmx的guest_msrs分配得到一个page，后面是vmcs的分配，vmx-&gt;loaded_vmcs-&gt;vmcs = alloc_vmcs()，alloc_vmcs为当前cpu执行alloc_vmcs_cpu，alloc_vmcs_cpu中alloc_pages_exact_node分配给vmcs，alloc_pages_exact_node调用__alloc_pages实现，原来以为vmcs占用了一个page，但此处从<a href="http://www.oenhan.com/size-512-slab-kmalloc" title="从size-512内存泄露看slab分配" target="_blank" rel="noopener">伙伴系统</a>申请了2^vmcs_config.order页，此处vmcs_config在setup_vmcs_config中初始化，vmcs_conf-&gt;order = get_order(vmcs_config.size)，而vmcs_conf-&gt;size = vmx_msr_high &amp; 0x1fff，又rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high)，此处size由于与0x1fff与运算，大小必然小于4k，order则为0，然来绕去还是一个page大小。这么做估计是为了兼容vmcs_config中的size计算。<br>下面根据vmm_exclusive进行kvm_cpu_vmxon，进入vmx模式，初始化loaded_vmcs，然后用kvm_cpu_vmxoff退出vmx模式。<br>vmx_vcpu_load加载VCPU的信息，切换到指定cpu，进入到vmx模式，将loaded_vmcs的vmcs和当前cpu的vmcs绑定到一起。vmx_vcpu_setup则是初始化vmcs内容，主要是赋值计算，下面的vmx_vcpu_put则是vmx_vcpu_load的反运算。下面还有一些apic，nested，pml就不说了。<br>vmx_create_vcpu结束就直接回到kvm_vm_ioctl_create_vcpu函数，下面是kvm_arch_vcpu_setup，整个就一条线到kvm_arch_vcpu_load函数，主要有kvm_x86_ops-&gt;vcpu_load(vcpu, cpu)和tsc处理，vcpu_load就是vmx_vcpu_load，刚说了，就是进入vcpu模式下准备工作。<br>kvm_arch_vcpu_setup后面是create_vcpu_fd为proc创建控制fd，让qemu使用。kvm_arch_vcpu_postcreate则是马后炮般，重新vcpu_load，写msr，tsc。<br>如此整个vcpu就创建完成了。</p><p>6.KVM_RUN</p><p>KVM run涉及内容也不少，先写完内存虚拟化之后再开篇专门写RUN流程。</p><p>下一篇：</p><p><a href="http://www.oenhan.com/kvm-src-4-mem" target="_blank" rel="noopener">KVM源代码分析4:内存虚拟化</a></p><p>———-完———-</p><p>——————–下面未编辑的留存————————————-<br>给vmcs分配空间并初始化，在alloc_vmcs_cpu分配一个<a href="http://www.oenhan.com/linux-kernel-khugepaged" title="hugepage内存管理机制" target="_blank" rel="noopener">页大小内存</a>，用来保存vm和vmm信息。</p><pre class="lang:c decode:1 hljs php">    vmx->vmcs = alloc_vmcs();    if (!vmx->vmcs)        goto free_msrs;    vmcs_init(vmx->vmcs);</pre><p>执行vm entry的时候将vmm状态保存到vmcs的host area，并加载对应vm的vmcs guest area信息到CPU中，vm exit的时候则反之，vmcs具体结构分配由硬件实现，程序员只需要通过VMWRITE和VMREAD指令去访问。</p><p>vmx执行完后，回到kvm_vm_ioctl_create_vcpu函数。kvm_arch_vcpu_reset对vcpu的结构进行初始化，后面一些就是检查vcpu的合法性，最后和kvm串接到一起。</p><p>vcpu的创建到此结束，下面说一下vcpu的运行。</p><p>VCPU一旦创建成功，后续的控制基本上从kvm_vcpu_ioctl开始，控制开关有KVM_RUN，KVM_GET_REGS，KVM_SET_REGS，KVM_GET_SREGS，KVM_SET_SREGS，KVM_GET_MP_STATE，KVM_SET_MP_STATE，KVM_TRANSLATE，KVM_SET_GUEST_DEBUG，KVM_SET_SIGNAL_MASK等，如果不清楚具体开关作用，可以直接到qemu搜索对应开关代码，一目了然。</p><p>KVM_RUN的实现函数是kvm_arch_vcpu_ioctl_run，进行安全检查之后进入__vcpu_run中，在while循环里面调用vcpu_enter_guest进入guest模式，首先处理vcpu-&gt;requests，对应的request做处理，kvm_mmu_reload加载mmu，通过kvm_x86_ops-&gt;prepare_guest_switch(vcpu)准备陷入到guest，prepare_guest_switch实现是vmx_save_host_state，顾名思义，就是保存host的当前状态。</p><pre class="lang:c decode:1 hljs php">kvm_x86_ops->prepare_guest_switch(vcpu);    if (vcpu->fpu_active)        kvm_load_guest_fpu(vcpu);    kvm_load_guest_xcr0(vcpu);    vcpu->mode = IN_GUEST_MODE;    /* We should set ->mode before check ->requests,     \* see the comment in make_all_cpus_request.     \*/    smp_mb();    local_irq_disable();</pre><p>然后加载guest的寄存器等信息，fpu，xcr0,将vcpu模式设置为guest状态，屏蔽中断响应，准备进入guest。但仍进行一次检查，vcpu-&gt;mode和vcpu-&gt;requests等，如果有问题，则恢复host状态。</p><p>kvm_guest_enter做了两件事：account_system_vtime计算虚拟机<a href="http://www.oenhan.com/glibc_pthread_cond_timedwait_disable" title="Glibc更新导致pthread_cond_timedwait失效" target="_blank" rel="noopener">系统时间</a>；rcu_virt_note_context_switch对rcu锁数据进行保护，完成上下文切换。</p><p>准备工作搞定，kvm_x86_ops-&gt;run(vcpu)，开始运行guest，由vmx_vcpu_run实现。</p><pre class="lang:c decode:1 hljs php">if (vmx->emulation_required && emulate_invalid_guest_state)        return;    if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))        vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);    if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))        vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);</pre><p>判断模拟器，RSP，RIP寄存器值。</p><p>主要功能在这段内联汇编上</p><pre class="lang:c decode:1 hljs cpp">asm(                /* Store host registers */        "push %%"R"dx; push %%"R"bp;"        "push %%"R"cx nt" /* placeholder for guest rcx */        "push %%"R"cx nt"//如果vcpu host rsp和环境不等，则将其拷贝到vpu上        "cmp %%"R"sp, %c[host_rsp](%0) nt""je 1f nt""mov %%"R"sp, %c[host_rsp](%0) nt"        __ex(ASM_VMX_VMWRITE_RSP_RDX) "nt"//__kvm_handle_fault_on_reboot write host rsp"1: nt"/* Reload cr2 if changed */        "mov %c[cr2](%0), %%"R"ax nt"        "mov %%cr2, %%"R"dx nt"                //环境上cr2值和vpu上的值不同，则将vpu上值拷贝到环境上        "cmp %%"R"ax, %%"R"dx nt"        "je 2f nt"        "mov %%"R"ax, %%cr2 nt"        "2: nt"        /* Check if vmlaunch of vmresume is needed */        "cmpl $0, %c[launched](%0) nt"        /* Load guest registers.  Don't clobber flags. */        "mov %c[rax](%0), %%"R"ax nt"        "mov %c[rbx](%0), %%"R"bx nt"        "mov %c[rdx](%0), %%"R"dx nt"        "mov %c[rsi](%0), %%"R"si nt"        "mov %c[rdi](%0), %%"R"di nt"        "mov %c[rbp](%0), %%"R"bp nt"\#ifdef CONFIG_X86_64        "mov %c[r8](%0),  %%r8  nt"        "mov %c[r9](%0),  %%r9  nt"        "mov %c[r10](%0), %%r10 nt"        "mov %c[r11](%0), %%r11 nt"        "mov %c[r12](%0), %%r12 nt"        "mov %c[r13](%0), %%r13 nt"        "mov %c[r14](%0), %%r14 nt"        "mov %c[r15](%0), %%r15 nt"\#endif        "mov %c[rcx](%0), %%"R"cx nt" /* kills %0 (ecx) */        /* Enter guest mode */                //此处和cmpl $0, %c[launched](%0)是对应的，此处选择进入guest的两种模式                //RESUME和LAUNCH，通过__ex  __kvm_handle_fault_on_reboot执行        "jne .Llaunched nt"        __ex(ASM_VMX_VMLAUNCH) "nt"        "jmp .Lkvm_vmx_return nt"        ".Llaunched: " __ex(ASM_VMX_VMRESUME) "nt"                 //退出vmx，保存guest信息，加载host信息        ".Lkvm_vmx_return: "        /* Save guest registers, load host registers, keep flags */        "mov %0, %c[wordsize](%%"R"sp) nt"        "pop %0 nt"        "mov %%"R"ax, %c[rax](%0) nt"        "mov %%"R"bx, %c[rbx](%0) nt"        "pop"Q" %c[rcx](%0) nt"        "mov %%"R"dx, %c[rdx](%0) nt"        "mov %%"R"si, %c[rsi](%0) nt"        "mov %%"R"di, %c[rdi](%0) nt"        "mov %%"R"bp, %c[rbp](%0) nt"\#ifdef CONFIG_X86_64        "mov %%r8,  %c[r8](%0) nt"        "mov %%r9,  %c[r9](%0) nt"        "mov %%r10, %c[r10](%0) nt"        "mov %%r11, %c[r11](%0) nt"        "mov %%r12, %c[r12](%0) nt"        "mov %%r13, %c[r13](%0) nt"        "mov %%r14, %c[r14](%0) nt"        "mov %%r15, %c[r15](%0) nt"\#endif        "mov %%cr2, %%"R"ax   nt"        "mov %%"R"ax, %c[cr2](%0) nt"        "pop  %%"R"bp; pop  %%"R"dx nt"        "setbe %c[fail](%0) nt"          : : "c"(vmx), "d"((unsigned long)HOST_RSP),//下面加了前面寄存器的指针值，对应具体结构的值        [launched]"i"(offsetof(struct vcpu_vmx, launched)),        [fail]"i"(offsetof(struct vcpu_vmx, fail)),        [host_rsp]"i"(offsetof(struct vcpu_vmx, host_rsp)),        [rax]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),        [rbx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),        [rcx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),        [rdx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),        [rsi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),        [rdi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),        [rbp]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\#ifdef CONFIG_X86_64        [r8]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),        [r9]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),        [r10]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),        [r11]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),        [r12]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),        [r13]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),        [r14]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),        [r15]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\#endif        [cr2]"i"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),        [wordsize]"i"(sizeof(ulong))          : "cc", "memory"        , R"ax", R"bx", R"di", R"si"\#ifdef CONFIG_X86_64        , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"\#endif</pre><p>以上代码相对容易理解的，根据注释大致清楚了具体作用。</p><p>然后就是恢复系统NMI等中断:</p><pre class="lang:c decode:1 hljs bash">vmx_complete_atomic_exit(vmx);vmx_recover_nmi_blocking(vmx);vmx_complete_interrupts(vmx);</pre><p>回到vcpu_enter_guest，通过hw_breakpoint_restore恢复<a href="http://www.oenhan.com/jprobe-hw-breakpoint" title="内核调试方法:Jprobe与硬件断点" target="_blank" rel="noopener">硬件断点</a>。</p><pre class="lang:c decode:1 hljs php">if (hw_breakpoint_active())        hw_breakpoint_restore();    kvm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.last_guest_tsc);//设置vcpu模式，恢复host相关内容    vcpu->mode = OUTSIDE_GUEST_MODE;    smp_wmb();    local_irq_enable();    ++vcpu->stat.exits;    /*     \* We must have an instruction between local_irq_enable() and     \* kvm_guest_exit(), so the timer interrupt isn't delayed by     \* the interrupt shadow.  The stat.exits increment will do nicely.     \* But we need to prevent reordering, hence this barrier():     \*/    barrier();//刷新系统时间    kvm_guest_exit();    preempt_enable();    vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);    /*     \* Profile KVM exit RIPs:     \*/    if (unlikely(prof_on == KVM_PROFILING)) {        unsigned long rip = kvm_rip_read(vcpu);        profile_hit(KVM_PROFILING, (void *)rip);    }    kvm_lapic_sync_from_vapic(vcpu);//处理vmx退出    r = kvm_x86_ops->handle_exit(vcpu);</pre><p>handle_exit退出函数由vmx_handle_exit实现，主要设置vcpu-&gt;run-&gt;exit_reason，让外部感知退出原因，并对应处理。对于vpu而言，handle_exit只是意味着一个传统linux一个时间片的结束，后续的工作都是由handle完成的，handle_exit对应的函数集如下：</p><pre class="lang:c decode:1 hljs objectivec">staticint (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception,    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,    [EXIT_REASON_NMI_WINDOW]          = handle_nmi_window,    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,    [EXIT_REASON_CR_ACCESS]               = handle_cr,    [EXIT_REASON_DR_ACCESS]               = handle_dr,    [EXIT_REASON_CPUID]                   = handle_cpuid,    [EXIT_REASON_MSR_READ]                = handle_rdmsr,    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,    [EXIT_REASON_HLT]                     = handle_halt,    [EXIT_REASON_INVD]              = handle_invd,    [EXIT_REASON_INVLPG]              = handle_invlpg,    [EXIT_REASON_VMCALL]                  = handle_vmcall,    [EXIT_REASON_VMCLEAR]                  = handle_vmx_insn,    [EXIT_REASON_VMLAUNCH]                = handle_vmx_insn,    [EXIT_REASON_VMPTRLD]                 = handle_vmx_insn,    [EXIT_REASON_VMPTRST]                 = handle_vmx_insn,    [EXIT_REASON_VMREAD]                  = handle_vmx_insn,    [EXIT_REASON_VMRESUME]                = handle_vmx_insn,    [EXIT_REASON_VMWRITE]                 = handle_vmx_insn,    [EXIT_REASON_VMOFF]                   = handle_vmx_insn,    [EXIT_REASON_VMON]                    = handle_vmx_insn,    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,    [EXIT_REASON_WBINVD]                  = handle_wbinvd,    [EXIT_REASON_XSETBV]                  = handle_xsetbv,    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,    [EXIT_REASON_EPT_VIOLATION]          = handle_ept_violation,    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,    [EXIT_REASON_MWAIT_INSTRUCTION]          = handle_invalid_op,    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,};</pre><p>有handle_task_switch进行<a href="http://www.oenhan.com/rwsem-realtime-task-hung" title="读写信号量与实时进程阻塞挂死问题" target="_blank" rel="noopener">任务切换</a>，handle_io处理qemu的外部模拟IO等，具体处理内容后面在写。</p><p>再次退回到__vcpu_run函数，在while (r &gt; 0)中，循环受vcpu_enter_guest返回值控制，只有运行异常的时候才退出循环，否则通过kvm_resched一直运行下去。</p><pre class="lang:c decode:1 hljs php">if (need_resched()) {            srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);            kvm_resched(vcpu);            vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);        }</pre><p>再退就到了kvm_arch_vcpu_ioctl_run函数，此时kvm run的执行也结束。</p><p>KVM cpu虚拟化的理解基本如上，涉及到的具体细节有时间后开篇另说。</p><p>KVM源代码分析未完待续</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM源代码分析2:虚拟机的创建与运行</title>
      <link href="/2014/12/11/kvm-src-2-vm-run/"/>
      <url>/2014/12/11/kvm-src-2-vm-run/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="http://oenhan.com/kvm-src-2-vm-run" target="_blank" rel="noopener">http://oenhan.com/kvm-src-2-vm-run</a></p><p>前段时间挖了一个坑，<a href="http://www.oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM源代码分析1:基本工作原理</a>，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和<a href="http://www.oenhan.com/size-512-slab-kmalloc" title="从size-512内存泄露看slab分配" target="_blank" rel="noopener">内核态驱动</a>kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从<a href="http://www.oenhan.com/sort-optimal-solution" title="比较排序的最优解" target="_blank" rel="noopener">虚拟机</a>的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。</p><p>代码：</p><p>QEMU：git://git.qemu.org/qemu.git v2.4.0</p><p>KVM：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v4.2</p><p>QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。</p><p>使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。</p><p>而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。</p><p>所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。</p><p>所有看QEMU和KVM的配合流程如下：</p><p><img src="/2014/12/11/kvm-src-2-vm-run/qemu_create_kvm_vm-1.png" alt=""></p><p>接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出<a href="http://www.oenhan.com/5w2h" title="5W2H:技术活动逻辑方法" target="_blank" rel="noopener">处理函数</a>，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：</p><pre class="lang:c decode:1 hljs cpp">typedef enum {    MODULE_INIT_BLOCK,    MODULE_INIT_MACHINE,    MODULE_INIT_QAPI,    MODULE_INIT_QOM,    MODULE_INIT_MAX} module_init_type;</pre><p>最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种<a href="http://www.oenhan.com/ext3-jbd-journal" title="journal block device代码分析" target="_blank" rel="noopener">模拟设备</a>，具体可以参考<a href="http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。" target="_blank" rel="noopener">http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。</a> module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图<br><img src="/2014/12/11/kvm-src-2-vm-run/qemu_module_init-1.png" alt=""></p><p>它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e-&gt;init()完成功能的，而e-&gt;init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有</p><pre class="lang:c decode:1 hljs cpp">\#define block_init(function) module_init(function, MODULE_INIT_BLOCK)\#define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\#define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\#define type_init(function) module_init(function, MODULE_INIT_QOM)</pre><p>那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine_init_##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有</p><pre class="lang:c decode:1 hljs cpp">\#define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn)staticvoid pc_init_\##suffix(MachineState *machine)    {        void (*compat)(MachineState *m) = (compatfn);        if (compat) {            compat(machine);        }        pc_init1(machine);    }    DEFINE_PC_MACHINE(suffix, name, pc_init_\##suffix, optionfn)\#define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)    static void pc_machine_\##suffix##_class_init(ObjectClass *oc, void *data)    {        MachineClass *mc = MACHINE_CLASS(oc);        optsfn(mc);        mc->name = namestr;        mc->init = initfn;    }    static const TypeInfo pc_machine_type_\##suffix = {        .name       = namestr TYPE_MACHINE_SUFFIX,        .parent     = TYPE_PC_MACHINE,        .class_init = pc_machine_\##suffix##_class_init,    };    static void pc_machine_init_\##suffix(void)    {        type_register(&pc_machine_type_\##suffix);    }    machine_init(pc_machine_init_\##suffix)</pre><p>DEFINE_PC_MACHINE注册的函数pc_init_##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc-&gt;init，其他爱看不看吧。<br>而module_init的宏是</p><pre class="lang:c decode:1 hljs cpp">\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \## function(void){    register_dso_module_init(function, type);}\#else/* This should not be used directly.  Use block_init etc. instead.  */\#define module_init(function, type)static void __attribute__((constructor)) do_qemu_init_ \## function(void){    register_module_init(function, type);}</pre><p>它前面的修饰是<strong>attribute</strong>((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-&gt; kvm_accel_type -&gt; kvm_accel_class_init -&gt; kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。<br>如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机<a href="http://www.oenhan.com/kernel-deadlock-check" title="Linux内核死锁检测机制" target="_blank" rel="noopener">句柄</a>。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对<a href="http://www.oenhan.com/size-512-slab-kmalloc" title="从size-512内存泄露看slab分配" target="_blank" rel="noopener">内存管理</a>的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。</p><p>这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc-&gt;init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。</p><p>下面涉及对OPT入参的解析过程略过不提。 qemu准备<a href="http://www.oenhan.com/cgroups-src-1" title="Cgroups源码分析1:基本概念与框架" target="_blank" rel="noopener">模拟的机器</a>的类型从下面语句获得:</p><pre class="lang:c decode:1 hljs nginx">current_machine = MACHINE(object_new(object_class_get_name(                          OBJECT_CLASS(machine_class))));</pre><p>machine_class则是通过入参传入的</p><pre class="lang:c decode:1 hljs bash">case QEMU_OPTION_machine:                olist = qemu_find_opts("machine");                opts = qemu_opts_parse_noisily(olist, optarg, true);                if (!opts) {                    exit(1);                }                break;</pre><p>man qemu</p><pre class="lang:shell decode:1 hljs sql">       -machine [type=]name[,prop=value[,...]]           Select the emulated machine by name.           Use "-machine help" to list available machines</pre><p>下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class-&gt;init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。</p><p>现在进入pc_init1函数：</p><p>在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。<br>pc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看</p><pre class="lang:c decode:1 hljs objectivec">    {        .name = "SandyBridge",        .level = 0xd,        .vendor = CPUID_VENDOR_INTEL,        .family = 6,        .model = 42,        .stepping = 1,        .features[FEAT_1_EDX] =            CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |            CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |            CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |            CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |            CPUID_DE | CPUID_FP87,        .features[FEAT_1_ECX] =            CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |            CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |            CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |            CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |            CPUID_EXT_SSE3,        .features[FEAT_8000_0001_EDX] =            CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |            CPUID_EXT2_SYSCALL,        .features[FEAT_8000_0001_ECX] =            CPUID_EXT3_LAHF_LM,        .features[FEAT_XSAVE] =            CPUID_XSAVE_XSAVEOPT,        .features[FEAT_6_EAX] =            CPUID_6_EAX_ARAT,        .xlevel = 0x80000008,        .model_id = "Intel Xeon E312xx (Sandy Bridge)",    },</pre><p>你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。<br>然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，<br>主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：</p><pre class="lang:c decode:1 hljs php">//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn    qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,                       cpu, QEMU_THREAD_JOINABLE);    //如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的    while (!cpu->created) {        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);    }</pre><p>线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作</p><pre class="lang:c decode:1 hljs cpp">\#define type_init(function) module_init(function, MODULE_INIT_QOM)</pre><p>从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：</p><pre class="lang:c decode:1 hljs objectivec">//初始化VCPU    r = kvm_init_vcpu(env);//初始化KVM中断    qemu_kvm_init_cpu_signals(env);//标志VCPU创建完成，和上面判断是对应的    cpu->created = true;    qemu_cond_signal(&qemu_cpu_cond);    while (1) {        if (cpu_can_run(env)) {          //CPU进入执行状态            r = kvm_cpu_exec(env);            if (r == EXCP_DEBUG) {                cpu_handle_guest_debug(env);            }        }        qemu_kvm_wait_io_event(env);    }</pre><p>CPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env-&gt;kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。<br>qemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看<a href="http://www.oenhan.com/size-512-slab-kmalloc" title="从size-512内存泄露看slab分配" target="_blank" rel="noopener">内存的初始化</a>。<br>内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。<br><img src="/2014/12/11/kvm-src-2-vm-run/qemu_memory_module-1.bmp" alt=""></p><p>qemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。<br>而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页<a href="http://www.oenhan.com/ubuntu-debuginfo-package" title="ubuntu下载debuginfo deb进行调试" target="_blank" rel="noopener">对齐分配</a>内存。后续的都是对RAMBlock的插入等处理。<br>从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。<br>vmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr-&gt;name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。<br>后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr-&gt;owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。<br>memory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。<br>下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：</p><pre class="lang:c decode:1 hljs php">while (iold < old_view->nr || inew < new_view->nr) {        if (iold < old_view->nr) {            frold = &old_view->ranges[iold];        } else {            frold = NULL;        }        if (inew < new_view->nr) {            frnew = &new_view->ranges[inew];        } else {            frnew = NULL;        }        if (frold            && (!frnew                || int128_lt(frold->addr.start, frnew->addr.start)                || (int128_eq(frold->addr.start, frnew->addr.start)                    && !flatrange_equal(frold, frnew)))) {            /* In old but not in new, or in both but attributes changed. */            if (!adding) { //这个判断代码添加的无用，可以直接删除,                //address_space_update_topology里面的两个pass也可以删除一个                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);            }            ++iold;        } else if (frold && frnew && flatrange_equal(frold, frnew)) {            /* In both and unchanged (except logging may have changed) */            if (adding) {                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);                if (frold->dirty_log_mask && !frnew->dirty_log_mask) {                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);                } else if (frnew->dirty_log_mask && !frold->dirty_log_mask) {                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);                }            }            ++iold;            ++inew;        } else {            /* In new */            if (adding) {                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);            }            ++inew;        }    }</pre><p>重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem)传递给kernel。<br>我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。<br>内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：</p><pre class="lang:c decode:1 hljs bash">while (1) {        if (cpu_can_run(cpu)) {            r = kvm_cpu_exec(cpu);            if (r == EXCP_DEBUG) {                cpu_handle_guest_debug(cpu);            }        }        qemu_kvm_wait_io_event(cpu);    }</pre><p>判断条件就是cpu_can_run函数，即cpu-&gt;stop &amp;&amp; cpu-&gt;stopped &amp;&amp; current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的</p><pre class="lang:c decode:1 hljs cpp">void vm_start(void){    if (!runstate_is_running()) {        cpu_enable_ticks();        runstate_set(RUN_STATE_RUNNING);        vm_state_notify(1, RUN_STATE_RUNNING);        resume_all_vcpus();        monitor_protocol_event(QEVENT_RESUME, NULL);    }}</pre><p>如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM源代码分析1:基本工作原理</title>
      <link href="/2014/12/11/kvm-src-1/"/>
      <url>/2014/12/11/kvm-src-1/</url>
      
        <content type="html"><![CDATA[<p>原文出自：<a href="http://oenhan.com/kvm-src-1" target="_blank" rel="noopener">http://oenhan.com/kvm-src-1</a><br>文章写作以及技术水平远远在我之上，感觉自己无力写出如此精炼的文章，膜拜并转发</p><h4 id="1-KVM模型结构"><a href="#1-KVM模型结构" class="headerlink" title="1.KVM模型结构"></a>1.KVM模型结构</h4><p>为什么有OS虚拟化？随着CPU计算能力的提高，单独的OS已不能充分利用CPU的计算能力，1.很多应用的执行需要单独占用一个OS环境，如安全测试等；2.而IAAS云计算厂商也是以OS为范围销售计算能力。那么在所有虚拟化方案中，都是由hypervisor取代原生的OS去控制具体硬件资源，而同时hypervisor将资源分配具体的VM，VM中运行的是没有修改过的OS，如果让VM中的OS能正常运行，hypervisor的任务就是模拟具体的硬件资源，让OS不能识别出是真是假。</p><p><img src="/2014/12/11/kvm-src-1/hypervisor-1.png" alt=""></p><p>当然上面的模型是Xen示例，OS对应用而言是硬件资源管理中心，那么hypervisor就是具体VM的OS了，KVM是就利用了这一点，利用现有的kernel代码，构建了一个hypervisor，这个样子<a href="http://www.oenhan.com/kernel-program-exec" target="_blank" rel="noopener">内存分配</a>，<a href="http://www.oenhan.com/task-group-sched" target="_blank" rel="noopener">进程调度</a>等就无需重写代码，如此hypervisor就是所谓的host，VM中的OS就是guest。</p><p>guest OS保证具体运行场景中的程序正常执行，而KVM的代码则部署在HOST上，Userspace对应的是QEMU，Kernel对应的是KVM Driver，KVM Driver负责模拟虚拟机的CPU运行，<a href="http://www.oenhan.com/size-512-slab-kmalloc" title="从size-512内存泄露看slab分配" target="_blank" rel="noopener">内存管理</a>，设备管理等；QEMU则模拟虚拟机的IO设备接口以及用户态控制接口。QEMU通过KVM等fd进行IOCTL控制KVM驱动的运行过程。</p><p><img src="/2014/12/11/kvm-src-1/kvm_arch_map-1.png" alt=""></p><p>如上图所示，guest自身有自己的用户模式和<a href="http://www.oenhan.com/iowait-wa-vmstat" title="iowait的形成原因和内核分析" target="_blank" rel="noopener">内核模式</a>；guest是在host中是作为一个用户态进程存在的，这个进程就是qemu，qemu本身就是一个虚拟化程序，只是纯软件虚拟化效率很低，它被KVM进行改造后，作为KVM的前端存在，用来进行<a href="http://www.oenhan.com/cpu-load-balance" title="Linux内核CPU负载均衡机制" target="_blank" rel="noopener">创建进程</a>或者IO交互等；而KVM Driver则是Linux内核模式，它提供KVM fd给qemu调用，用来进行cpu虚拟化，内存虚拟化等。QEMU通KVM提供的fd接口，通过ioctl系统调用创建和运行虚拟机。KVM Driver使得整个Linux成为一个虚拟机监控器，负责接收qemu模拟效率很低的命令。</p><h4 id="2-KVM工作原理"><a href="#2-KVM工作原理" class="headerlink" title="2.KVM工作原理"></a>2.KVM工作原理</h4><p><img src="/2014/12/11/kvm-src-1/kvm_process-1.png" alt=""></p><p>上图是一个执行过程图，首先启动一个虚拟化管理软件qemu，开始启动一个虚拟机，通过ioctl等系统调用向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执行 VMLAUCH 指令，即进入了guest代码执行过程。如果 Guest OS 发生外部中断或者影子页表缺页之类的事件，暂停 Guest OS 的执行，退出QEMU即guest VM-exit，进行一些必要的处理，然后重新进入客户模式，执行guest代码；这个时候如果是io请求，则提交给用户态下的qemu处理，qemu处理后再次通过IOCTL反馈给KVM驱动。</p><h4 id="3-CPU虚拟化"><a href="#3-CPU虚拟化" class="headerlink" title="3.CPU虚拟化"></a>3.CPU虚拟化</h4><p>X86体系结构CPU虚拟化技术的称为 Intel VT-x 技术，引入了VMX，提供了两种处理器的工作环境。 VMCS 结构实现两种环境之间的切换。 VM Entry 使虚拟机进去guest模式，VM Exit 使虚拟机退出guest模式。</p><p>VMM调度guest执行时，qemu 通过 ioctl <a href="http://www.oenhan.com/kernel-program-exec" target="_blank" rel="noopener">系统调用</a>进入内核模式，在 KVM Driver中获得当前物理 CPU的引用。之后将guest状态从VMCS中读出， 并装入物理CPU中。执行 VMLAUCH 指令使得物理处理器进入非根操作环境，运行guest OS代码。</p><p>当 guest OS 执行一些特权指令或者外部事件时， 比如I/O访问，对控制寄存器的操作，MSR的读写等， 都会导致物理CPU发生 VMExit， 停止运行 Guest OS，将 Guest OS保存到VMCS中， Host 状态装入物理处理器中， 处理器进入根操作环境，KVM取得控制权，通过读取 VMCS 中 VM_EXIT_REASON 字段得到引起 VM Exit 的原因。 从而调用kvm_exit_handler 处理函数。 如果由于 I/O 获得信号到达，则退出到userspace模式的 Qemu 处理。处理完毕后，重新进入guest模式运行虚拟 CPU。</p><h4 id="4-Mem虚拟化"><a href="#4-Mem虚拟化" class="headerlink" title="4.Mem虚拟化"></a>4.Mem虚拟化</h4><p>OS对于物理内存主要有两点认识：1.物理地址从0开始；2.<a href="http://www.oenhan.com/kernel-program-exec" target="_blank" rel="noopener">内存地址</a>是连续的。VMM接管了所有内存，但guest OS的对内存的使用就存在这两点冲突了，除此之外，一个guest对内存的操作很有可能影响到另外一个guest乃至host的运行。VMM的内存虚拟化就要解决这些问题。</p><p>在OS代码中，应用也是占用所有的逻辑地址，同时不影响其他应用的关键点在于有线性地址这个中间层；解决方法则是添加了一个中间层：guest物理地址空间；guest看到是从0开始的guest物理地址空间（类比从0开始的线性地址），而且是连续的，虽然有些地址没有映射；同时guest物理地址映射到不同的host逻辑地址，如此保证了VM之间的安全性要求。</p><p>这样MEM虚拟化就是GVA-&gt;GPA-&gt;HPA的寻址过程，传统软件方法有影子页表，硬件虚拟化提供了EPT支持。</p><p>总体描述到此，后面代码里面见真相。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2014/01/01/hello-world/"/>
      <url>/2014/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h3><p><div id="flowchart-0" class="flow-chart"></div></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始op=>operation: My Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op&</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
